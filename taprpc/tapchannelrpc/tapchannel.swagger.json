{
  "swagger": "2.0",
  "info": {
    "title": "tapchannelrpc/tapchannel.proto",
    "version": "version not set"
  },
  "tags": [
    {
      "name": "TaprootAssetChannels"
    }
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/v1/taproot-assets/channels/encode-custom-data": {
      "post": {
        "summary": "EncodeCustomRecords allows RPC users to encode Taproot Asset channel related\ndata into the TLV format that is used in the custom records of the lnd\npayment or other channel related RPCs. This RPC is completely stateless and\ndoes not perform any checks on the data provided, other than pure format\nvalidation.",
        "operationId": "TaprootAssetChannels_EncodeCustomRecords",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/tapchannelrpcEncodeCustomRecordsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/tapchannelrpcEncodeCustomRecordsRequest"
            }
          }
        ],
        "tags": [
          "TaprootAssetChannels"
        ]
      }
    },
    "/v1/taproot-assets/channels/fund": {
      "get": {
        "summary": "FundChannel initiates the channel funding negotiation with a peer for the\ncreation of a channel that contains a specified amount of a given asset.",
        "operationId": "TaprootAssetChannels_FundChannel",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/tapchannelrpcFundChannelResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "asset_amount",
            "description": "The asset amount to fund the channel with. The BTC amount is fixed and\ncannot be customized (for now).",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "asset_id",
            "description": "The asset ID to use for the channel funding.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "peer_pubkey",
            "description": "The public key of the peer to open the channel with. Must already be\nconnected to this peer.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "fee_rate_sat_per_vbyte",
            "description": "The channel funding fee rate in sat/vByte.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "push_sat",
            "description": "The number of satoshis to give the remote side as part of the initial\ncommitment state. This is equivalent to first opening a channel and then\nsending the remote party funds, but all done in one step. Therefore, this\nis equivalent to a donation to the remote party, unless they reimburse\nthe funds in another way (outside the protocol).",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "TaprootAssetChannels"
        ]
      }
    },
    "/v1/taproot-assets/channels/invoice": {
      "post": {
        "summary": "AddInvoice is a wrapper around lnd's lnrpc.AddInvoice method with asset\nspecific parameters. It allows RPC users to create invoices that correspond\nto the specified asset amount.",
        "operationId": "TaprootAssetChannels_AddInvoice",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/tapchannelrpcAddInvoiceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/tapchannelrpcAddInvoiceRequest"
            }
          }
        ],
        "tags": [
          "TaprootAssetChannels"
        ]
      }
    },
    "/v1/taproot-assets/channels/send-payment": {
      "post": {
        "summary": "SendPayment is a wrapper around lnd's routerrpc.SendPaymentV2 RPC method\nwith asset specific parameters. It allows RPC users to send asset keysend\npayments (direct payments) or payments to an invoice with a specified asset\namount.",
        "operationId": "TaprootAssetChannels_SendPayment",
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "$ref": "#/definitions/tapchannelrpcSendPaymentResponse"
                },
                "error": {
                  "$ref": "#/definitions/rpcStatus"
                }
              },
              "title": "Stream result of tapchannelrpcSendPaymentResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/tapchannelrpcSendPaymentRequest"
            }
          }
        ],
        "tags": [
          "TaprootAssetChannels"
        ]
      }
    }
  },
  "definitions": {
    "FailureFailureCode": {
      "type": "string",
      "enum": [
        "RESERVED",
        "INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS",
        "INCORRECT_PAYMENT_AMOUNT",
        "FINAL_INCORRECT_CLTV_EXPIRY",
        "FINAL_INCORRECT_HTLC_AMOUNT",
        "FINAL_EXPIRY_TOO_SOON",
        "INVALID_REALM",
        "EXPIRY_TOO_SOON",
        "INVALID_ONION_VERSION",
        "INVALID_ONION_HMAC",
        "INVALID_ONION_KEY",
        "AMOUNT_BELOW_MINIMUM",
        "FEE_INSUFFICIENT",
        "INCORRECT_CLTV_EXPIRY",
        "CHANNEL_DISABLED",
        "TEMPORARY_CHANNEL_FAILURE",
        "REQUIRED_NODE_FEATURE_MISSING",
        "REQUIRED_CHANNEL_FEATURE_MISSING",
        "UNKNOWN_NEXT_PEER",
        "TEMPORARY_NODE_FAILURE",
        "PERMANENT_NODE_FAILURE",
        "PERMANENT_CHANNEL_FAILURE",
        "EXPIRY_TOO_FAR",
        "MPP_TIMEOUT",
        "INVALID_ONION_PAYLOAD",
        "INVALID_ONION_BLINDING",
        "INTERNAL_FAILURE",
        "UNKNOWN_FAILURE",
        "UNREADABLE_FAILURE"
      ],
      "default": "RESERVED",
      "description": " - RESERVED: The numbers assigned in this enumeration match the failure codes as\ndefined in BOLT #4. Because protobuf 3 requires enums to start with 0,\na RESERVED value is added.\n - INTERNAL_FAILURE: An internal error occurred.\n - UNKNOWN_FAILURE: The error source is known, but the failure itself couldn't be decoded.\n - UNREADABLE_FAILURE: An unreadable failure result is returned if the received failure message\ncannot be decrypted. In that case the error source is unknown."
    },
    "HTLCAttemptHTLCStatus": {
      "type": "string",
      "enum": [
        "IN_FLIGHT",
        "SUCCEEDED",
        "FAILED"
      ],
      "default": "IN_FLIGHT"
    },
    "InvoiceInvoiceState": {
      "type": "string",
      "enum": [
        "OPEN",
        "SETTLED",
        "CANCELED",
        "ACCEPTED"
      ],
      "default": "OPEN"
    },
    "lnrpcAMP": {
      "type": "object",
      "properties": {
        "root_share": {
          "type": "string",
          "format": "byte",
          "description": "An n-of-n secret share of the root seed from which child payment hashes\nand preimages are derived."
        },
        "set_id": {
          "type": "string",
          "format": "byte",
          "description": "An identifier for the HTLC set that this HTLC belongs to."
        },
        "child_index": {
          "type": "integer",
          "format": "int64",
          "description": "A nonce used to randomize the child preimage and child hash from a given\nroot_share."
        },
        "hash": {
          "type": "string",
          "format": "byte",
          "description": "The payment hash of the AMP HTLC."
        },
        "preimage": {
          "type": "string",
          "format": "byte",
          "description": "The preimage used to settle this AMP htlc. This field will only be\npopulated if the invoice is in InvoiceState_ACCEPTED or\nInvoiceState_SETTLED."
        }
      },
      "description": "Details specific to AMP HTLCs."
    },
    "lnrpcAMPInvoiceState": {
      "type": "object",
      "properties": {
        "state": {
          "$ref": "#/definitions/lnrpcInvoiceHTLCState",
          "description": "The state the HTLCs associated with this setID are in."
        },
        "settle_index": {
          "type": "string",
          "format": "uint64",
          "description": "The settle index of this HTLC set, if the invoice state is settled."
        },
        "settle_time": {
          "type": "string",
          "format": "int64",
          "description": "The time this HTLC set was settled expressed in unix epoch."
        },
        "amt_paid_msat": {
          "type": "string",
          "format": "int64",
          "description": "The total amount paid for the sub-invoice expressed in milli satoshis."
        }
      }
    },
    "lnrpcAMPRecord": {
      "type": "object",
      "properties": {
        "root_share": {
          "type": "string",
          "format": "byte"
        },
        "set_id": {
          "type": "string",
          "format": "byte"
        },
        "child_index": {
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "lnrpcAddInvoiceResponse": {
      "type": "object",
      "properties": {
        "r_hash": {
          "type": "string",
          "format": "byte"
        },
        "payment_request": {
          "type": "string",
          "description": "A bare-bones invoice for a payment within the Lightning Network. With the\ndetails of the invoice, the sender has all the data necessary to send a\npayment to the recipient."
        },
        "add_index": {
          "type": "string",
          "format": "uint64",
          "description": "The \"add\" index of this invoice. Each newly created invoice will increment\nthis index making it monotonically increasing. Callers to the\nSubscribeInvoices call can use this to instantly get notified of all added\ninvoices with an add_index greater than this one."
        },
        "payment_addr": {
          "type": "string",
          "format": "byte",
          "description": "The payment address of the generated invoice. This is also called\npayment secret in specifications (e.g. BOLT 11). This value should be used\nin all payments for this invoice as we require it for end to end security."
        }
      }
    },
    "lnrpcChannelUpdate": {
      "type": "object",
      "properties": {
        "signature": {
          "type": "string",
          "format": "byte",
          "description": "The signature that validates the announced data and proves the ownership\nof node id."
        },
        "chain_hash": {
          "type": "string",
          "format": "byte",
          "description": "The target chain that this channel was opened within. This value\nshould be the genesis hash of the target chain. Along with the short\nchannel ID, this uniquely identifies the channel globally in a\nblockchain."
        },
        "chan_id": {
          "type": "string",
          "format": "uint64",
          "description": "The unique description of the funding transaction."
        },
        "timestamp": {
          "type": "integer",
          "format": "int64",
          "description": "A timestamp that allows ordering in the case of multiple announcements.\nWe should ignore the message if timestamp is not greater than the\nlast-received."
        },
        "message_flags": {
          "type": "integer",
          "format": "int64",
          "description": "The bitfield that describes whether optional fields are present in this\nupdate. Currently, the least-significant bit must be set to 1 if the\noptional field MaxHtlc is present."
        },
        "channel_flags": {
          "type": "integer",
          "format": "int64",
          "description": "The bitfield that describes additional meta-data concerning how the\nupdate is to be interpreted. Currently, the least-significant bit must be\nset to 0 if the creating node corresponds to the first node in the\npreviously sent channel announcement and 1 otherwise. If the second bit\nis set, then the channel is set to be disabled."
        },
        "time_lock_delta": {
          "type": "integer",
          "format": "int64",
          "description": "The minimum number of blocks this node requires to be added to the expiry\nof HTLCs. This is a security parameter determined by the node operator.\nThis value represents the required gap between the time locks of the\nincoming and outgoing HTLC's set to this node."
        },
        "htlc_minimum_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The minimum HTLC value which will be accepted."
        },
        "base_fee": {
          "type": "integer",
          "format": "int64",
          "description": "The base fee that must be used for incoming HTLC's to this particular\nchannel. This value will be tacked onto the required for a payment\nindependent of the size of the payment."
        },
        "fee_rate": {
          "type": "integer",
          "format": "int64",
          "description": "The fee rate that will be charged per millionth of a satoshi."
        },
        "htlc_maximum_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The maximum HTLC value which will be accepted."
        },
        "extra_opaque_data": {
          "type": "string",
          "format": "byte",
          "description": "The set of data that was appended to this message, some of which we may\nnot actually know how to iterate or parse. By holding onto this data, we\nensure that we're able to properly validate the set of signatures that\ncover these new fields, and ensure we're able to make upgrades to the\nnetwork in a forwards compatible manner."
        }
      }
    },
    "lnrpcFailure": {
      "type": "object",
      "properties": {
        "code": {
          "$ref": "#/definitions/FailureFailureCode",
          "title": "Failure code as defined in the Lightning spec"
        },
        "channel_update": {
          "$ref": "#/definitions/lnrpcChannelUpdate",
          "description": "An optional channel update message."
        },
        "htlc_msat": {
          "type": "string",
          "format": "uint64",
          "description": "A failure type-dependent htlc value."
        },
        "onion_sha_256": {
          "type": "string",
          "format": "byte",
          "description": "The sha256 sum of the onion payload."
        },
        "cltv_expiry": {
          "type": "integer",
          "format": "int64",
          "description": "A failure type-dependent cltv expiry value."
        },
        "flags": {
          "type": "integer",
          "format": "int64",
          "description": "A failure type-dependent flags value."
        },
        "failure_source_index": {
          "type": "integer",
          "format": "int64",
          "description": "The position in the path of the intermediate or final node that generated\nthe failure message. Position zero is the sender node."
        },
        "height": {
          "type": "integer",
          "format": "int64",
          "description": "A failure type-dependent block height."
        }
      }
    },
    "lnrpcFeature": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "is_required": {
          "type": "boolean"
        },
        "is_known": {
          "type": "boolean"
        }
      }
    },
    "lnrpcFeatureBit": {
      "type": "string",
      "enum": [
        "DATALOSS_PROTECT_REQ",
        "DATALOSS_PROTECT_OPT",
        "INITIAL_ROUING_SYNC",
        "UPFRONT_SHUTDOWN_SCRIPT_REQ",
        "UPFRONT_SHUTDOWN_SCRIPT_OPT",
        "GOSSIP_QUERIES_REQ",
        "GOSSIP_QUERIES_OPT",
        "TLV_ONION_REQ",
        "TLV_ONION_OPT",
        "EXT_GOSSIP_QUERIES_REQ",
        "EXT_GOSSIP_QUERIES_OPT",
        "STATIC_REMOTE_KEY_REQ",
        "STATIC_REMOTE_KEY_OPT",
        "PAYMENT_ADDR_REQ",
        "PAYMENT_ADDR_OPT",
        "MPP_REQ",
        "MPP_OPT",
        "WUMBO_CHANNELS_REQ",
        "WUMBO_CHANNELS_OPT",
        "ANCHORS_REQ",
        "ANCHORS_OPT",
        "ANCHORS_ZERO_FEE_HTLC_REQ",
        "ANCHORS_ZERO_FEE_HTLC_OPT",
        "ROUTE_BLINDING_REQUIRED",
        "ROUTE_BLINDING_OPTIONAL",
        "AMP_REQ",
        "AMP_OPT"
      ],
      "default": "DATALOSS_PROTECT_REQ"
    },
    "lnrpcHTLCAttempt": {
      "type": "object",
      "properties": {
        "attempt_id": {
          "type": "string",
          "format": "uint64",
          "description": "The unique ID that is used for this attempt."
        },
        "status": {
          "$ref": "#/definitions/HTLCAttemptHTLCStatus",
          "description": "The status of the HTLC."
        },
        "route": {
          "$ref": "#/definitions/lnrpcRoute",
          "description": "The route taken by this HTLC."
        },
        "attempt_time_ns": {
          "type": "string",
          "format": "int64",
          "description": "The time in UNIX nanoseconds at which this HTLC was sent."
        },
        "resolve_time_ns": {
          "type": "string",
          "format": "int64",
          "description": "The time in UNIX nanoseconds at which this HTLC was settled or failed.\nThis value will not be set if the HTLC is still IN_FLIGHT."
        },
        "failure": {
          "$ref": "#/definitions/lnrpcFailure",
          "description": "Detailed htlc failure info."
        },
        "preimage": {
          "type": "string",
          "format": "byte",
          "description": "The preimage that was used to settle the HTLC."
        }
      }
    },
    "lnrpcHop": {
      "type": "object",
      "properties": {
        "chan_id": {
          "type": "string",
          "format": "uint64",
          "description": "The unique channel ID for the channel. The first 3 bytes are the block\nheight, the next 3 the index within the block, and the last 2 bytes are the\noutput index for the channel."
        },
        "chan_capacity": {
          "type": "string",
          "format": "int64"
        },
        "amt_to_forward": {
          "type": "string",
          "format": "int64"
        },
        "fee": {
          "type": "string",
          "format": "int64"
        },
        "expiry": {
          "type": "integer",
          "format": "int64"
        },
        "amt_to_forward_msat": {
          "type": "string",
          "format": "int64"
        },
        "fee_msat": {
          "type": "string",
          "format": "int64"
        },
        "pub_key": {
          "type": "string",
          "description": "An optional public key of the hop. If the public key is given, the payment\ncan be executed without relying on a copy of the channel graph."
        },
        "tlv_payload": {
          "type": "boolean",
          "description": "If set to true, then this hop will be encoded using the new variable length\nTLV format. Note that if any custom tlv_records below are specified, then\nthis field MUST be set to true for them to be encoded properly."
        },
        "mpp_record": {
          "$ref": "#/definitions/lnrpcMPPRecord",
          "description": "An optional TLV record that signals the use of an MPP payment. If present,\nthe receiver will enforce that the same mpp_record is included in the final\nhop payload of all non-zero payments in the HTLC set. If empty, a regular\nsingle-shot payment is or was attempted."
        },
        "amp_record": {
          "$ref": "#/definitions/lnrpcAMPRecord",
          "description": "An optional TLV record that signals the use of an AMP payment. If present,\nthe receiver will treat all received payments including the same\n(payment_addr, set_id) pair  as being part of one logical payment. The\npayment will be settled by XORing the root_share's together and deriving the\nchild hashes and preimages according to BOLT XX. Must be used in conjunction\nwith mpp_record."
        },
        "custom_records": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "byte"
          },
          "description": "An optional set of key-value TLV records. This is useful within the context\nof the SendToRoute call as it allows callers to specify arbitrary K-V pairs\nto drop off at each hop within the onion."
        },
        "metadata": {
          "type": "string",
          "format": "byte",
          "description": "The payment metadata to send along with the payment to the payee."
        },
        "blinding_point": {
          "type": "string",
          "format": "byte",
          "description": "Blinding point is an optional blinding point included for introduction\nnodes in blinded paths. This field is mandatory for hops that represents\nthe introduction point in a blinded path."
        },
        "encrypted_data": {
          "type": "string",
          "format": "byte",
          "description": "Encrypted data is a receiver-produced blob of data that provides hops\nin a blinded route with forwarding data. As this data is encrypted by\nthe recipient, we will not be able to parse it - it is essentially an\narbitrary blob of data from our node's perspective. This field is\nmandatory for all hops in a blinded path, including the introduction\nnode."
        },
        "total_amt_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The total amount that is sent to the recipient (possibly across multiple\nHTLCs), as specified by the sender when making a payment to a blinded path.\nThis value is only set in the final hop payload of a blinded payment. This\nvalue is analogous to the MPPRecord that is used for regular (non-blinded)\nMPP payments."
        }
      }
    },
    "lnrpcHopHint": {
      "type": "object",
      "properties": {
        "node_id": {
          "type": "string",
          "description": "The public key of the node at the start of the channel."
        },
        "chan_id": {
          "type": "string",
          "format": "uint64",
          "description": "The unique identifier of the channel."
        },
        "fee_base_msat": {
          "type": "integer",
          "format": "int64",
          "description": "The base fee of the channel denominated in millisatoshis."
        },
        "fee_proportional_millionths": {
          "type": "integer",
          "format": "int64",
          "description": "The fee rate of the channel for sending one satoshi across it denominated in\nmillionths of a satoshi."
        },
        "cltv_expiry_delta": {
          "type": "integer",
          "format": "int64",
          "description": "The time-lock delta of the channel."
        }
      }
    },
    "lnrpcInvoice": {
      "type": "object",
      "properties": {
        "memo": {
          "type": "string",
          "description": "An optional memo to attach along with the invoice. Used for record keeping\npurposes for the invoice's creator, and will also be set in the description\nfield of the encoded payment request if the description_hash field is not\nbeing used."
        },
        "r_preimage": {
          "type": "string",
          "format": "byte",
          "description": "The hex-encoded preimage (32 byte) which will allow settling an incoming\nHTLC payable to this preimage. When using REST, this field must be encoded\nas base64."
        },
        "r_hash": {
          "type": "string",
          "format": "byte",
          "description": "The hash of the preimage. When using REST, this field must be encoded as\nbase64.\nNote: Output only, don't specify for creating an invoice."
        },
        "value": {
          "type": "string",
          "format": "int64",
          "description": "The fields value and value_msat are mutually exclusive.",
          "title": "The value of this invoice in satoshis"
        },
        "value_msat": {
          "type": "string",
          "format": "int64",
          "description": "The fields value and value_msat are mutually exclusive.",
          "title": "The value of this invoice in millisatoshis"
        },
        "settled": {
          "type": "boolean",
          "description": "Whether this invoice has been fulfilled.\n\nThe field is deprecated. Use the state field instead (compare to SETTLED)."
        },
        "creation_date": {
          "type": "string",
          "format": "int64",
          "description": "When this invoice was created.\nMeasured in seconds since the unix epoch.\nNote: Output only, don't specify for creating an invoice."
        },
        "settle_date": {
          "type": "string",
          "format": "int64",
          "description": "When this invoice was settled.\nMeasured in seconds since the unix epoch.\nNote: Output only, don't specify for creating an invoice."
        },
        "payment_request": {
          "type": "string",
          "description": "A bare-bones invoice for a payment within the Lightning Network. With the\ndetails of the invoice, the sender has all the data necessary to send a\npayment to the recipient.\nNote: Output only, don't specify for creating an invoice."
        },
        "description_hash": {
          "type": "string",
          "format": "byte",
          "description": "Hash (SHA-256) of a description of the payment. Used if the description of\npayment (memo) is too long to naturally fit within the description field\nof an encoded payment request. When using REST, this field must be encoded\nas base64."
        },
        "expiry": {
          "type": "string",
          "format": "int64",
          "description": "Payment request expiry time in seconds. Default is 86400 (24 hours)."
        },
        "fallback_addr": {
          "type": "string",
          "description": "Fallback on-chain address."
        },
        "cltv_expiry": {
          "type": "string",
          "format": "uint64",
          "description": "Delta to use for the time-lock of the CLTV extended to the final hop."
        },
        "route_hints": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/lnrpcRouteHint"
          },
          "description": "Route hints that can each be individually used to assist in reaching the\ninvoice's destination."
        },
        "private": {
          "type": "boolean",
          "description": "Whether this invoice should include routing hints for private channels.\nNote: When enabled, if value and value_msat are zero, a large number of\nhints with these channels can be included, which might not be desirable."
        },
        "add_index": {
          "type": "string",
          "format": "uint64",
          "description": "The \"add\" index of this invoice. Each newly created invoice will increment\nthis index making it monotonically increasing. Callers to the\nSubscribeInvoices call can use this to instantly get notified of all added\ninvoices with an add_index greater than this one.\nNote: Output only, don't specify for creating an invoice."
        },
        "settle_index": {
          "type": "string",
          "format": "uint64",
          "description": "The \"settle\" index of this invoice. Each newly settled invoice will\nincrement this index making it monotonically increasing. Callers to the\nSubscribeInvoices call can use this to instantly get notified of all\nsettled invoices with an settle_index greater than this one.\nNote: Output only, don't specify for creating an invoice."
        },
        "amt_paid": {
          "type": "string",
          "format": "int64",
          "description": "Deprecated, use amt_paid_sat or amt_paid_msat."
        },
        "amt_paid_sat": {
          "type": "string",
          "format": "int64",
          "description": "The amount that was accepted for this invoice, in satoshis. This will ONLY\nbe set if this invoice has been settled or accepted. We provide this field\nas if the invoice was created with a zero value, then we need to record what\namount was ultimately accepted. Additionally, it's possible that the sender\npaid MORE that was specified in the original invoice. So we'll record that\nhere as well.\nNote: Output only, don't specify for creating an invoice."
        },
        "amt_paid_msat": {
          "type": "string",
          "format": "int64",
          "description": "The amount that was accepted for this invoice, in millisatoshis. This will\nONLY be set if this invoice has been settled or accepted. We provide this\nfield as if the invoice was created with a zero value, then we need to\nrecord what amount was ultimately accepted. Additionally, it's possible that\nthe sender paid MORE that was specified in the original invoice. So we'll\nrecord that here as well.\nNote: Output only, don't specify for creating an invoice."
        },
        "state": {
          "$ref": "#/definitions/InvoiceInvoiceState",
          "description": "The state the invoice is in.\nNote: Output only, don't specify for creating an invoice."
        },
        "htlcs": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/lnrpcInvoiceHTLC"
          },
          "description": "List of HTLCs paying to this invoice [EXPERIMENTAL].\nNote: Output only, don't specify for creating an invoice."
        },
        "features": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/lnrpcFeature"
          },
          "description": "List of features advertised on the invoice.\nNote: Output only, don't specify for creating an invoice."
        },
        "is_keysend": {
          "type": "boolean",
          "description": "Indicates if this invoice was a spontaneous payment that arrived via keysend\n[EXPERIMENTAL].\nNote: Output only, don't specify for creating an invoice."
        },
        "payment_addr": {
          "type": "string",
          "format": "byte",
          "description": "The payment address of this invoice. This is also called payment secret in\nspecifications (e.g. BOLT 11). This value will be used in MPP payments, and\nalso for newer invoices that always require the MPP payload for added\nend-to-end security.\nNote: Output only, don't specify for creating an invoice."
        },
        "is_amp": {
          "type": "boolean",
          "description": "Signals whether or not this is an AMP invoice."
        },
        "amp_invoice_state": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/lnrpcAMPInvoiceState"
          },
          "description": "Maps a 32-byte hex-encoded set ID to the sub-invoice AMP state for the\ngiven set ID. This field is always populated for AMP invoices, and can be\nused along side LookupInvoice to obtain the HTLC information related to a\ngiven sub-invoice.\nNote: Output only, don't specify for creating an invoice.",
          "title": "[EXPERIMENTAL]:"
        }
      }
    },
    "lnrpcInvoiceHTLC": {
      "type": "object",
      "properties": {
        "chan_id": {
          "type": "string",
          "format": "uint64",
          "description": "Short channel id over which the htlc was received."
        },
        "htlc_index": {
          "type": "string",
          "format": "uint64",
          "description": "Index identifying the htlc on the channel."
        },
        "amt_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The amount of the htlc in msat."
        },
        "accept_height": {
          "type": "integer",
          "format": "int32",
          "description": "Block height at which this htlc was accepted."
        },
        "accept_time": {
          "type": "string",
          "format": "int64",
          "description": "Time at which this htlc was accepted."
        },
        "resolve_time": {
          "type": "string",
          "format": "int64",
          "description": "Time at which this htlc was settled or canceled."
        },
        "expiry_height": {
          "type": "integer",
          "format": "int32",
          "description": "Block height at which this htlc expires."
        },
        "state": {
          "$ref": "#/definitions/lnrpcInvoiceHTLCState",
          "description": "Current state the htlc is in."
        },
        "custom_records": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "byte"
          },
          "description": "Custom tlv records."
        },
        "mpp_total_amt_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The total amount of the mpp payment in msat."
        },
        "amp": {
          "$ref": "#/definitions/lnrpcAMP",
          "description": "Details relevant to AMP HTLCs, only populated if this is an AMP HTLC."
        },
        "wire_custom_records": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "byte"
          },
          "description": "Custom tlv records that were only sent on the p2p wire message, not in\nthe onion."
        }
      },
      "title": "Details of an HTLC that paid to an invoice"
    },
    "lnrpcInvoiceHTLCState": {
      "type": "string",
      "enum": [
        "ACCEPTED",
        "SETTLED",
        "CANCELED"
      ],
      "default": "ACCEPTED"
    },
    "lnrpcMPPRecord": {
      "type": "object",
      "properties": {
        "payment_addr": {
          "type": "string",
          "format": "byte",
          "description": "A unique, random identifier used to authenticate the sender as the intended\npayer of a multi-path payment. The payment_addr must be the same for all\nsubpayments, and match the payment_addr provided in the receiver's invoice.\nThe same payment_addr must be used on all subpayments. This is also called\npayment secret in specifications (e.g. BOLT 11)."
        },
        "total_amt_msat": {
          "type": "string",
          "format": "int64",
          "description": "The total amount in milli-satoshis being sent as part of a larger multi-path\npayment. The caller is responsible for ensuring subpayments to the same node\nand payment_hash sum exactly to total_amt_msat. The same\ntotal_amt_msat must be used on all subpayments."
        }
      }
    },
    "lnrpcPayment": {
      "type": "object",
      "properties": {
        "payment_hash": {
          "type": "string",
          "title": "The payment hash"
        },
        "value": {
          "type": "string",
          "format": "int64",
          "description": "Deprecated, use value_sat or value_msat."
        },
        "creation_date": {
          "type": "string",
          "format": "int64",
          "title": "Deprecated, use creation_time_ns"
        },
        "fee": {
          "type": "string",
          "format": "int64",
          "description": "Deprecated, use fee_sat or fee_msat."
        },
        "payment_preimage": {
          "type": "string",
          "title": "The payment preimage"
        },
        "value_sat": {
          "type": "string",
          "format": "int64",
          "title": "The value of the payment in satoshis"
        },
        "value_msat": {
          "type": "string",
          "format": "int64",
          "title": "The value of the payment in milli-satoshis"
        },
        "payment_request": {
          "type": "string",
          "description": "The optional payment request being fulfilled."
        },
        "status": {
          "$ref": "#/definitions/lnrpcPaymentPaymentStatus",
          "description": "The status of the payment."
        },
        "fee_sat": {
          "type": "string",
          "format": "int64",
          "title": "The fee paid for this payment in satoshis"
        },
        "fee_msat": {
          "type": "string",
          "format": "int64",
          "title": "The fee paid for this payment in milli-satoshis"
        },
        "creation_time_ns": {
          "type": "string",
          "format": "int64",
          "description": "The time in UNIX nanoseconds at which the payment was created."
        },
        "htlcs": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/lnrpcHTLCAttempt"
          },
          "description": "The HTLCs made in attempt to settle the payment."
        },
        "payment_index": {
          "type": "string",
          "format": "uint64",
          "description": "The creation index of this payment. Each payment can be uniquely identified\nby this index, which may not strictly increment by 1 for payments made in\nolder versions of lnd."
        },
        "failure_reason": {
          "$ref": "#/definitions/lnrpcPaymentFailureReason"
        }
      }
    },
    "lnrpcPaymentFailureReason": {
      "type": "string",
      "enum": [
        "FAILURE_REASON_NONE",
        "FAILURE_REASON_TIMEOUT",
        "FAILURE_REASON_NO_ROUTE",
        "FAILURE_REASON_ERROR",
        "FAILURE_REASON_INCORRECT_PAYMENT_DETAILS",
        "FAILURE_REASON_INSUFFICIENT_BALANCE"
      ],
      "default": "FAILURE_REASON_NONE",
      "description": " - FAILURE_REASON_NONE: Payment isn't failed (yet).\n - FAILURE_REASON_TIMEOUT: There are more routes to try, but the payment timeout was exceeded.\n - FAILURE_REASON_NO_ROUTE: All possible routes were tried and failed permanently. Or were no\nroutes to the destination at all.\n - FAILURE_REASON_ERROR: A non-recoverable error has occured.\n - FAILURE_REASON_INCORRECT_PAYMENT_DETAILS: Payment details incorrect (unknown hash, invalid amt or\ninvalid final cltv delta)\n - FAILURE_REASON_INSUFFICIENT_BALANCE: Insufficient local balance."
    },
    "lnrpcPaymentPaymentStatus": {
      "type": "string",
      "enum": [
        "UNKNOWN",
        "IN_FLIGHT",
        "SUCCEEDED",
        "FAILED",
        "INITIATED"
      ],
      "default": "UNKNOWN",
      "description": " - UNKNOWN: Deprecated. This status will never be returned.\n - IN_FLIGHT: Payment has inflight HTLCs.\n - SUCCEEDED: Payment is settled.\n - FAILED: Payment is failed.\n - INITIATED: Payment is created and has not attempted any HTLCs."
    },
    "lnrpcRoute": {
      "type": "object",
      "properties": {
        "total_time_lock": {
          "type": "integer",
          "format": "int64",
          "description": "The cumulative (final) time lock across the entire route. This is the CLTV\nvalue that should be extended to the first hop in the route. All other hops\nwill decrement the time-lock as advertised, leaving enough time for all\nhops to wait for or present the payment preimage to complete the payment."
        },
        "total_fees": {
          "type": "string",
          "format": "int64",
          "description": "The sum of the fees paid at each hop within the final route. In the case\nof a one-hop payment, this value will be zero as we don't need to pay a fee\nto ourselves."
        },
        "total_amt": {
          "type": "string",
          "format": "int64",
          "description": "The total amount of funds required to complete a payment over this route.\nThis value includes the cumulative fees at each hop. As a result, the HTLC\nextended to the first-hop in the route will need to have at least this many\nsatoshis, otherwise the route will fail at an intermediate node due to an\ninsufficient amount of fees."
        },
        "hops": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/lnrpcHop"
          },
          "description": "Contains details concerning the specific forwarding details at each hop."
        },
        "total_fees_msat": {
          "type": "string",
          "format": "int64",
          "description": "The total fees in millisatoshis."
        },
        "total_amt_msat": {
          "type": "string",
          "format": "int64",
          "description": "The total amount in millisatoshis."
        }
      },
      "description": "A path through the channel graph which runs over one or more channels in\nsuccession. This struct carries all the information required to craft the\nSphinx onion packet, and send the payment along the first hop in the path. A\nroute is only selected as valid if all the channels have sufficient capacity to\ncarry the initial payment amount after fees are accounted for."
    },
    "lnrpcRouteHint": {
      "type": "object",
      "properties": {
        "hop_hints": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/lnrpcHopHint"
          },
          "description": "A list of hop hints that when chained together can assist in reaching a\nspecific destination."
        }
      }
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string"
        }
      },
      "additionalProperties": {}
    },
    "rfqrpcFixedPoint": {
      "type": "object",
      "properties": {
        "coefficient": {
          "type": "string",
          "description": "The coefficient is the fractional value scaled-up as an integer. This\ninteger is represented as a string as it may be too large to fit in a\nuint64."
        },
        "scale": {
          "type": "integer",
          "format": "int64",
          "description": "The scale is the component that determines how many decimal places\nthe coefficient should be divided by to obtain the fractional value."
        }
      },
      "description": "FixedPoint is a scaled integer representation of a fractional number.\n\nThis type consists of two integer fields: a coefficient and a scale.\nUsing this format enables precise and consistent representation of fractional\nnumbers while avoiding floating-point data types, which are prone to\nprecision errors.\n\nThe relationship between the fractional representation and its fixed-point\nrepresentation is expressed as:\n```\nV = F_c / (10^F_s)\n```\nwhere:\n\n* `V` is the fractional value.\n\n* `F_c` is the coefficient component of the fixed-point representation. It is\n   the scaled-up fractional value represented as an integer.\n\n* `F_s` is the scale component. It is an integer specifying how\n  many decimal places `F_c` should be divided by to obtain the fractional\n  representation."
    },
    "rfqrpcPeerAcceptedBuyQuote": {
      "type": "object",
      "properties": {
        "peer": {
          "type": "string",
          "description": "Quote counterparty peer."
        },
        "id": {
          "type": "string",
          "format": "byte",
          "description": "The unique identifier of the quote request."
        },
        "scid": {
          "type": "string",
          "format": "uint64",
          "description": "scid is the short channel ID of the channel over which the payment for\nthe quote should be made."
        },
        "asset_amount": {
          "type": "string",
          "format": "uint64",
          "description": "asset_amount is the amount of the subject asset."
        },
        "ask_asset_rate": {
          "$ref": "#/definitions/rfqrpcFixedPoint",
          "description": "ask_asset_rate is the asset to BTC conversion rate represented as a\nfixed-point number."
        },
        "expiry": {
          "type": "string",
          "format": "uint64",
          "description": "The unix timestamp in seconds after which the quote is no longer valid."
        }
      }
    },
    "rfqrpcPeerAcceptedSellQuote": {
      "type": "object",
      "properties": {
        "peer": {
          "type": "string",
          "description": "Quote counterparty peer."
        },
        "id": {
          "type": "string",
          "format": "byte",
          "description": "The unique identifier of the quote request."
        },
        "scid": {
          "type": "string",
          "format": "uint64",
          "description": "scid is the short channel ID of the channel over which the payment for\nthe quote should be made."
        },
        "asset_amount": {
          "type": "string",
          "format": "uint64",
          "description": "asset_amount is the amount of the subject asset."
        },
        "bid_price": {
          "type": "string",
          "format": "uint64",
          "description": "bid_price is the price in milli-satoshi per asset unit."
        },
        "expiry": {
          "type": "string",
          "format": "uint64",
          "description": "The unix timestamp in seconds after which the quote is no longer valid."
        }
      }
    },
    "routerrpcSendPaymentRequest": {
      "type": "object",
      "properties": {
        "dest": {
          "type": "string",
          "format": "byte",
          "title": "The identity pubkey of the payment recipient"
        },
        "amt": {
          "type": "string",
          "format": "int64",
          "description": "Number of satoshis to send.\n\nThe fields amt and amt_msat are mutually exclusive."
        },
        "payment_hash": {
          "type": "string",
          "format": "byte",
          "title": "The hash to use within the payment's HTLC"
        },
        "final_cltv_delta": {
          "type": "integer",
          "format": "int32",
          "description": "The CLTV delta from the current height that should be used to set the\ntimelock for the final hop."
        },
        "payment_request": {
          "type": "string",
          "description": "A bare-bones invoice for a payment within the Lightning Network.  With the\ndetails of the invoice, the sender has all the data necessary to send a\npayment to the recipient. The amount in the payment request may be zero. In\nthat case it is required to set the amt field as well. If no payment request\nis specified, the following fields are required: dest, amt and payment_hash."
        },
        "timeout_seconds": {
          "type": "integer",
          "format": "int32",
          "description": "An upper limit on the amount of time we should spend when attempting to\nfulfill the payment. This is expressed in seconds. If we cannot make a\nsuccessful payment within this time frame, an error will be returned.\nThis field must be non-zero."
        },
        "fee_limit_sat": {
          "type": "string",
          "format": "int64",
          "description": "The maximum number of satoshis that will be paid as a fee of the payment.\nIf this field is left to the default value of 0, only zero-fee routes will\nbe considered. This usually means single hop routes connecting directly to\nthe destination. To send the payment without a fee limit, use max int here.\n\nThe fields fee_limit_sat and fee_limit_msat are mutually exclusive."
        },
        "outgoing_chan_id": {
          "type": "string",
          "format": "uint64",
          "description": "Deprecated, use outgoing_chan_ids. The channel id of the channel that must\nbe taken to the first hop. If zero, any channel may be used (unless\noutgoing_chan_ids are set)."
        },
        "cltv_limit": {
          "type": "integer",
          "format": "int32",
          "description": "An optional maximum total time lock for the route. This should not\nexceed lnd's `--max-cltv-expiry` setting. If zero, then the value of\n`--max-cltv-expiry` is enforced."
        },
        "route_hints": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/lnrpcRouteHint"
          },
          "description": "Optional route hints to reach the destination through private channels."
        },
        "dest_custom_records": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "byte"
          },
          "description": "An optional field that can be used to pass an arbitrary set of TLV records\nto a peer which understands the new records. This can be used to pass\napplication specific data during the payment attempt. Record types are\nrequired to be in the custom range \u003e= 65536. When using REST, the values\nmust be encoded as base64."
        },
        "amt_msat": {
          "type": "string",
          "format": "int64",
          "description": "Number of millisatoshis to send.\n\nThe fields amt and amt_msat are mutually exclusive."
        },
        "fee_limit_msat": {
          "type": "string",
          "format": "int64",
          "description": "The maximum number of millisatoshis that will be paid as a fee of the\npayment. If this field is left to the default value of 0, only zero-fee\nroutes will be considered. This usually means single hop routes connecting\ndirectly to the destination. To send the payment without a fee limit, use\nmax int here.\n\nThe fields fee_limit_sat and fee_limit_msat are mutually exclusive."
        },
        "last_hop_pubkey": {
          "type": "string",
          "format": "byte",
          "description": "The pubkey of the last hop of the route. If empty, any hop may be used."
        },
        "allow_self_payment": {
          "type": "boolean",
          "description": "If set, circular payments to self are permitted."
        },
        "dest_features": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/lnrpcFeatureBit"
          },
          "description": "Features assumed to be supported by the final node. All transitive feature\ndependencies must also be set properly. For a given feature bit pair, either\noptional or remote may be set, but not both. If this field is nil or empty,\nthe router will try to load destination features from the graph as a\nfallback."
        },
        "max_parts": {
          "type": "integer",
          "format": "int64",
          "description": "The maximum number of partial payments that may be use to complete the full\namount."
        },
        "no_inflight_updates": {
          "type": "boolean",
          "description": "If set, only the final payment update is streamed back. Intermediate updates\nthat show which htlcs are still in flight are suppressed."
        },
        "outgoing_chan_ids": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uint64"
          },
          "description": "The channel ids of the channels are allowed for the first hop. If empty,\nany channel may be used."
        },
        "payment_addr": {
          "type": "string",
          "format": "byte",
          "description": "An optional payment addr to be included within the last hop of the route.\nThis is also called payment secret in specifications (e.g. BOLT 11)."
        },
        "max_shard_size_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The largest payment split that should be attempted when making a payment if\nsplitting is necessary. Setting this value will effectively cause lnd to\nsplit more aggressively, vs only when it thinks it needs to. Note that this\nvalue is in milli-satoshis."
        },
        "amp": {
          "type": "boolean",
          "description": "If set, an AMP-payment will be attempted."
        },
        "time_pref": {
          "type": "number",
          "format": "double",
          "description": "The time preference for this payment. Set to -1 to optimize for fees\nonly, to 1 to optimize for reliability only or a value inbetween for a mix."
        },
        "first_hop_custom_records": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "byte"
          },
          "description": "An optional field that can be used to pass an arbitrary set of TLV records\nto the first hop peer of this payment. This can be used to pass application\nspecific data during the payment attempt. Record types are required to be in\nthe custom range \u003e= 65536. When using REST, the values must be encoded as\nbase64."
        }
      }
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "tapchannelrpcAddInvoiceRequest": {
      "type": "object",
      "properties": {
        "asset_id": {
          "type": "string",
          "format": "byte",
          "description": "The asset ID to use for the invoice."
        },
        "asset_amount": {
          "type": "string",
          "format": "uint64",
          "description": "The asset amount to receive."
        },
        "peer_pubkey": {
          "type": "string",
          "format": "byte",
          "description": "The node identity public key of the peer to ask for a quote for receiving\nassets and converting them from satoshis. This must be specified if\nthere are multiple channels with the given asset ID."
        },
        "invoice_request": {
          "$ref": "#/definitions/lnrpcInvoice",
          "description": "The full lnd invoice request to send. All fields (except for the value\nand the route hints) behave the same way as they do for lnd's\nlnrpc.AddInvoice RPC method (see the API docs at\nhttps://lightning.engineering/api-docs/api/lnd/lightning/add-invoice\nfor more details). The value/value_msat fields will be overwritten by the\nsatoshi (or milli-satoshi) equivalent of the asset amount, after\nnegotiating a quote with a peer that supports the given asset ID."
        }
      }
    },
    "tapchannelrpcAddInvoiceResponse": {
      "type": "object",
      "properties": {
        "accepted_buy_quote": {
          "$ref": "#/definitions/rfqrpcPeerAcceptedBuyQuote",
          "description": "The quote for the purchase of assets that was accepted by the peer."
        },
        "invoice_result": {
          "$ref": "#/definitions/lnrpcAddInvoiceResponse",
          "description": "The result of the invoice creation."
        }
      }
    },
    "tapchannelrpcEncodeCustomRecordsRequest": {
      "type": "object",
      "properties": {
        "router_send_payment": {
          "$ref": "#/definitions/tapchannelrpcRouterSendPaymentData"
        }
      }
    },
    "tapchannelrpcEncodeCustomRecordsResponse": {
      "type": "object",
      "properties": {
        "custom_records": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "byte"
          },
          "description": "The encoded custom records in TLV format."
        }
      }
    },
    "tapchannelrpcFundChannelResponse": {
      "type": "object",
      "properties": {
        "txid": {
          "type": "string",
          "description": "The channel funding transaction ID."
        },
        "output_index": {
          "type": "integer",
          "format": "int32",
          "description": "The index of the channel funding output in the funding transaction."
        }
      }
    },
    "tapchannelrpcRouterSendPaymentData": {
      "type": "object",
      "properties": {
        "asset_amounts": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "uint64"
          },
          "description": "The string encoded asset ID to amount mapping. Instructs the router to\nuse these assets in the given amounts for the payment. Can be empty for\na payment of an invoice, if the RFQ ID is set instead."
        },
        "rfq_id": {
          "type": "string",
          "format": "byte",
          "description": "The RFQ ID to use for the payment. Can be empty for a direct keysend\npayment that doesn't involve any conversion (and thus no RFQ)."
        }
      }
    },
    "tapchannelrpcSendPaymentRequest": {
      "type": "object",
      "properties": {
        "asset_id": {
          "type": "string",
          "format": "byte",
          "description": "The asset ID to use for the payment. This must be set for both invoice\nand keysend payments, unless RFQ negotiation was already done beforehand\nand payment_request.first_hop_custom_records already contains valid RFQ\ndata."
        },
        "asset_amount": {
          "type": "string",
          "format": "uint64",
          "description": "The asset amount to send in a keysend payment. This amount is ignored for\ninvoice payments as the asset amount is negotiated through RFQ with the\npeer, depending on the invoice amount. This can also be left unset if RFQ\nnegotiation was already done beforehand and\npayment_request.first_hop_custom_records already contains valid RFQ data."
        },
        "peer_pubkey": {
          "type": "string",
          "format": "byte",
          "description": "The node identity public key of the peer to ask for a quote for sending\nout the assets and converting them to satoshis. This must be specified if\nthere are multiple channels with the given asset ID."
        },
        "payment_request": {
          "$ref": "#/definitions/routerrpcSendPaymentRequest",
          "description": "The full lnd payment request to send. All fields behave the same way as\nthey do for lnd's routerrpc.SendPaymentV2 RPC method (see the API docs\nat https://lightning.engineering/api-docs/api/lnd/router/send-payment-v2\nfor more details).\nTo send a keysend payment, the payment_request.dest_custom_records must\ncontain a valid keysend record (key 5482373484 and a 32-byte preimage\nthat corresponds to the payment hash)."
        }
      }
    },
    "tapchannelrpcSendPaymentResponse": {
      "type": "object",
      "properties": {
        "accepted_sell_order": {
          "$ref": "#/definitions/rfqrpcPeerAcceptedSellQuote",
          "description": "In case channel assets need to be swapped to another asset, an asset\nsell order is negotiated with the channel peer. The result will be\nthe first message in the response stream. If no swap is needed, the\npayment results will be streamed directly."
        },
        "payment_result": {
          "$ref": "#/definitions/lnrpcPayment",
          "description": "The payment result of a single payment attempt. Multiple attempts may\nbe returned per payment request until either the payment succeeds or\nthe payment times out."
        }
      }
    }
  }
}
