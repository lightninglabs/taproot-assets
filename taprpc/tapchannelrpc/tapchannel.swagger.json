{
  "swagger": "2.0",
  "info": {
    "title": "tapchannelrpc/tapchannel.proto",
    "version": "version not set"
  },
  "tags": [
    {
      "name": "TaprootAssetChannels"
    }
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/v1/taproot-assets/channels/encode-custom-data": {
      "post": {
        "summary": "EncodeCustomRecords allows RPC users to encode Taproot Asset channel related\ndata into the TLV format that is used in the custom records of the lnd\npayment or other channel related RPCs. This RPC is completely stateless and\ndoes not perform any checks on the data provided, other than pure format\nvalidation.",
        "operationId": "TaprootAssetChannels_EncodeCustomRecords",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/tapchannelrpcEncodeCustomRecordsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/tapchannelrpcEncodeCustomRecordsRequest"
            }
          }
        ],
        "tags": [
          "TaprootAssetChannels"
        ]
      }
    },
    "/v1/taproot-assets/channels/fund": {
      "post": {
        "summary": "FundChannel initiates the channel funding negotiation with a peer for the\ncreation of a channel that contains a specified amount of a given asset.",
        "operationId": "TaprootAssetChannels_FundChannel",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/tapchannelrpcFundChannelResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/tapchannelrpcFundChannelRequest"
            }
          }
        ],
        "tags": [
          "TaprootAssetChannels"
        ]
      }
    },
    "/v1/taproot-assets/channels/invoice": {
      "post": {
        "summary": "AddInvoice is a wrapper around lnd's lnrpc.AddInvoice method with asset\nspecific parameters. It allows RPC users to create invoices that correspond\nto the specified asset amount. If a peer pubkey is specified, then only that\npeer will be used for RFQ negotiations. If none is specified then RFQ quotes\nfor all peers with suitable asset channels will be created.",
        "operationId": "TaprootAssetChannels_AddInvoice",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/tapchannelrpcAddInvoiceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/tapchannelrpcAddInvoiceRequest"
            }
          }
        ],
        "tags": [
          "TaprootAssetChannels"
        ]
      }
    },
    "/v1/taproot-assets/channels/invoice/decode": {
      "post": {
        "summary": "DecodeAssetPayReq is similar to lnd's lnrpc.DecodePayReq, but it accepts an\nasset ID and returns the invoice amount expressed in asset units along side\nthe normal information.",
        "operationId": "TaprootAssetChannels_DecodeAssetPayReq",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/tapchannelrpcAssetPayReqResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/tapchannelrpcAssetPayReq"
            }
          }
        ],
        "tags": [
          "TaprootAssetChannels"
        ]
      }
    },
    "/v1/taproot-assets/channels/send-payment": {
      "post": {
        "summary": "SendPayment is a wrapper around lnd's routerrpc.SendPaymentV2 RPC method\nwith asset specific parameters. It allows RPC users to send asset keysend\npayments (direct payments) or payments to an invoice with a specified asset\namount.",
        "operationId": "TaprootAssetChannels_SendPayment",
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "$ref": "#/definitions/tapchannelrpcSendPaymentResponse"
                },
                "error": {
                  "$ref": "#/definitions/rpcStatus"
                }
              },
              "title": "Stream result of tapchannelrpcSendPaymentResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/tapchannelrpcSendPaymentRequest"
            }
          }
        ],
        "tags": [
          "TaprootAssetChannels"
        ]
      }
    }
  },
  "definitions": {
    "FailureFailureCode": {
      "type": "string",
      "enum": [
        "RESERVED",
        "INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS",
        "INCORRECT_PAYMENT_AMOUNT",
        "FINAL_INCORRECT_CLTV_EXPIRY",
        "FINAL_INCORRECT_HTLC_AMOUNT",
        "FINAL_EXPIRY_TOO_SOON",
        "INVALID_REALM",
        "EXPIRY_TOO_SOON",
        "INVALID_ONION_VERSION",
        "INVALID_ONION_HMAC",
        "INVALID_ONION_KEY",
        "AMOUNT_BELOW_MINIMUM",
        "FEE_INSUFFICIENT",
        "INCORRECT_CLTV_EXPIRY",
        "CHANNEL_DISABLED",
        "TEMPORARY_CHANNEL_FAILURE",
        "REQUIRED_NODE_FEATURE_MISSING",
        "REQUIRED_CHANNEL_FEATURE_MISSING",
        "UNKNOWN_NEXT_PEER",
        "TEMPORARY_NODE_FAILURE",
        "PERMANENT_NODE_FAILURE",
        "PERMANENT_CHANNEL_FAILURE",
        "EXPIRY_TOO_FAR",
        "MPP_TIMEOUT",
        "INVALID_ONION_PAYLOAD",
        "INVALID_ONION_BLINDING",
        "INTERNAL_FAILURE",
        "UNKNOWN_FAILURE",
        "UNREADABLE_FAILURE"
      ],
      "default": "RESERVED",
      "description": " - RESERVED: The numbers assigned in this enumeration match the failure codes as\ndefined in BOLT #4. Because protobuf 3 requires enums to start with 0,\na RESERVED value is added.\n - INTERNAL_FAILURE: An internal error occurred.\n - UNKNOWN_FAILURE: The error source is known, but the failure itself couldn't be decoded.\n - UNREADABLE_FAILURE: An unreadable failure result is returned if the received failure message\ncannot be decrypted. In that case the error source is unknown."
    },
    "HTLCAttemptHTLCStatus": {
      "type": "string",
      "enum": [
        "IN_FLIGHT",
        "SUCCEEDED",
        "FAILED"
      ],
      "default": "IN_FLIGHT"
    },
    "InvoiceInvoiceState": {
      "type": "string",
      "enum": [
        "OPEN",
        "SETTLED",
        "CANCELED",
        "ACCEPTED"
      ],
      "default": "OPEN"
    },
    "lnrpcAMP": {
      "type": "object",
      "properties": {
        "root_share": {
          "type": "string",
          "format": "byte",
          "description": "An n-of-n secret share of the root seed from which child payment hashes\nand preimages are derived."
        },
        "set_id": {
          "type": "string",
          "format": "byte",
          "description": "An identifier for the HTLC set that this HTLC belongs to."
        },
        "child_index": {
          "type": "integer",
          "format": "int64",
          "description": "A nonce used to randomize the child preimage and child hash from a given\nroot_share."
        },
        "hash": {
          "type": "string",
          "format": "byte",
          "description": "The payment hash of the AMP HTLC."
        },
        "preimage": {
          "type": "string",
          "format": "byte",
          "description": "The preimage used to settle this AMP htlc. This field will only be\npopulated if the invoice is in InvoiceState_ACCEPTED or\nInvoiceState_SETTLED."
        }
      },
      "description": "Details specific to AMP HTLCs."
    },
    "lnrpcAMPInvoiceState": {
      "type": "object",
      "properties": {
        "state": {
          "$ref": "#/definitions/lnrpcInvoiceHTLCState",
          "description": "The state the HTLCs associated with this setID are in."
        },
        "settle_index": {
          "type": "string",
          "format": "uint64",
          "description": "The settle index of this HTLC set, if the invoice state is settled."
        },
        "settle_time": {
          "type": "string",
          "format": "int64",
          "description": "The time this HTLC set was settled expressed in unix epoch."
        },
        "amt_paid_msat": {
          "type": "string",
          "format": "int64",
          "description": "The total amount paid for the sub-invoice expressed in milli satoshis."
        }
      }
    },
    "lnrpcAMPRecord": {
      "type": "object",
      "properties": {
        "root_share": {
          "type": "string",
          "format": "byte"
        },
        "set_id": {
          "type": "string",
          "format": "byte"
        },
        "child_index": {
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "lnrpcAddInvoiceResponse": {
      "type": "object",
      "properties": {
        "r_hash": {
          "type": "string",
          "format": "byte"
        },
        "payment_request": {
          "type": "string",
          "description": "A bare-bones invoice for a payment within the Lightning Network. With the\ndetails of the invoice, the sender has all the data necessary to send a\npayment to the recipient."
        },
        "add_index": {
          "type": "string",
          "format": "uint64",
          "description": "The \"add\" index of this invoice. Each newly created invoice will increment\nthis index making it monotonically increasing. Callers to the\nSubscribeInvoices call can use this to instantly get notified of all added\ninvoices with an add_index greater than this one."
        },
        "payment_addr": {
          "type": "string",
          "format": "byte",
          "description": "The payment address of the generated invoice. This is also called\npayment secret in specifications (e.g. BOLT 11). This value should be used\nin all payments for this invoice as we require it for end to end security."
        }
      }
    },
    "lnrpcBlindedHop": {
      "type": "object",
      "properties": {
        "blinded_node": {
          "type": "string",
          "format": "byte",
          "description": "The blinded public key of the node."
        },
        "encrypted_data": {
          "type": "string",
          "format": "byte",
          "description": "An encrypted blob of data provided to the blinded node."
        }
      }
    },
    "lnrpcBlindedPath": {
      "type": "object",
      "properties": {
        "introduction_node": {
          "type": "string",
          "format": "byte",
          "description": "The unblinded pubkey of the introduction node for the route."
        },
        "blinding_point": {
          "type": "string",
          "format": "byte",
          "description": "The ephemeral pubkey used by nodes in the blinded route."
        },
        "blinded_hops": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/lnrpcBlindedHop"
          },
          "description": "A set of blinded node keys and data blobs for the blinded portion of the\nroute. Note that the first hop is expected to be the introduction node,\nso the route is always expected to have at least one hop."
        }
      }
    },
    "lnrpcBlindedPathConfig": {
      "type": "object",
      "properties": {
        "min_num_real_hops": {
          "type": "integer",
          "format": "int64",
          "description": "The minimum number of real hops to include in a blinded path. This doesn't\ninclude our node, so if the minimum is 1, then the path will contain at\nminimum our node along with an introduction node hop. If it is zero then\nthe shortest path will use our node as an introduction node."
        },
        "num_hops": {
          "type": "integer",
          "format": "int64",
          "description": "The number of hops to include in a blinded path. This doesn't include our\nnode, so if it is 1, then the path will contain our node along with an\nintroduction node or dummy node hop. If paths shorter than NumHops is\nfound, then they will be padded using dummy hops."
        },
        "max_num_paths": {
          "type": "integer",
          "format": "int64",
          "description": "The maximum number of blinded paths to select and add to an invoice."
        },
        "node_omission_list": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          },
          "description": "A list of node IDs of nodes that should not be used in any of our generated\nblinded paths."
        }
      }
    },
    "lnrpcBlindedPaymentPath": {
      "type": "object",
      "properties": {
        "blinded_path": {
          "$ref": "#/definitions/lnrpcBlindedPath",
          "description": "The blinded path to send the payment to."
        },
        "base_fee_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The base fee for the blinded path provided, expressed in msat."
        },
        "proportional_fee_rate": {
          "type": "integer",
          "format": "int64",
          "description": "The proportional fee for the blinded path provided, expressed in parts\nper million."
        },
        "total_cltv_delta": {
          "type": "integer",
          "format": "int64",
          "description": "The total CLTV delta for the blinded path provided, including the\nfinal CLTV delta for the receiving node."
        },
        "htlc_min_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The minimum hltc size that may be sent over the blinded path, expressed\nin msat."
        },
        "htlc_max_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The maximum htlc size that may be sent over the blinded path, expressed\nin msat."
        },
        "features": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/lnrpcFeatureBit"
          },
          "description": "The feature bits for the route."
        }
      }
    },
    "lnrpcChannelUpdate": {
      "type": "object",
      "properties": {
        "signature": {
          "type": "string",
          "format": "byte",
          "description": "The signature that validates the announced data and proves the ownership\nof node id."
        },
        "chain_hash": {
          "type": "string",
          "format": "byte",
          "description": "The target chain that this channel was opened within. This value\nshould be the genesis hash of the target chain. Along with the short\nchannel ID, this uniquely identifies the channel globally in a\nblockchain."
        },
        "chan_id": {
          "type": "string",
          "format": "uint64",
          "description": "The unique description of the funding transaction."
        },
        "timestamp": {
          "type": "integer",
          "format": "int64",
          "description": "A timestamp that allows ordering in the case of multiple announcements.\nWe should ignore the message if timestamp is not greater than the\nlast-received."
        },
        "message_flags": {
          "type": "integer",
          "format": "int64",
          "description": "The bitfield that describes whether optional fields are present in this\nupdate. Currently, the least-significant bit must be set to 1 if the\noptional field MaxHtlc is present."
        },
        "channel_flags": {
          "type": "integer",
          "format": "int64",
          "description": "The bitfield that describes additional meta-data concerning how the\nupdate is to be interpreted. Currently, the least-significant bit must be\nset to 0 if the creating node corresponds to the first node in the\npreviously sent channel announcement and 1 otherwise. If the second bit\nis set, then the channel is set to be disabled."
        },
        "time_lock_delta": {
          "type": "integer",
          "format": "int64",
          "description": "The minimum number of blocks this node requires to be added to the expiry\nof HTLCs. This is a security parameter determined by the node operator.\nThis value represents the required gap between the time locks of the\nincoming and outgoing HTLC's set to this node."
        },
        "htlc_minimum_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The minimum HTLC value which will be accepted."
        },
        "base_fee": {
          "type": "integer",
          "format": "int64",
          "description": "The base fee that must be used for incoming HTLC's to this particular\nchannel. This value will be tacked onto the required for a payment\nindependent of the size of the payment."
        },
        "fee_rate": {
          "type": "integer",
          "format": "int64",
          "description": "The fee rate that will be charged per millionth of a satoshi."
        },
        "htlc_maximum_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The maximum HTLC value which will be accepted."
        },
        "extra_opaque_data": {
          "type": "string",
          "format": "byte",
          "description": "The set of data that was appended to this message, some of which we may\nnot actually know how to iterate or parse. By holding onto this data, we\nensure that we're able to properly validate the set of signatures that\ncover these new fields, and ensure we're able to make upgrades to the\nnetwork in a forwards compatible manner."
        }
      }
    },
    "lnrpcFailure": {
      "type": "object",
      "properties": {
        "code": {
          "$ref": "#/definitions/FailureFailureCode",
          "title": "Failure code as defined in the Lightning spec"
        },
        "channel_update": {
          "$ref": "#/definitions/lnrpcChannelUpdate",
          "description": "An optional channel update message."
        },
        "htlc_msat": {
          "type": "string",
          "format": "uint64",
          "description": "A failure type-dependent htlc value."
        },
        "onion_sha_256": {
          "type": "string",
          "format": "byte",
          "description": "The sha256 sum of the onion payload."
        },
        "cltv_expiry": {
          "type": "integer",
          "format": "int64",
          "description": "A failure type-dependent cltv expiry value."
        },
        "flags": {
          "type": "integer",
          "format": "int64",
          "description": "A failure type-dependent flags value."
        },
        "failure_source_index": {
          "type": "integer",
          "format": "int64",
          "description": "The position in the path of the intermediate or final node that generated\nthe failure message. Position zero is the sender node."
        },
        "height": {
          "type": "integer",
          "format": "int64",
          "description": "A failure type-dependent block height."
        }
      }
    },
    "lnrpcFeature": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "is_required": {
          "type": "boolean"
        },
        "is_known": {
          "type": "boolean"
        }
      }
    },
    "lnrpcFeatureBit": {
      "type": "string",
      "enum": [
        "DATALOSS_PROTECT_REQ",
        "DATALOSS_PROTECT_OPT",
        "INITIAL_ROUING_SYNC",
        "UPFRONT_SHUTDOWN_SCRIPT_REQ",
        "UPFRONT_SHUTDOWN_SCRIPT_OPT",
        "GOSSIP_QUERIES_REQ",
        "GOSSIP_QUERIES_OPT",
        "TLV_ONION_REQ",
        "TLV_ONION_OPT",
        "EXT_GOSSIP_QUERIES_REQ",
        "EXT_GOSSIP_QUERIES_OPT",
        "STATIC_REMOTE_KEY_REQ",
        "STATIC_REMOTE_KEY_OPT",
        "PAYMENT_ADDR_REQ",
        "PAYMENT_ADDR_OPT",
        "MPP_REQ",
        "MPP_OPT",
        "WUMBO_CHANNELS_REQ",
        "WUMBO_CHANNELS_OPT",
        "ANCHORS_REQ",
        "ANCHORS_OPT",
        "ANCHORS_ZERO_FEE_HTLC_REQ",
        "ANCHORS_ZERO_FEE_HTLC_OPT",
        "ROUTE_BLINDING_REQUIRED",
        "ROUTE_BLINDING_OPTIONAL",
        "AMP_REQ",
        "AMP_OPT"
      ],
      "default": "DATALOSS_PROTECT_REQ"
    },
    "lnrpcHTLCAttempt": {
      "type": "object",
      "properties": {
        "attempt_id": {
          "type": "string",
          "format": "uint64",
          "description": "The unique ID that is used for this attempt."
        },
        "status": {
          "$ref": "#/definitions/HTLCAttemptHTLCStatus",
          "description": "The status of the HTLC."
        },
        "route": {
          "$ref": "#/definitions/lnrpcRoute",
          "description": "The route taken by this HTLC."
        },
        "attempt_time_ns": {
          "type": "string",
          "format": "int64",
          "description": "The time in UNIX nanoseconds at which this HTLC was sent."
        },
        "resolve_time_ns": {
          "type": "string",
          "format": "int64",
          "description": "The time in UNIX nanoseconds at which this HTLC was settled or failed.\nThis value will not be set if the HTLC is still IN_FLIGHT."
        },
        "failure": {
          "$ref": "#/definitions/lnrpcFailure",
          "description": "Detailed htlc failure info."
        },
        "preimage": {
          "type": "string",
          "format": "byte",
          "description": "The preimage that was used to settle the HTLC."
        }
      }
    },
    "lnrpcHop": {
      "type": "object",
      "properties": {
        "chan_id": {
          "type": "string",
          "format": "uint64",
          "description": "The unique channel ID for the channel. The first 3 bytes are the block\nheight, the next 3 the index within the block, and the last 2 bytes are the\noutput index for the channel."
        },
        "chan_capacity": {
          "type": "string",
          "format": "int64"
        },
        "amt_to_forward": {
          "type": "string",
          "format": "int64"
        },
        "fee": {
          "type": "string",
          "format": "int64"
        },
        "expiry": {
          "type": "integer",
          "format": "int64"
        },
        "amt_to_forward_msat": {
          "type": "string",
          "format": "int64"
        },
        "fee_msat": {
          "type": "string",
          "format": "int64"
        },
        "pub_key": {
          "type": "string",
          "description": "An optional public key of the hop. If the public key is given, the payment\ncan be executed without relying on a copy of the channel graph."
        },
        "tlv_payload": {
          "type": "boolean",
          "description": "If set to true, then this hop will be encoded using the new variable length\nTLV format. Note that if any custom tlv_records below are specified, then\nthis field MUST be set to true for them to be encoded properly."
        },
        "mpp_record": {
          "$ref": "#/definitions/lnrpcMPPRecord",
          "description": "An optional TLV record that signals the use of an MPP payment. If present,\nthe receiver will enforce that the same mpp_record is included in the final\nhop payload of all non-zero payments in the HTLC set. If empty, a regular\nsingle-shot payment is or was attempted."
        },
        "amp_record": {
          "$ref": "#/definitions/lnrpcAMPRecord",
          "description": "An optional TLV record that signals the use of an AMP payment. If present,\nthe receiver will treat all received payments including the same\n(payment_addr, set_id) pair  as being part of one logical payment. The\npayment will be settled by XORing the root_share's together and deriving the\nchild hashes and preimages according to BOLT XX. Must be used in conjunction\nwith mpp_record."
        },
        "custom_records": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "byte"
          },
          "description": "An optional set of key-value TLV records. This is useful within the context\nof the SendToRoute call as it allows callers to specify arbitrary K-V pairs\nto drop off at each hop within the onion."
        },
        "metadata": {
          "type": "string",
          "format": "byte",
          "description": "The payment metadata to send along with the payment to the payee."
        },
        "blinding_point": {
          "type": "string",
          "format": "byte",
          "description": "Blinding point is an optional blinding point included for introduction\nnodes in blinded paths. This field is mandatory for hops that represents\nthe introduction point in a blinded path."
        },
        "encrypted_data": {
          "type": "string",
          "format": "byte",
          "description": "Encrypted data is a receiver-produced blob of data that provides hops\nin a blinded route with forwarding data. As this data is encrypted by\nthe recipient, we will not be able to parse it - it is essentially an\narbitrary blob of data from our node's perspective. This field is\nmandatory for all hops in a blinded path, including the introduction\nnode."
        },
        "total_amt_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The total amount that is sent to the recipient (possibly across multiple\nHTLCs), as specified by the sender when making a payment to a blinded path.\nThis value is only set in the final hop payload of a blinded payment. This\nvalue is analogous to the MPPRecord that is used for regular (non-blinded)\nMPP payments."
        }
      }
    },
    "lnrpcHopHint": {
      "type": "object",
      "properties": {
        "node_id": {
          "type": "string",
          "description": "The public key of the node at the start of the channel."
        },
        "chan_id": {
          "type": "string",
          "format": "uint64",
          "description": "The unique identifier of the channel."
        },
        "fee_base_msat": {
          "type": "integer",
          "format": "int64",
          "description": "The base fee of the channel denominated in millisatoshis."
        },
        "fee_proportional_millionths": {
          "type": "integer",
          "format": "int64",
          "description": "The fee rate of the channel for sending one satoshi across it denominated in\nmillionths of a satoshi."
        },
        "cltv_expiry_delta": {
          "type": "integer",
          "format": "int64",
          "description": "The time-lock delta of the channel."
        }
      }
    },
    "lnrpcInvoice": {
      "type": "object",
      "properties": {
        "memo": {
          "type": "string",
          "description": "An optional memo to attach along with the invoice. Used for record keeping\npurposes for the invoice's creator, and will also be set in the description\nfield of the encoded payment request if the description_hash field is not\nbeing used."
        },
        "r_preimage": {
          "type": "string",
          "format": "byte",
          "description": "The hex-encoded preimage (32 byte) which will allow settling an incoming\nHTLC payable to this preimage. When using REST, this field must be encoded\nas base64."
        },
        "r_hash": {
          "type": "string",
          "format": "byte",
          "description": "The hash of the preimage. When using REST, this field must be encoded as\nbase64.\nNote: Output only, don't specify for creating an invoice."
        },
        "value": {
          "type": "string",
          "format": "int64",
          "description": "The fields value and value_msat are mutually exclusive.",
          "title": "The value of this invoice in satoshis"
        },
        "value_msat": {
          "type": "string",
          "format": "int64",
          "description": "The fields value and value_msat are mutually exclusive.",
          "title": "The value of this invoice in millisatoshis"
        },
        "settled": {
          "type": "boolean",
          "description": "Whether this invoice has been fulfilled.\n\nThe field is deprecated. Use the state field instead (compare to SETTLED)."
        },
        "creation_date": {
          "type": "string",
          "format": "int64",
          "description": "When this invoice was created.\nMeasured in seconds since the unix epoch.\nNote: Output only, don't specify for creating an invoice."
        },
        "settle_date": {
          "type": "string",
          "format": "int64",
          "description": "When this invoice was settled.\nMeasured in seconds since the unix epoch.\nNote: Output only, don't specify for creating an invoice."
        },
        "payment_request": {
          "type": "string",
          "description": "A bare-bones invoice for a payment within the Lightning Network. With the\ndetails of the invoice, the sender has all the data necessary to send a\npayment to the recipient.\nNote: Output only, don't specify for creating an invoice."
        },
        "description_hash": {
          "type": "string",
          "format": "byte",
          "description": "Hash (SHA-256) of a description of the payment. Used if the description of\npayment (memo) is too long to naturally fit within the description field\nof an encoded payment request. When using REST, this field must be encoded\nas base64."
        },
        "expiry": {
          "type": "string",
          "format": "int64",
          "description": "Payment request expiry time in seconds. Default is 86400 (24 hours)."
        },
        "fallback_addr": {
          "type": "string",
          "description": "Fallback on-chain address."
        },
        "cltv_expiry": {
          "type": "string",
          "format": "uint64",
          "description": "Delta to use for the time-lock of the CLTV extended to the final hop."
        },
        "route_hints": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/lnrpcRouteHint"
          },
          "description": "Route hints that can each be individually used to assist in reaching the\ninvoice's destination."
        },
        "private": {
          "type": "boolean",
          "description": "Whether this invoice should include routing hints for private channels.\nNote: When enabled, if value and value_msat are zero, a large number of\nhints with these channels can be included, which might not be desirable."
        },
        "add_index": {
          "type": "string",
          "format": "uint64",
          "description": "The \"add\" index of this invoice. Each newly created invoice will increment\nthis index making it monotonically increasing. Callers to the\nSubscribeInvoices call can use this to instantly get notified of all added\ninvoices with an add_index greater than this one.\nNote: Output only, don't specify for creating an invoice."
        },
        "settle_index": {
          "type": "string",
          "format": "uint64",
          "description": "The \"settle\" index of this invoice. Each newly settled invoice will\nincrement this index making it monotonically increasing. Callers to the\nSubscribeInvoices call can use this to instantly get notified of all\nsettled invoices with an settle_index greater than this one.\nNote: Output only, don't specify for creating an invoice."
        },
        "amt_paid": {
          "type": "string",
          "format": "int64",
          "description": "Deprecated, use amt_paid_sat or amt_paid_msat."
        },
        "amt_paid_sat": {
          "type": "string",
          "format": "int64",
          "description": "The amount that was accepted for this invoice, in satoshis. This will ONLY\nbe set if this invoice has been settled or accepted. We provide this field\nas if the invoice was created with a zero value, then we need to record what\namount was ultimately accepted. Additionally, it's possible that the sender\npaid MORE that was specified in the original invoice. So we'll record that\nhere as well.\nNote: Output only, don't specify for creating an invoice."
        },
        "amt_paid_msat": {
          "type": "string",
          "format": "int64",
          "description": "The amount that was accepted for this invoice, in millisatoshis. This will\nONLY be set if this invoice has been settled or accepted. We provide this\nfield as if the invoice was created with a zero value, then we need to\nrecord what amount was ultimately accepted. Additionally, it's possible that\nthe sender paid MORE that was specified in the original invoice. So we'll\nrecord that here as well.\nNote: Output only, don't specify for creating an invoice."
        },
        "state": {
          "$ref": "#/definitions/InvoiceInvoiceState",
          "description": "The state the invoice is in.\nNote: Output only, don't specify for creating an invoice."
        },
        "htlcs": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/lnrpcInvoiceHTLC"
          },
          "description": "List of HTLCs paying to this invoice [EXPERIMENTAL].\nNote: Output only, don't specify for creating an invoice."
        },
        "features": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/lnrpcFeature"
          },
          "description": "List of features advertised on the invoice.\nNote: Output only, don't specify for creating an invoice."
        },
        "is_keysend": {
          "type": "boolean",
          "description": "Indicates if this invoice was a spontaneous payment that arrived via keysend\n[EXPERIMENTAL].\nNote: Output only, don't specify for creating an invoice."
        },
        "payment_addr": {
          "type": "string",
          "format": "byte",
          "description": "The payment address of this invoice. This is also called payment secret in\nspecifications (e.g. BOLT 11). This value will be used in MPP payments, and\nalso for newer invoices that always require the MPP payload for added\nend-to-end security.\nNote: Output only, don't specify for creating an invoice."
        },
        "is_amp": {
          "type": "boolean",
          "description": "Signals whether or not this is an AMP invoice."
        },
        "amp_invoice_state": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/lnrpcAMPInvoiceState"
          },
          "description": "Maps a 32-byte hex-encoded set ID to the sub-invoice AMP state for the\ngiven set ID. This field is always populated for AMP invoices, and can be\nused along side LookupInvoice to obtain the HTLC information related to a\ngiven sub-invoice.\nNote: Output only, don't specify for creating an invoice.",
          "title": "[EXPERIMENTAL]:"
        },
        "is_blinded": {
          "type": "boolean",
          "description": "Signals that the invoice should include blinded paths to hide the true\nidentity of the recipient."
        },
        "blinded_path_config": {
          "$ref": "#/definitions/lnrpcBlindedPathConfig",
          "description": "Config values to use when creating blinded paths for this invoice. These\ncan be used to override the defaults config values provided in by the\nglobal config. This field is only used if is_blinded is true."
        }
      }
    },
    "lnrpcInvoiceHTLC": {
      "type": "object",
      "properties": {
        "chan_id": {
          "type": "string",
          "format": "uint64",
          "description": "Short channel id over which the htlc was received."
        },
        "htlc_index": {
          "type": "string",
          "format": "uint64",
          "description": "Index identifying the htlc on the channel."
        },
        "amt_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The amount of the htlc in msat."
        },
        "accept_height": {
          "type": "integer",
          "format": "int32",
          "description": "Block height at which this htlc was accepted."
        },
        "accept_time": {
          "type": "string",
          "format": "int64",
          "description": "Time at which this htlc was accepted."
        },
        "resolve_time": {
          "type": "string",
          "format": "int64",
          "description": "Time at which this htlc was settled or canceled."
        },
        "expiry_height": {
          "type": "integer",
          "format": "int32",
          "description": "Block height at which this htlc expires."
        },
        "state": {
          "$ref": "#/definitions/lnrpcInvoiceHTLCState",
          "description": "Current state the htlc is in."
        },
        "custom_records": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "byte"
          },
          "description": "Custom tlv records."
        },
        "mpp_total_amt_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The total amount of the mpp payment in msat."
        },
        "amp": {
          "$ref": "#/definitions/lnrpcAMP",
          "description": "Details relevant to AMP HTLCs, only populated if this is an AMP HTLC."
        },
        "custom_channel_data": {
          "type": "string",
          "format": "byte",
          "description": "Custom channel data that might be populated in custom channels."
        }
      },
      "title": "Details of an HTLC that paid to an invoice"
    },
    "lnrpcInvoiceHTLCState": {
      "type": "string",
      "enum": [
        "ACCEPTED",
        "SETTLED",
        "CANCELED"
      ],
      "default": "ACCEPTED"
    },
    "lnrpcMPPRecord": {
      "type": "object",
      "properties": {
        "payment_addr": {
          "type": "string",
          "format": "byte",
          "description": "A unique, random identifier used to authenticate the sender as the intended\npayer of a multi-path payment. The payment_addr must be the same for all\nsubpayments, and match the payment_addr provided in the receiver's invoice.\nThe same payment_addr must be used on all subpayments. This is also called\npayment secret in specifications (e.g. BOLT 11)."
        },
        "total_amt_msat": {
          "type": "string",
          "format": "int64",
          "description": "The total amount in milli-satoshis being sent as part of a larger multi-path\npayment. The caller is responsible for ensuring subpayments to the same node\nand payment_hash sum exactly to total_amt_msat. The same\ntotal_amt_msat must be used on all subpayments."
        }
      }
    },
    "lnrpcPayReq": {
      "type": "object",
      "properties": {
        "destination": {
          "type": "string"
        },
        "payment_hash": {
          "type": "string"
        },
        "num_satoshis": {
          "type": "string",
          "format": "int64"
        },
        "timestamp": {
          "type": "string",
          "format": "int64"
        },
        "expiry": {
          "type": "string",
          "format": "int64"
        },
        "description": {
          "type": "string"
        },
        "description_hash": {
          "type": "string"
        },
        "fallback_addr": {
          "type": "string"
        },
        "cltv_expiry": {
          "type": "string",
          "format": "int64"
        },
        "route_hints": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/lnrpcRouteHint"
          }
        },
        "payment_addr": {
          "type": "string",
          "format": "byte"
        },
        "num_msat": {
          "type": "string",
          "format": "int64"
        },
        "features": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/lnrpcFeature"
          }
        },
        "blinded_paths": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/lnrpcBlindedPaymentPath"
          }
        }
      }
    },
    "lnrpcPayment": {
      "type": "object",
      "properties": {
        "payment_hash": {
          "type": "string",
          "title": "The payment hash"
        },
        "value": {
          "type": "string",
          "format": "int64",
          "description": "Deprecated, use value_sat or value_msat."
        },
        "creation_date": {
          "type": "string",
          "format": "int64",
          "title": "Deprecated, use creation_time_ns"
        },
        "fee": {
          "type": "string",
          "format": "int64",
          "description": "Deprecated, use fee_sat or fee_msat."
        },
        "payment_preimage": {
          "type": "string",
          "title": "The payment preimage"
        },
        "value_sat": {
          "type": "string",
          "format": "int64",
          "title": "The value of the payment in satoshis"
        },
        "value_msat": {
          "type": "string",
          "format": "int64",
          "title": "The value of the payment in milli-satoshis"
        },
        "payment_request": {
          "type": "string",
          "description": "The optional payment request being fulfilled."
        },
        "status": {
          "$ref": "#/definitions/lnrpcPaymentPaymentStatus",
          "description": "The status of the payment."
        },
        "fee_sat": {
          "type": "string",
          "format": "int64",
          "title": "The fee paid for this payment in satoshis"
        },
        "fee_msat": {
          "type": "string",
          "format": "int64",
          "title": "The fee paid for this payment in milli-satoshis"
        },
        "creation_time_ns": {
          "type": "string",
          "format": "int64",
          "description": "The time in UNIX nanoseconds at which the payment was created."
        },
        "htlcs": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/lnrpcHTLCAttempt"
          },
          "description": "The HTLCs made in attempt to settle the payment."
        },
        "payment_index": {
          "type": "string",
          "format": "uint64",
          "description": "The creation index of this payment. Each payment can be uniquely identified\nby this index, which may not strictly increment by 1 for payments made in\nolder versions of lnd."
        },
        "failure_reason": {
          "$ref": "#/definitions/lnrpcPaymentFailureReason"
        },
        "first_hop_custom_records": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "byte"
          },
          "description": "The custom TLV records that were sent to the first hop as part of the HTLC\nwire message for this payment."
        }
      }
    },
    "lnrpcPaymentFailureReason": {
      "type": "string",
      "enum": [
        "FAILURE_REASON_NONE",
        "FAILURE_REASON_TIMEOUT",
        "FAILURE_REASON_NO_ROUTE",
        "FAILURE_REASON_ERROR",
        "FAILURE_REASON_INCORRECT_PAYMENT_DETAILS",
        "FAILURE_REASON_INSUFFICIENT_BALANCE",
        "FAILURE_REASON_CANCELED"
      ],
      "default": "FAILURE_REASON_NONE",
      "description": " - FAILURE_REASON_NONE: Payment isn't failed (yet).\n - FAILURE_REASON_TIMEOUT: There are more routes to try, but the payment timeout was exceeded.\n - FAILURE_REASON_NO_ROUTE: All possible routes were tried and failed permanently. Or were no\nroutes to the destination at all.\n - FAILURE_REASON_ERROR: A non-recoverable error has occured.\n - FAILURE_REASON_INCORRECT_PAYMENT_DETAILS: Payment details incorrect (unknown hash, invalid amt or\ninvalid final cltv delta)\n - FAILURE_REASON_INSUFFICIENT_BALANCE: Insufficient local balance.\n - FAILURE_REASON_CANCELED: The payment was canceled."
    },
    "lnrpcPaymentPaymentStatus": {
      "type": "string",
      "enum": [
        "UNKNOWN",
        "IN_FLIGHT",
        "SUCCEEDED",
        "FAILED",
        "INITIATED"
      ],
      "default": "UNKNOWN",
      "description": " - UNKNOWN: Deprecated. This status will never be returned.\n - IN_FLIGHT: Payment has inflight HTLCs.\n - SUCCEEDED: Payment is settled.\n - FAILED: Payment is failed.\n - INITIATED: Payment is created and has not attempted any HTLCs."
    },
    "lnrpcRoute": {
      "type": "object",
      "properties": {
        "total_time_lock": {
          "type": "integer",
          "format": "int64",
          "description": "The cumulative (final) time lock across the entire route. This is the CLTV\nvalue that should be extended to the first hop in the route. All other hops\nwill decrement the time-lock as advertised, leaving enough time for all\nhops to wait for or present the payment preimage to complete the payment."
        },
        "total_fees": {
          "type": "string",
          "format": "int64",
          "description": "The sum of the fees paid at each hop within the final route. In the case\nof a one-hop payment, this value will be zero as we don't need to pay a fee\nto ourselves."
        },
        "total_amt": {
          "type": "string",
          "format": "int64",
          "description": "The total amount of funds required to complete a payment over this route.\nThis value includes the cumulative fees at each hop. As a result, the HTLC\nextended to the first-hop in the route will need to have at least this many\nsatoshis, otherwise the route will fail at an intermediate node due to an\ninsufficient amount of fees."
        },
        "hops": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/lnrpcHop"
          },
          "description": "Contains details concerning the specific forwarding details at each hop."
        },
        "total_fees_msat": {
          "type": "string",
          "format": "int64",
          "description": "The total fees in millisatoshis."
        },
        "total_amt_msat": {
          "type": "string",
          "format": "int64",
          "description": "The total amount in millisatoshis."
        },
        "first_hop_amount_msat": {
          "type": "string",
          "format": "int64",
          "description": "The actual on-chain amount that was sent out to the first hop. This value is\nonly different from the total_amt_msat field if this is a custom channel\npayment and the value transported in the HTLC is different from the BTC\namount in the HTLC. If this value is zero, then this is an old payment that\ndidn't have this value yet and can be ignored."
        },
        "custom_channel_data": {
          "type": "string",
          "format": "byte",
          "description": "Custom channel data that might be populated in custom channels."
        }
      },
      "description": "A path through the channel graph which runs over one or more channels in\nsuccession. This struct carries all the information required to craft the\nSphinx onion packet, and send the payment along the first hop in the path. A\nroute is only selected as valid if all the channels have sufficient capacity to\ncarry the initial payment amount after fees are accounted for."
    },
    "lnrpcRouteHint": {
      "type": "object",
      "properties": {
        "hop_hints": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/lnrpcHopHint"
          },
          "description": "A list of hop hints that when chained together can assist in reaching a\nspecific destination."
        }
      }
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string"
        }
      },
      "additionalProperties": {}
    },
    "rfqrpcFixedPoint": {
      "type": "object",
      "properties": {
        "coefficient": {
          "type": "string",
          "description": "The coefficient is the fractional value scaled-up as an integer. This\ninteger is represented as a string as it may be too large to fit in a\nuint64."
        },
        "scale": {
          "type": "integer",
          "format": "int64",
          "description": "The scale is the component that determines how many decimal places\nthe coefficient should be divided by to obtain the fractional value."
        }
      },
      "description": "FixedPoint is a scaled integer representation of a fractional number.\n\nThis type consists of two integer fields: a coefficient and a scale.\nUsing this format enables precise and consistent representation of fractional\nnumbers while avoiding floating-point data types, which are prone to\nprecision errors.\n\nThe relationship between the fractional representation and its fixed-point\nrepresentation is expressed as:\n```\nV = F_c / (10^F_s)\n```\nwhere:\n\n* `V` is the fractional value.\n\n* `F_c` is the coefficient component of the fixed-point representation. It is\n   the scaled-up fractional value represented as an integer.\n\n* `F_s` is the scale component. It is an integer specifying how\n  many decimal places `F_c` should be divided by to obtain the fractional\n  representation."
    },
    "rfqrpcPeerAcceptedBuyQuote": {
      "type": "object",
      "properties": {
        "peer": {
          "type": "string",
          "description": "Quote counterparty peer."
        },
        "id": {
          "type": "string",
          "format": "byte",
          "description": "The unique identifier of the quote request."
        },
        "scid": {
          "type": "string",
          "format": "uint64",
          "description": "The short channel ID of the channel over which the payment for the quote\nshould be made."
        },
        "asset_max_amount": {
          "type": "string",
          "format": "uint64",
          "description": "The maximum exchange amount denoted in the subject asset. This includes\nthe user-configured maximum routing fees, so the actual payment amount\nwill be less than this. This just defines the maximum volume that the\nedge node has accepted to divest with the given rate."
        },
        "ask_asset_rate": {
          "$ref": "#/definitions/rfqrpcFixedPoint",
          "description": "ask_asset_rate is the asset to BTC conversion rate represented as a\nfixed-point number."
        },
        "expiry": {
          "type": "string",
          "format": "uint64",
          "description": "The unix timestamp in seconds after which the quote is no longer valid."
        },
        "min_transportable_units": {
          "type": "string",
          "format": "uint64",
          "description": "The smallest amount of asset units that can be transported within a\nsingle HTLC over the Lightning Network with the given rate. This is the\nasset unit equivalent of 354 satoshis, which is the minimum amount for an\nHTLC to be above the dust limit."
        }
      }
    },
    "rfqrpcPeerAcceptedSellQuote": {
      "type": "object",
      "properties": {
        "peer": {
          "type": "string",
          "description": "Quote counterparty peer."
        },
        "id": {
          "type": "string",
          "format": "byte",
          "description": "The unique identifier of the quote request."
        },
        "scid": {
          "type": "string",
          "format": "uint64",
          "description": "scid is the short channel ID of the channel over which the payment for\nthe quote should be made."
        },
        "asset_amount": {
          "type": "string",
          "format": "uint64",
          "description": "asset_amount is the amount of the subject asset."
        },
        "bid_asset_rate": {
          "$ref": "#/definitions/rfqrpcFixedPoint",
          "description": "bid_asset_rate is the asset to BTC conversion rate represented as a\nfixed-point number."
        },
        "expiry": {
          "type": "string",
          "format": "uint64",
          "description": "The unix timestamp in seconds after which the quote is no longer valid."
        },
        "min_transportable_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The minimum amount of milli-satoshis that need to be sent out in order to\ntransport a single asset unit over the Lightning Network with the given\nrate. This is the base amount of 354,000 milli-satoshi (the minimum\namount for a non-dust HTLC) plus the equivalent of one asset unit in\nmilli-satoshis."
        }
      }
    },
    "routerrpcSendPaymentRequest": {
      "type": "object",
      "properties": {
        "dest": {
          "type": "string",
          "format": "byte",
          "title": "The identity pubkey of the payment recipient"
        },
        "amt": {
          "type": "string",
          "format": "int64",
          "description": "Number of satoshis to send.\n\nThe fields amt and amt_msat are mutually exclusive."
        },
        "payment_hash": {
          "type": "string",
          "format": "byte",
          "title": "The hash to use within the payment's HTLC"
        },
        "final_cltv_delta": {
          "type": "integer",
          "format": "int32",
          "description": "The CLTV delta from the current height that should be used to set the\ntimelock for the final hop."
        },
        "payment_request": {
          "type": "string",
          "description": "A bare-bones invoice for a payment within the Lightning Network.  With the\ndetails of the invoice, the sender has all the data necessary to send a\npayment to the recipient. The amount in the payment request may be zero. In\nthat case it is required to set the amt field as well. If no payment request\nis specified, the following fields are required: dest, amt and payment_hash."
        },
        "timeout_seconds": {
          "type": "integer",
          "format": "int32",
          "description": "An optional limit, expressed in seconds, on the time to wait before\nattempting the first HTLC. Once HTLCs are in flight, the payment will\nnot be aborted until the HTLCs are either settled or failed. If the field\nis not set or is explicitly set to zero, the default value of 60 seconds\nwill be applied."
        },
        "fee_limit_sat": {
          "type": "string",
          "format": "int64",
          "description": "The maximum number of satoshis that will be paid as a fee of the payment.\nIf this field is left to the default value of 0, only zero-fee routes will\nbe considered. This usually means single hop routes connecting directly to\nthe destination. To send the payment without a fee limit, use max int here.\n\nThe fields fee_limit_sat and fee_limit_msat are mutually exclusive."
        },
        "outgoing_chan_id": {
          "type": "string",
          "format": "uint64",
          "description": "Deprecated, use outgoing_chan_ids. The channel id of the channel that must\nbe taken to the first hop. If zero, any channel may be used (unless\noutgoing_chan_ids are set)."
        },
        "cltv_limit": {
          "type": "integer",
          "format": "int32",
          "description": "An optional maximum total time lock for the route. This should not\nexceed lnd's `--max-cltv-expiry` setting. If zero, then the value of\n`--max-cltv-expiry` is enforced."
        },
        "route_hints": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/lnrpcRouteHint"
          },
          "description": "Optional route hints to reach the destination through private channels."
        },
        "dest_custom_records": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "byte"
          },
          "description": "An optional field that can be used to pass an arbitrary set of TLV records\nto a peer which understands the new records. This can be used to pass\napplication specific data during the payment attempt. Record types are\nrequired to be in the custom range \u003e= 65536. When using REST, the values\nmust be encoded as base64."
        },
        "amt_msat": {
          "type": "string",
          "format": "int64",
          "description": "Number of millisatoshis to send.\n\nThe fields amt and amt_msat are mutually exclusive."
        },
        "fee_limit_msat": {
          "type": "string",
          "format": "int64",
          "description": "The maximum number of millisatoshis that will be paid as a fee of the\npayment. If this field is left to the default value of 0, only zero-fee\nroutes will be considered. This usually means single hop routes connecting\ndirectly to the destination. To send the payment without a fee limit, use\nmax int here.\n\nThe fields fee_limit_sat and fee_limit_msat are mutually exclusive."
        },
        "last_hop_pubkey": {
          "type": "string",
          "format": "byte",
          "description": "The pubkey of the last hop of the route. If empty, any hop may be used."
        },
        "allow_self_payment": {
          "type": "boolean",
          "description": "If set, circular payments to self are permitted."
        },
        "dest_features": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/lnrpcFeatureBit"
          },
          "description": "Features assumed to be supported by the final node. All transitive feature\ndependencies must also be set properly. For a given feature bit pair, either\noptional or remote may be set, but not both. If this field is nil or empty,\nthe router will try to load destination features from the graph as a\nfallback."
        },
        "max_parts": {
          "type": "integer",
          "format": "int64",
          "description": "The maximum number of partial payments that may be use to complete the full\namount."
        },
        "no_inflight_updates": {
          "type": "boolean",
          "description": "If set, only the final payment update is streamed back. Intermediate updates\nthat show which htlcs are still in flight are suppressed."
        },
        "outgoing_chan_ids": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uint64"
          },
          "description": "The channel ids of the channels are allowed for the first hop. If empty,\nany channel may be used."
        },
        "payment_addr": {
          "type": "string",
          "format": "byte",
          "description": "An optional payment addr to be included within the last hop of the route.\nThis is also called payment secret in specifications (e.g. BOLT 11)."
        },
        "max_shard_size_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The largest payment split that should be attempted when making a payment if\nsplitting is necessary. Setting this value will effectively cause lnd to\nsplit more aggressively, vs only when it thinks it needs to. Note that this\nvalue is in milli-satoshis."
        },
        "amp": {
          "type": "boolean",
          "description": "If set, an AMP-payment will be attempted."
        },
        "time_pref": {
          "type": "number",
          "format": "double",
          "description": "The time preference for this payment. Set to -1 to optimize for fees\nonly, to 1 to optimize for reliability only or a value inbetween for a mix."
        },
        "cancelable": {
          "type": "boolean",
          "description": "If set, the payment loop can be interrupted by manually canceling the\npayment context, even before the payment timeout is reached. Note that the\npayment may still succeed after cancellation, as in-flight attempts can\nstill settle afterwards. Canceling will only prevent further attempts from\nbeing sent."
        },
        "first_hop_custom_records": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "byte"
          },
          "description": "An optional field that can be used to pass an arbitrary set of TLV records\nto the first hop peer of this payment. This can be used to pass application\nspecific data during the payment attempt. Record types are required to be in\nthe custom range \u003e= 65536. When using REST, the values must be encoded as\nbase64."
        }
      }
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "tapchannelrpcAddInvoiceRequest": {
      "type": "object",
      "properties": {
        "asset_id": {
          "type": "string",
          "format": "byte",
          "description": "The asset ID to use for the invoice. Mutually exclusive to group_key."
        },
        "asset_amount": {
          "type": "string",
          "format": "uint64",
          "description": "The asset amount to receive."
        },
        "peer_pubkey": {
          "type": "string",
          "format": "byte",
          "description": "The node identity public key of the peer to ask for a quote for receiving\nassets and converting them from satoshis. This must be specified if\nthere are multiple channels with the given asset ID."
        },
        "invoice_request": {
          "$ref": "#/definitions/lnrpcInvoice",
          "description": "The full lnd invoice request to send. All fields behave the same way as\nthey do for lnd's lnrpc.AddInvoice RPC method (see the API docs at\nhttps://lightning.engineering/api-docs/api/lnd/lightning/add-invoice\nfor more details).\n\nOnly one of the asset_amount/value/value_msat may be set to dictate the\nvalue of the invoice. When using asset_amount, the value/value_msat\nfields will be overwritten by the satoshi (or milli-satoshi) equivalent\nof the asset amount, after negotiating a quote with a peer that supports\nthe given asset ID.\n\nIf the value/value_msat are used, we still receive assets, but they will\nexactly evaluate to the defined amount in sats/msats."
        },
        "hodl_invoice": {
          "$ref": "#/definitions/tapchannelrpcHodlInvoice",
          "description": "If set, then this will make the invoice created a hodl invoice, which\nwon't be settled automatically. Instead, users will need to use the\ninvoicesrpc.SettleInvoice call to manually settle the invoice."
        },
        "group_key": {
          "type": "string",
          "format": "byte",
          "description": "The group key which dictates which assets may be accepted for this\ninvoice. If set, any asset that belongs to this group may be accepted to\nsettle this invoice. Mutually exclusive to asset_id."
        }
      }
    },
    "tapchannelrpcAddInvoiceResponse": {
      "type": "object",
      "properties": {
        "accepted_buy_quote": {
          "$ref": "#/definitions/rfqrpcPeerAcceptedBuyQuote",
          "description": "The quote for the purchase of assets that was accepted by the peer."
        },
        "invoice_result": {
          "$ref": "#/definitions/lnrpcAddInvoiceResponse",
          "description": "The result of the invoice creation."
        }
      }
    },
    "tapchannelrpcAssetPayReq": {
      "type": "object",
      "properties": {
        "asset_id": {
          "type": "string",
          "format": "byte",
          "description": "The asset ID that will be used to resolve the invoice's satoshi amount."
        },
        "pay_req_string": {
          "type": "string",
          "description": "The normal LN invoice that whose amount will be mapped to units of the\nasset ID."
        }
      }
    },
    "tapchannelrpcAssetPayReqResponse": {
      "type": "object",
      "properties": {
        "asset_amount": {
          "type": "string",
          "format": "uint64",
          "description": "The invoice amount, expressed in asset units."
        },
        "decimal_display": {
          "$ref": "#/definitions/taprpcDecimalDisplay",
          "description": "The decimal display corresponding to the asset_id."
        },
        "asset_group": {
          "$ref": "#/definitions/taprpcAssetGroup",
          "description": "The group the asset ID belong to, if applicable."
        },
        "genesis_info": {
          "$ref": "#/definitions/taprpcGenesisInfo",
          "description": "Genesis information for the asset ID which includes the meta hash, and\nasset ID."
        },
        "pay_req": {
          "$ref": "#/definitions/lnrpcPayReq",
          "description": "The normal decoded payment request."
        }
      }
    },
    "tapchannelrpcEncodeCustomRecordsRequest": {
      "type": "object",
      "properties": {
        "router_send_payment": {
          "$ref": "#/definitions/tapchannelrpcRouterSendPaymentData"
        }
      }
    },
    "tapchannelrpcEncodeCustomRecordsResponse": {
      "type": "object",
      "properties": {
        "custom_records": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "byte"
          },
          "description": "The encoded custom records in TLV format."
        }
      }
    },
    "tapchannelrpcFundChannelRequest": {
      "type": "object",
      "properties": {
        "asset_amount": {
          "type": "string",
          "format": "uint64",
          "description": "The asset amount to fund the channel with. The BTC amount is fixed and\ncannot be customized (for now)."
        },
        "asset_id": {
          "type": "string",
          "format": "byte",
          "description": "The asset ID to use for the channel funding."
        },
        "peer_pubkey": {
          "type": "string",
          "format": "byte",
          "description": "The public key of the peer to open the channel with. Must already be\nconnected to this peer."
        },
        "fee_rate_sat_per_vbyte": {
          "type": "integer",
          "format": "int64",
          "description": "The channel funding fee rate in sat/vByte."
        },
        "push_sat": {
          "type": "string",
          "format": "int64",
          "description": "The number of satoshis to give the remote side as part of the initial\ncommitment state. This is equivalent to first opening a channel and then\nsending the remote party funds, but all done in one step. Therefore, this\nis equivalent to a donation to the remote party, unless they reimburse\nthe funds in another way (outside the protocol)."
        },
        "group_key": {
          "type": "string",
          "format": "byte",
          "description": "The group key to use for the channel. This can be used instead of the\nasset_id to allow assets from a fungible group to be used for the channel\nfunding instead of just assets from a single minting tranche (asset_id)."
        }
      }
    },
    "tapchannelrpcFundChannelResponse": {
      "type": "object",
      "properties": {
        "txid": {
          "type": "string",
          "description": "The channel funding transaction ID."
        },
        "output_index": {
          "type": "integer",
          "format": "int32",
          "description": "The index of the channel funding output in the funding transaction."
        }
      }
    },
    "tapchannelrpcHodlInvoice": {
      "type": "object",
      "properties": {
        "payment_hash": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "tapchannelrpcRouterSendPaymentData": {
      "type": "object",
      "properties": {
        "asset_amounts": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "uint64"
          },
          "description": "The string encoded asset ID to amount mapping. Instructs the router to\nuse these assets in the given amounts for the payment. Can be empty for\na payment of an invoice, if the RFQ ID is set instead."
        },
        "rfq_id": {
          "type": "string",
          "format": "byte",
          "description": "The RFQ ID to use for the payment. Can be empty for a direct keysend\npayment that doesn't involve any conversion (and thus no RFQ)."
        }
      }
    },
    "tapchannelrpcSendPaymentRequest": {
      "type": "object",
      "properties": {
        "asset_id": {
          "type": "string",
          "format": "byte",
          "description": "The asset ID to use for the payment. This must be set for both invoice\nand keysend payments, unless RFQ negotiation was already done beforehand\nand payment_request.first_hop_custom_records already contains valid RFQ\ndata. Mutually exclusive to group_key."
        },
        "asset_amount": {
          "type": "string",
          "format": "uint64",
          "description": "The asset amount to send in a keysend payment. This amount is ignored for\ninvoice payments as the asset amount is negotiated through RFQ with the\npeer, depending on the invoice amount. This can also be left unset if RFQ\nnegotiation was already done beforehand and\npayment_request.first_hop_custom_records already contains valid RFQ data."
        },
        "peer_pubkey": {
          "type": "string",
          "format": "byte",
          "description": "The node identity public key of the peer to ask for a quote for sending\nout the assets and converting them to satoshis. This must be specified if\nthere are multiple channels with the given asset ID."
        },
        "payment_request": {
          "$ref": "#/definitions/routerrpcSendPaymentRequest",
          "description": "The full lnd payment request to send. All fields behave the same way as\nthey do for lnd's routerrpc.SendPaymentV2 RPC method (see the API docs\nat https://lightning.engineering/api-docs/api/lnd/router/send-payment-v2\nfor more details).\nTo send a keysend payment, the payment_request.dest_custom_records must\ncontain a valid keysend record (key 5482373484 and a 32-byte preimage\nthat corresponds to the payment hash)."
        },
        "rfq_id": {
          "type": "string",
          "format": "byte",
          "description": "The rfq id to use for this payment. If the user sets this value then the\npayment will immediately be dispatched, skipping the rfq negotiation\nphase, and using the following rfq id instead."
        },
        "allow_overpay": {
          "type": "boolean",
          "description": "If a small invoice should be paid that is below the amount that always\nneeds to be sent out to carry a single asset unit, then by default the\npayment is rejected. If this flag is set, then the payment will be\nallowed to proceed, even if it is uneconomical, meaning that more sats\nare sent out to the network than the invoice amount plus routing fees\nrequire to be paid."
        },
        "group_key": {
          "type": "string",
          "format": "byte",
          "description": "The group key which dictates which assets may be used for this payment.\nMutually exclusive to asset_id."
        }
      }
    },
    "tapchannelrpcSendPaymentResponse": {
      "type": "object",
      "properties": {
        "accepted_sell_order": {
          "$ref": "#/definitions/rfqrpcPeerAcceptedSellQuote",
          "description": "In case channel assets need to be swapped to another asset, an asset\nsell order is negotiated with the channel peer. The result will be\nthe first message in the response stream. If no swap is needed, the\npayment results will be streamed directly."
        },
        "payment_result": {
          "$ref": "#/definitions/lnrpcPayment",
          "description": "The payment result of a single payment attempt. Multiple attempts may\nbe returned per payment request until either the payment succeeds or\nthe payment times out."
        }
      }
    },
    "taprpcAssetGroup": {
      "type": "object",
      "properties": {
        "raw_group_key": {
          "type": "string",
          "format": "byte",
          "description": "The raw group key which is a normal public key."
        },
        "tweaked_group_key": {
          "type": "string",
          "format": "byte",
          "description": "The tweaked group key, which is derived based on the genesis point and also\nasset type."
        },
        "asset_witness": {
          "type": "string",
          "format": "byte",
          "description": "A witness that authorizes a specific asset to be part of the asset group\nspecified by the above key."
        },
        "tapscript_root": {
          "type": "string",
          "format": "byte",
          "description": "The root hash of a tapscript tree, which enables future issuance authorized\nwith a script witness."
        }
      }
    },
    "taprpcAssetType": {
      "type": "string",
      "enum": [
        "NORMAL",
        "COLLECTIBLE"
      ],
      "default": "NORMAL",
      "description": " - NORMAL: Indicates that an asset is capable of being split/merged, with each of the\nunits being fungible, even across a key asset ID boundary (assuming the\nkey group is the same).\n - COLLECTIBLE: Indicates that an asset is a collectible, meaning that each of the other\nitems under the same key group are not fully fungible with each other.\nCollectibles also cannot be split or merged."
    },
    "taprpcDecimalDisplay": {
      "type": "object",
      "properties": {
        "decimal_display": {
          "type": "integer",
          "format": "int64",
          "description": "Decimal display dictates the number of decimal places to shift the amount to\nthe left converting from Taproot Asset integer representation to a\nUX-recognizable fractional quantity.\n\nFor example, if the decimal_display value is 2 and there's 100 of those\nassets, then a wallet would display the amount as \"1.00\". This field is\nintended as information for wallets that display balances and has no impact\non the behavior of the daemon or any other part of the protocol. This value\nis encoded in the MetaData field as a JSON field, therefore it is only\ncompatible with assets that have a JSON MetaData field."
        }
      }
    },
    "taprpcGenesisInfo": {
      "type": "object",
      "properties": {
        "genesis_point": {
          "type": "string",
          "description": "The first outpoint of the transaction that created the asset (txid:vout)."
        },
        "name": {
          "type": "string",
          "description": "The name of the asset."
        },
        "meta_hash": {
          "type": "string",
          "format": "byte",
          "description": "The hash of the meta data for this genesis asset."
        },
        "asset_id": {
          "type": "string",
          "format": "byte",
          "description": "The asset ID that uniquely identifies the asset."
        },
        "asset_type": {
          "$ref": "#/definitions/taprpcAssetType",
          "description": "The type of the asset."
        },
        "output_index": {
          "type": "integer",
          "format": "int64",
          "description": "The index of the output that carries the unique Taproot Asset commitment in\nthe genesis transaction."
        }
      }
    }
  }
}
