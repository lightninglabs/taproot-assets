// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: mintrpc/mint.proto

package mintrpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Mint_MintAsset_FullMethodName           = "/mintrpc.Mint/MintAsset"
	Mint_FundBatch_FullMethodName           = "/mintrpc.Mint/FundBatch"
	Mint_SealBatch_FullMethodName           = "/mintrpc.Mint/SealBatch"
	Mint_FinalizeBatch_FullMethodName       = "/mintrpc.Mint/FinalizeBatch"
	Mint_CancelBatch_FullMethodName         = "/mintrpc.Mint/CancelBatch"
	Mint_ListBatches_FullMethodName         = "/mintrpc.Mint/ListBatches"
	Mint_SubscribeMintEvents_FullMethodName = "/mintrpc.Mint/SubscribeMintEvents"
)

// MintClient is the client API for Mint service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MintClient interface {
	// tapcli: `assets mint`
	// MintAsset will attempt to mint the set of assets (async by default to
	// ensure proper batching) specified in the request. The pending batch is
	// returned that shows the other pending assets that are part of the next
	// batch. This call will block until the operation succeeds (asset is staged
	// in the batch) or fails.
	MintAsset(ctx context.Context, in *MintAssetRequest, opts ...grpc.CallOption) (*MintAssetResponse, error)
	// tapcli `assets mint fund`
	// FundBatch will attempt to fund the current pending batch with a genesis
	// input, or create a new funded batch if no batch exists yet. This RPC is only
	// needed if a custom witness is needed to finalize the batch. Otherwise,
	// FinalizeBatch can be called directly.
	FundBatch(ctx context.Context, in *FundBatchRequest, opts ...grpc.CallOption) (*FundBatchResponse, error)
	// tapcli `assets mint seal`
	// SealBatch will attempt to seal the current pending batch by creating and
	// validating asset group witness for all assets in the batch. If a witness
	// is not provided, a signature will be derived to serve as the witness. This
	// RPC is only needed if any assets in the batch have a custom asset group key
	// that require an external signer. Otherwise, FinalizeBatch can be called
	// directly.
	SealBatch(ctx context.Context, in *SealBatchRequest, opts ...grpc.CallOption) (*SealBatchResponse, error)
	// tapcli: `assets mint finalize`
	// FinalizeBatch will attempt to finalize the current pending batch.
	FinalizeBatch(ctx context.Context, in *FinalizeBatchRequest, opts ...grpc.CallOption) (*FinalizeBatchResponse, error)
	// tapcli: `assets mint cancel`
	// CancelBatch will attempt to cancel the current pending batch.
	CancelBatch(ctx context.Context, in *CancelBatchRequest, opts ...grpc.CallOption) (*CancelBatchResponse, error)
	// tapcli: `assets mint batches`
	// ListBatches lists the set of batches submitted to the daemon, including
	// pending and cancelled batches.
	ListBatches(ctx context.Context, in *ListBatchRequest, opts ...grpc.CallOption) (*ListBatchResponse, error)
	// tapcli: `events mint`
	// SubscribeMintEvents allows a caller to subscribe to mint events for asset
	// creation batches.
	SubscribeMintEvents(ctx context.Context, in *SubscribeMintEventsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MintEvent], error)
}

type mintClient struct {
	cc grpc.ClientConnInterface
}

func NewMintClient(cc grpc.ClientConnInterface) MintClient {
	return &mintClient{cc}
}

func (c *mintClient) MintAsset(ctx context.Context, in *MintAssetRequest, opts ...grpc.CallOption) (*MintAssetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MintAssetResponse)
	err := c.cc.Invoke(ctx, Mint_MintAsset_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mintClient) FundBatch(ctx context.Context, in *FundBatchRequest, opts ...grpc.CallOption) (*FundBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FundBatchResponse)
	err := c.cc.Invoke(ctx, Mint_FundBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mintClient) SealBatch(ctx context.Context, in *SealBatchRequest, opts ...grpc.CallOption) (*SealBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SealBatchResponse)
	err := c.cc.Invoke(ctx, Mint_SealBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mintClient) FinalizeBatch(ctx context.Context, in *FinalizeBatchRequest, opts ...grpc.CallOption) (*FinalizeBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FinalizeBatchResponse)
	err := c.cc.Invoke(ctx, Mint_FinalizeBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mintClient) CancelBatch(ctx context.Context, in *CancelBatchRequest, opts ...grpc.CallOption) (*CancelBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelBatchResponse)
	err := c.cc.Invoke(ctx, Mint_CancelBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mintClient) ListBatches(ctx context.Context, in *ListBatchRequest, opts ...grpc.CallOption) (*ListBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListBatchResponse)
	err := c.cc.Invoke(ctx, Mint_ListBatches_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mintClient) SubscribeMintEvents(ctx context.Context, in *SubscribeMintEventsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MintEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Mint_ServiceDesc.Streams[0], Mint_SubscribeMintEvents_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeMintEventsRequest, MintEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Mint_SubscribeMintEventsClient = grpc.ServerStreamingClient[MintEvent]

// MintServer is the server API for Mint service.
// All implementations must embed UnimplementedMintServer
// for forward compatibility.
type MintServer interface {
	// tapcli: `assets mint`
	// MintAsset will attempt to mint the set of assets (async by default to
	// ensure proper batching) specified in the request. The pending batch is
	// returned that shows the other pending assets that are part of the next
	// batch. This call will block until the operation succeeds (asset is staged
	// in the batch) or fails.
	MintAsset(context.Context, *MintAssetRequest) (*MintAssetResponse, error)
	// tapcli `assets mint fund`
	// FundBatch will attempt to fund the current pending batch with a genesis
	// input, or create a new funded batch if no batch exists yet. This RPC is only
	// needed if a custom witness is needed to finalize the batch. Otherwise,
	// FinalizeBatch can be called directly.
	FundBatch(context.Context, *FundBatchRequest) (*FundBatchResponse, error)
	// tapcli `assets mint seal`
	// SealBatch will attempt to seal the current pending batch by creating and
	// validating asset group witness for all assets in the batch. If a witness
	// is not provided, a signature will be derived to serve as the witness. This
	// RPC is only needed if any assets in the batch have a custom asset group key
	// that require an external signer. Otherwise, FinalizeBatch can be called
	// directly.
	SealBatch(context.Context, *SealBatchRequest) (*SealBatchResponse, error)
	// tapcli: `assets mint finalize`
	// FinalizeBatch will attempt to finalize the current pending batch.
	FinalizeBatch(context.Context, *FinalizeBatchRequest) (*FinalizeBatchResponse, error)
	// tapcli: `assets mint cancel`
	// CancelBatch will attempt to cancel the current pending batch.
	CancelBatch(context.Context, *CancelBatchRequest) (*CancelBatchResponse, error)
	// tapcli: `assets mint batches`
	// ListBatches lists the set of batches submitted to the daemon, including
	// pending and cancelled batches.
	ListBatches(context.Context, *ListBatchRequest) (*ListBatchResponse, error)
	// tapcli: `events mint`
	// SubscribeMintEvents allows a caller to subscribe to mint events for asset
	// creation batches.
	SubscribeMintEvents(*SubscribeMintEventsRequest, grpc.ServerStreamingServer[MintEvent]) error
	mustEmbedUnimplementedMintServer()
}

// UnimplementedMintServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMintServer struct{}

func (UnimplementedMintServer) MintAsset(context.Context, *MintAssetRequest) (*MintAssetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MintAsset not implemented")
}
func (UnimplementedMintServer) FundBatch(context.Context, *FundBatchRequest) (*FundBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FundBatch not implemented")
}
func (UnimplementedMintServer) SealBatch(context.Context, *SealBatchRequest) (*SealBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SealBatch not implemented")
}
func (UnimplementedMintServer) FinalizeBatch(context.Context, *FinalizeBatchRequest) (*FinalizeBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinalizeBatch not implemented")
}
func (UnimplementedMintServer) CancelBatch(context.Context, *CancelBatchRequest) (*CancelBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelBatch not implemented")
}
func (UnimplementedMintServer) ListBatches(context.Context, *ListBatchRequest) (*ListBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBatches not implemented")
}
func (UnimplementedMintServer) SubscribeMintEvents(*SubscribeMintEventsRequest, grpc.ServerStreamingServer[MintEvent]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeMintEvents not implemented")
}
func (UnimplementedMintServer) mustEmbedUnimplementedMintServer() {}
func (UnimplementedMintServer) testEmbeddedByValue()              {}

// UnsafeMintServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MintServer will
// result in compilation errors.
type UnsafeMintServer interface {
	mustEmbedUnimplementedMintServer()
}

func RegisterMintServer(s grpc.ServiceRegistrar, srv MintServer) {
	// If the following call pancis, it indicates UnimplementedMintServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mint_ServiceDesc, srv)
}

func _Mint_MintAsset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MintAssetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MintServer).MintAsset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mint_MintAsset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MintServer).MintAsset(ctx, req.(*MintAssetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mint_FundBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FundBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MintServer).FundBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mint_FundBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MintServer).FundBatch(ctx, req.(*FundBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mint_SealBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SealBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MintServer).SealBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mint_SealBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MintServer).SealBatch(ctx, req.(*SealBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mint_FinalizeBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinalizeBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MintServer).FinalizeBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mint_FinalizeBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MintServer).FinalizeBatch(ctx, req.(*FinalizeBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mint_CancelBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MintServer).CancelBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mint_CancelBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MintServer).CancelBatch(ctx, req.(*CancelBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mint_ListBatches_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MintServer).ListBatches(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mint_ListBatches_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MintServer).ListBatches(ctx, req.(*ListBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mint_SubscribeMintEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeMintEventsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MintServer).SubscribeMintEvents(m, &grpc.GenericServerStream[SubscribeMintEventsRequest, MintEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Mint_SubscribeMintEventsServer = grpc.ServerStreamingServer[MintEvent]

// Mint_ServiceDesc is the grpc.ServiceDesc for Mint service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mint_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mintrpc.Mint",
	HandlerType: (*MintServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MintAsset",
			Handler:    _Mint_MintAsset_Handler,
		},
		{
			MethodName: "FundBatch",
			Handler:    _Mint_FundBatch_Handler,
		},
		{
			MethodName: "SealBatch",
			Handler:    _Mint_SealBatch_Handler,
		},
		{
			MethodName: "FinalizeBatch",
			Handler:    _Mint_FinalizeBatch_Handler,
		},
		{
			MethodName: "CancelBatch",
			Handler:    _Mint_CancelBatch_Handler,
		},
		{
			MethodName: "ListBatches",
			Handler:    _Mint_ListBatches_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeMintEvents",
			Handler:       _Mint_SubscribeMintEvents_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "mintrpc/mint.proto",
}
