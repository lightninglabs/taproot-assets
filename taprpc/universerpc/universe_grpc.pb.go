// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: universerpc/universe.proto

package universerpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Universe_MultiverseRoot_FullMethodName            = "/universerpc.Universe/MultiverseRoot"
	Universe_AssetRoots_FullMethodName                = "/universerpc.Universe/AssetRoots"
	Universe_QueryAssetRoots_FullMethodName           = "/universerpc.Universe/QueryAssetRoots"
	Universe_DeleteAssetRoot_FullMethodName           = "/universerpc.Universe/DeleteAssetRoot"
	Universe_AssetLeafKeys_FullMethodName             = "/universerpc.Universe/AssetLeafKeys"
	Universe_AssetLeaves_FullMethodName               = "/universerpc.Universe/AssetLeaves"
	Universe_QueryProof_FullMethodName                = "/universerpc.Universe/QueryProof"
	Universe_InsertProof_FullMethodName               = "/universerpc.Universe/InsertProof"
	Universe_PushProof_FullMethodName                 = "/universerpc.Universe/PushProof"
	Universe_Info_FullMethodName                      = "/universerpc.Universe/Info"
	Universe_SyncUniverse_FullMethodName              = "/universerpc.Universe/SyncUniverse"
	Universe_ListFederationServers_FullMethodName     = "/universerpc.Universe/ListFederationServers"
	Universe_AddFederationServer_FullMethodName       = "/universerpc.Universe/AddFederationServer"
	Universe_DeleteFederationServer_FullMethodName    = "/universerpc.Universe/DeleteFederationServer"
	Universe_UniverseStats_FullMethodName             = "/universerpc.Universe/UniverseStats"
	Universe_QueryAssetStats_FullMethodName           = "/universerpc.Universe/QueryAssetStats"
	Universe_QueryEvents_FullMethodName               = "/universerpc.Universe/QueryEvents"
	Universe_SetFederationSyncConfig_FullMethodName   = "/universerpc.Universe/SetFederationSyncConfig"
	Universe_QueryFederationSyncConfig_FullMethodName = "/universerpc.Universe/QueryFederationSyncConfig"
)

// UniverseClient is the client API for Universe service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UniverseClient interface {
	// tapcli: `universe multiverse`
	// MultiverseRoot returns the root of the multiverse tree. This is useful to
	// determine the equality of two multiverse trees, since the root can directly
	// be compared to another multiverse root to find out if a sync is required.
	MultiverseRoot(ctx context.Context, in *MultiverseRootRequest, opts ...grpc.CallOption) (*MultiverseRootResponse, error)
	// tapcli: `universe roots`
	// AssetRoots queries for the known Universe roots associated with each known
	// asset. These roots represent the supply/audit state for each known asset.
	AssetRoots(ctx context.Context, in *AssetRootRequest, opts ...grpc.CallOption) (*AssetRootResponse, error)
	// tapcli: `universe roots`
	// QueryAssetRoots attempts to locate the current Universe root for a specific
	// asset. This asset can be identified by its asset ID or group key.
	QueryAssetRoots(ctx context.Context, in *AssetRootQuery, opts ...grpc.CallOption) (*QueryRootResponse, error)
	// tapcli: `universe delete`
	// DeleteAssetRoot deletes the Universe root for a specific asset, including
	// all asoociated universe keys, leaves, and events.
	DeleteAssetRoot(ctx context.Context, in *DeleteRootQuery, opts ...grpc.CallOption) (*DeleteRootResponse, error)
	// tapcli: `universe keys`
	// AssetLeafKeys queries for the set of Universe keys associated with a given
	// asset_id or group_key. Each key takes the form: (outpoint, script_key),
	// where outpoint is an outpoint in the Bitcoin blockchain that anchors a
	// valid Taproot Asset commitment, and script_key is the script_key of
	// the asset within the Taproot Asset commitment for the given asset_id or
	// group_key.
	AssetLeafKeys(ctx context.Context, in *AssetLeafKeysRequest, opts ...grpc.CallOption) (*AssetLeafKeyResponse, error)
	// tapcli: `universe leaves`
	// AssetLeaves queries for the set of asset leaves (the values in the Universe
	// MS-SMT tree) for a given asset_id or group_key. These represents either
	// asset issuance events (they have a genesis witness) or asset transfers that
	// took place on chain. The leaves contain a normal Taproot Asset proof, as
	// well as details for the asset.
	AssetLeaves(ctx context.Context, in *ID, opts ...grpc.CallOption) (*AssetLeafResponse, error)
	// tapcli: `universe proofs query`
	// QueryProof attempts to query for an issuance or transfer proof for a given
	// asset based on its UniverseKey. A UniverseKey is composed of the Universe
	// ID (asset_id/group_key) and also a leaf key (outpoint || script_key). If
	// found, then the issuance proof is returned that includes an inclusion proof
	// to the known Universe root, as well as a Taproot Asset state transition or
	// issuance proof for the said asset.
	QueryProof(ctx context.Context, in *UniverseKey, opts ...grpc.CallOption) (*AssetProofResponse, error)
	// tapcli: `universe proofs insert`
	// InsertProof attempts to insert a new issuance or transfer proof into the
	// Universe tree specified by the UniverseKey. If valid, then the proof is
	// inserted into the database, with a new Universe root returned for the
	// updated asset_id/group_key.
	InsertProof(ctx context.Context, in *AssetProof, opts ...grpc.CallOption) (*AssetProofResponse, error)
	// tapcli: `universe proofs push`
	// PushProof attempts to query the local universe for a proof specified by a
	// UniverseKey. If found, a connection is made to a remote Universe server to
	// attempt to upload the asset leaf.
	PushProof(ctx context.Context, in *PushProofRequest, opts ...grpc.CallOption) (*PushProofResponse, error)
	// tapcli: `universe info`
	// Info returns a set of information about the current state of the Universe.
	Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse, error)
	// tapcli: `universe sync`
	// SyncUniverse takes host information for a remote Universe server, then
	// attempts to synchronize either only the set of specified asset_ids, or all
	// assets if none are specified. The sync process will attempt to query for
	// the latest known root for each asset, performing tree based reconciliation
	// to arrive at a new shared root.
	SyncUniverse(ctx context.Context, in *SyncRequest, opts ...grpc.CallOption) (*SyncResponse, error)
	// tapcli: `universe federation list`
	// ListFederationServers lists the set of servers that make up the federation
	// of the local Universe server. This servers are used to push out new proofs,
	// and also periodically call sync new proofs from the remote server.
	ListFederationServers(ctx context.Context, in *ListFederationServersRequest, opts ...grpc.CallOption) (*ListFederationServersResponse, error)
	// tapcli: `universe federation add`
	// AddFederationServer adds a new server to the federation of the local
	// Universe server. Once a server is added, this call can also optionally be
	// used to trigger a sync of the remote server.
	AddFederationServer(ctx context.Context, in *AddFederationServerRequest, opts ...grpc.CallOption) (*AddFederationServerResponse, error)
	// tapcli: `universe federation del`
	// DeleteFederationServer removes a server from the federation of the local
	// Universe server.
	DeleteFederationServer(ctx context.Context, in *DeleteFederationServerRequest, opts ...grpc.CallOption) (*DeleteFederationServerResponse, error)
	// tapcli: `universe stats`
	// UniverseStats returns a set of aggregate statistics for the current state
	// of the Universe. Stats returned include: total number of syncs, total
	// number of proofs, and total number of known assets.
	UniverseStats(ctx context.Context, in *StatsRequest, opts ...grpc.CallOption) (*StatsResponse, error)
	// tapcli `universe stats assets`
	// QueryAssetStats returns a set of statistics for a given set of assets.
	// Stats can be queried for all assets, or based on the: asset ID, name, or
	// asset type. Pagination is supported via the offset and limit params.
	// Results can also be sorted based on any of the main query params.
	QueryAssetStats(ctx context.Context, in *AssetStatsQuery, opts ...grpc.CallOption) (*UniverseAssetStats, error)
	// tapcli `universe stats events`
	// QueryEvents returns the number of sync and proof events for a given time
	// period, grouped by day.
	QueryEvents(ctx context.Context, in *QueryEventsRequest, opts ...grpc.CallOption) (*QueryEventsResponse, error)
	// SetFederationSyncConfig sets the configuration of the universe federation
	// sync.
	SetFederationSyncConfig(ctx context.Context, in *SetFederationSyncConfigRequest, opts ...grpc.CallOption) (*SetFederationSyncConfigResponse, error)
	// tapcli: `universe federation config info`
	// QueryFederationSyncConfig queries the universe federation sync configuration
	// settings.
	QueryFederationSyncConfig(ctx context.Context, in *QueryFederationSyncConfigRequest, opts ...grpc.CallOption) (*QueryFederationSyncConfigResponse, error)
}

type universeClient struct {
	cc grpc.ClientConnInterface
}

func NewUniverseClient(cc grpc.ClientConnInterface) UniverseClient {
	return &universeClient{cc}
}

func (c *universeClient) MultiverseRoot(ctx context.Context, in *MultiverseRootRequest, opts ...grpc.CallOption) (*MultiverseRootResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MultiverseRootResponse)
	err := c.cc.Invoke(ctx, Universe_MultiverseRoot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *universeClient) AssetRoots(ctx context.Context, in *AssetRootRequest, opts ...grpc.CallOption) (*AssetRootResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AssetRootResponse)
	err := c.cc.Invoke(ctx, Universe_AssetRoots_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *universeClient) QueryAssetRoots(ctx context.Context, in *AssetRootQuery, opts ...grpc.CallOption) (*QueryRootResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryRootResponse)
	err := c.cc.Invoke(ctx, Universe_QueryAssetRoots_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *universeClient) DeleteAssetRoot(ctx context.Context, in *DeleteRootQuery, opts ...grpc.CallOption) (*DeleteRootResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteRootResponse)
	err := c.cc.Invoke(ctx, Universe_DeleteAssetRoot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *universeClient) AssetLeafKeys(ctx context.Context, in *AssetLeafKeysRequest, opts ...grpc.CallOption) (*AssetLeafKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AssetLeafKeyResponse)
	err := c.cc.Invoke(ctx, Universe_AssetLeafKeys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *universeClient) AssetLeaves(ctx context.Context, in *ID, opts ...grpc.CallOption) (*AssetLeafResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AssetLeafResponse)
	err := c.cc.Invoke(ctx, Universe_AssetLeaves_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *universeClient) QueryProof(ctx context.Context, in *UniverseKey, opts ...grpc.CallOption) (*AssetProofResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AssetProofResponse)
	err := c.cc.Invoke(ctx, Universe_QueryProof_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *universeClient) InsertProof(ctx context.Context, in *AssetProof, opts ...grpc.CallOption) (*AssetProofResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AssetProofResponse)
	err := c.cc.Invoke(ctx, Universe_InsertProof_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *universeClient) PushProof(ctx context.Context, in *PushProofRequest, opts ...grpc.CallOption) (*PushProofResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PushProofResponse)
	err := c.cc.Invoke(ctx, Universe_PushProof_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *universeClient) Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InfoResponse)
	err := c.cc.Invoke(ctx, Universe_Info_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *universeClient) SyncUniverse(ctx context.Context, in *SyncRequest, opts ...grpc.CallOption) (*SyncResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SyncResponse)
	err := c.cc.Invoke(ctx, Universe_SyncUniverse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *universeClient) ListFederationServers(ctx context.Context, in *ListFederationServersRequest, opts ...grpc.CallOption) (*ListFederationServersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListFederationServersResponse)
	err := c.cc.Invoke(ctx, Universe_ListFederationServers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *universeClient) AddFederationServer(ctx context.Context, in *AddFederationServerRequest, opts ...grpc.CallOption) (*AddFederationServerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddFederationServerResponse)
	err := c.cc.Invoke(ctx, Universe_AddFederationServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *universeClient) DeleteFederationServer(ctx context.Context, in *DeleteFederationServerRequest, opts ...grpc.CallOption) (*DeleteFederationServerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteFederationServerResponse)
	err := c.cc.Invoke(ctx, Universe_DeleteFederationServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *universeClient) UniverseStats(ctx context.Context, in *StatsRequest, opts ...grpc.CallOption) (*StatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StatsResponse)
	err := c.cc.Invoke(ctx, Universe_UniverseStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *universeClient) QueryAssetStats(ctx context.Context, in *AssetStatsQuery, opts ...grpc.CallOption) (*UniverseAssetStats, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UniverseAssetStats)
	err := c.cc.Invoke(ctx, Universe_QueryAssetStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *universeClient) QueryEvents(ctx context.Context, in *QueryEventsRequest, opts ...grpc.CallOption) (*QueryEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryEventsResponse)
	err := c.cc.Invoke(ctx, Universe_QueryEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *universeClient) SetFederationSyncConfig(ctx context.Context, in *SetFederationSyncConfigRequest, opts ...grpc.CallOption) (*SetFederationSyncConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetFederationSyncConfigResponse)
	err := c.cc.Invoke(ctx, Universe_SetFederationSyncConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *universeClient) QueryFederationSyncConfig(ctx context.Context, in *QueryFederationSyncConfigRequest, opts ...grpc.CallOption) (*QueryFederationSyncConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryFederationSyncConfigResponse)
	err := c.cc.Invoke(ctx, Universe_QueryFederationSyncConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UniverseServer is the server API for Universe service.
// All implementations must embed UnimplementedUniverseServer
// for forward compatibility.
type UniverseServer interface {
	// tapcli: `universe multiverse`
	// MultiverseRoot returns the root of the multiverse tree. This is useful to
	// determine the equality of two multiverse trees, since the root can directly
	// be compared to another multiverse root to find out if a sync is required.
	MultiverseRoot(context.Context, *MultiverseRootRequest) (*MultiverseRootResponse, error)
	// tapcli: `universe roots`
	// AssetRoots queries for the known Universe roots associated with each known
	// asset. These roots represent the supply/audit state for each known asset.
	AssetRoots(context.Context, *AssetRootRequest) (*AssetRootResponse, error)
	// tapcli: `universe roots`
	// QueryAssetRoots attempts to locate the current Universe root for a specific
	// asset. This asset can be identified by its asset ID or group key.
	QueryAssetRoots(context.Context, *AssetRootQuery) (*QueryRootResponse, error)
	// tapcli: `universe delete`
	// DeleteAssetRoot deletes the Universe root for a specific asset, including
	// all asoociated universe keys, leaves, and events.
	DeleteAssetRoot(context.Context, *DeleteRootQuery) (*DeleteRootResponse, error)
	// tapcli: `universe keys`
	// AssetLeafKeys queries for the set of Universe keys associated with a given
	// asset_id or group_key. Each key takes the form: (outpoint, script_key),
	// where outpoint is an outpoint in the Bitcoin blockchain that anchors a
	// valid Taproot Asset commitment, and script_key is the script_key of
	// the asset within the Taproot Asset commitment for the given asset_id or
	// group_key.
	AssetLeafKeys(context.Context, *AssetLeafKeysRequest) (*AssetLeafKeyResponse, error)
	// tapcli: `universe leaves`
	// AssetLeaves queries for the set of asset leaves (the values in the Universe
	// MS-SMT tree) for a given asset_id or group_key. These represents either
	// asset issuance events (they have a genesis witness) or asset transfers that
	// took place on chain. The leaves contain a normal Taproot Asset proof, as
	// well as details for the asset.
	AssetLeaves(context.Context, *ID) (*AssetLeafResponse, error)
	// tapcli: `universe proofs query`
	// QueryProof attempts to query for an issuance or transfer proof for a given
	// asset based on its UniverseKey. A UniverseKey is composed of the Universe
	// ID (asset_id/group_key) and also a leaf key (outpoint || script_key). If
	// found, then the issuance proof is returned that includes an inclusion proof
	// to the known Universe root, as well as a Taproot Asset state transition or
	// issuance proof for the said asset.
	QueryProof(context.Context, *UniverseKey) (*AssetProofResponse, error)
	// tapcli: `universe proofs insert`
	// InsertProof attempts to insert a new issuance or transfer proof into the
	// Universe tree specified by the UniverseKey. If valid, then the proof is
	// inserted into the database, with a new Universe root returned for the
	// updated asset_id/group_key.
	InsertProof(context.Context, *AssetProof) (*AssetProofResponse, error)
	// tapcli: `universe proofs push`
	// PushProof attempts to query the local universe for a proof specified by a
	// UniverseKey. If found, a connection is made to a remote Universe server to
	// attempt to upload the asset leaf.
	PushProof(context.Context, *PushProofRequest) (*PushProofResponse, error)
	// tapcli: `universe info`
	// Info returns a set of information about the current state of the Universe.
	Info(context.Context, *InfoRequest) (*InfoResponse, error)
	// tapcli: `universe sync`
	// SyncUniverse takes host information for a remote Universe server, then
	// attempts to synchronize either only the set of specified asset_ids, or all
	// assets if none are specified. The sync process will attempt to query for
	// the latest known root for each asset, performing tree based reconciliation
	// to arrive at a new shared root.
	SyncUniverse(context.Context, *SyncRequest) (*SyncResponse, error)
	// tapcli: `universe federation list`
	// ListFederationServers lists the set of servers that make up the federation
	// of the local Universe server. This servers are used to push out new proofs,
	// and also periodically call sync new proofs from the remote server.
	ListFederationServers(context.Context, *ListFederationServersRequest) (*ListFederationServersResponse, error)
	// tapcli: `universe federation add`
	// AddFederationServer adds a new server to the federation of the local
	// Universe server. Once a server is added, this call can also optionally be
	// used to trigger a sync of the remote server.
	AddFederationServer(context.Context, *AddFederationServerRequest) (*AddFederationServerResponse, error)
	// tapcli: `universe federation del`
	// DeleteFederationServer removes a server from the federation of the local
	// Universe server.
	DeleteFederationServer(context.Context, *DeleteFederationServerRequest) (*DeleteFederationServerResponse, error)
	// tapcli: `universe stats`
	// UniverseStats returns a set of aggregate statistics for the current state
	// of the Universe. Stats returned include: total number of syncs, total
	// number of proofs, and total number of known assets.
	UniverseStats(context.Context, *StatsRequest) (*StatsResponse, error)
	// tapcli `universe stats assets`
	// QueryAssetStats returns a set of statistics for a given set of assets.
	// Stats can be queried for all assets, or based on the: asset ID, name, or
	// asset type. Pagination is supported via the offset and limit params.
	// Results can also be sorted based on any of the main query params.
	QueryAssetStats(context.Context, *AssetStatsQuery) (*UniverseAssetStats, error)
	// tapcli `universe stats events`
	// QueryEvents returns the number of sync and proof events for a given time
	// period, grouped by day.
	QueryEvents(context.Context, *QueryEventsRequest) (*QueryEventsResponse, error)
	// SetFederationSyncConfig sets the configuration of the universe federation
	// sync.
	SetFederationSyncConfig(context.Context, *SetFederationSyncConfigRequest) (*SetFederationSyncConfigResponse, error)
	// tapcli: `universe federation config info`
	// QueryFederationSyncConfig queries the universe federation sync configuration
	// settings.
	QueryFederationSyncConfig(context.Context, *QueryFederationSyncConfigRequest) (*QueryFederationSyncConfigResponse, error)
	mustEmbedUnimplementedUniverseServer()
}

// UnimplementedUniverseServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUniverseServer struct{}

func (UnimplementedUniverseServer) MultiverseRoot(context.Context, *MultiverseRootRequest) (*MultiverseRootResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MultiverseRoot not implemented")
}
func (UnimplementedUniverseServer) AssetRoots(context.Context, *AssetRootRequest) (*AssetRootResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssetRoots not implemented")
}
func (UnimplementedUniverseServer) QueryAssetRoots(context.Context, *AssetRootQuery) (*QueryRootResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAssetRoots not implemented")
}
func (UnimplementedUniverseServer) DeleteAssetRoot(context.Context, *DeleteRootQuery) (*DeleteRootResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAssetRoot not implemented")
}
func (UnimplementedUniverseServer) AssetLeafKeys(context.Context, *AssetLeafKeysRequest) (*AssetLeafKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssetLeafKeys not implemented")
}
func (UnimplementedUniverseServer) AssetLeaves(context.Context, *ID) (*AssetLeafResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssetLeaves not implemented")
}
func (UnimplementedUniverseServer) QueryProof(context.Context, *UniverseKey) (*AssetProofResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryProof not implemented")
}
func (UnimplementedUniverseServer) InsertProof(context.Context, *AssetProof) (*AssetProofResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InsertProof not implemented")
}
func (UnimplementedUniverseServer) PushProof(context.Context, *PushProofRequest) (*PushProofResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushProof not implemented")
}
func (UnimplementedUniverseServer) Info(context.Context, *InfoRequest) (*InfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Info not implemented")
}
func (UnimplementedUniverseServer) SyncUniverse(context.Context, *SyncRequest) (*SyncResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncUniverse not implemented")
}
func (UnimplementedUniverseServer) ListFederationServers(context.Context, *ListFederationServersRequest) (*ListFederationServersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListFederationServers not implemented")
}
func (UnimplementedUniverseServer) AddFederationServer(context.Context, *AddFederationServerRequest) (*AddFederationServerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddFederationServer not implemented")
}
func (UnimplementedUniverseServer) DeleteFederationServer(context.Context, *DeleteFederationServerRequest) (*DeleteFederationServerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFederationServer not implemented")
}
func (UnimplementedUniverseServer) UniverseStats(context.Context, *StatsRequest) (*StatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UniverseStats not implemented")
}
func (UnimplementedUniverseServer) QueryAssetStats(context.Context, *AssetStatsQuery) (*UniverseAssetStats, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAssetStats not implemented")
}
func (UnimplementedUniverseServer) QueryEvents(context.Context, *QueryEventsRequest) (*QueryEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryEvents not implemented")
}
func (UnimplementedUniverseServer) SetFederationSyncConfig(context.Context, *SetFederationSyncConfigRequest) (*SetFederationSyncConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetFederationSyncConfig not implemented")
}
func (UnimplementedUniverseServer) QueryFederationSyncConfig(context.Context, *QueryFederationSyncConfigRequest) (*QueryFederationSyncConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryFederationSyncConfig not implemented")
}
func (UnimplementedUniverseServer) mustEmbedUnimplementedUniverseServer() {}
func (UnimplementedUniverseServer) testEmbeddedByValue()                  {}

// UnsafeUniverseServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UniverseServer will
// result in compilation errors.
type UnsafeUniverseServer interface {
	mustEmbedUnimplementedUniverseServer()
}

func RegisterUniverseServer(s grpc.ServiceRegistrar, srv UniverseServer) {
	// If the following call pancis, it indicates UnimplementedUniverseServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Universe_ServiceDesc, srv)
}

func _Universe_MultiverseRoot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MultiverseRootRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).MultiverseRoot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Universe_MultiverseRoot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).MultiverseRoot(ctx, req.(*MultiverseRootRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Universe_AssetRoots_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssetRootRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).AssetRoots(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Universe_AssetRoots_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).AssetRoots(ctx, req.(*AssetRootRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Universe_QueryAssetRoots_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssetRootQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).QueryAssetRoots(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Universe_QueryAssetRoots_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).QueryAssetRoots(ctx, req.(*AssetRootQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Universe_DeleteAssetRoot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRootQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).DeleteAssetRoot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Universe_DeleteAssetRoot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).DeleteAssetRoot(ctx, req.(*DeleteRootQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Universe_AssetLeafKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssetLeafKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).AssetLeafKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Universe_AssetLeafKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).AssetLeafKeys(ctx, req.(*AssetLeafKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Universe_AssetLeaves_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).AssetLeaves(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Universe_AssetLeaves_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).AssetLeaves(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Universe_QueryProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UniverseKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).QueryProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Universe_QueryProof_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).QueryProof(ctx, req.(*UniverseKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Universe_InsertProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssetProof)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).InsertProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Universe_InsertProof_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).InsertProof(ctx, req.(*AssetProof))
	}
	return interceptor(ctx, in, info, handler)
}

func _Universe_PushProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).PushProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Universe_PushProof_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).PushProof(ctx, req.(*PushProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Universe_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Universe_Info_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).Info(ctx, req.(*InfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Universe_SyncUniverse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).SyncUniverse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Universe_SyncUniverse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).SyncUniverse(ctx, req.(*SyncRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Universe_ListFederationServers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFederationServersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).ListFederationServers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Universe_ListFederationServers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).ListFederationServers(ctx, req.(*ListFederationServersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Universe_AddFederationServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddFederationServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).AddFederationServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Universe_AddFederationServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).AddFederationServer(ctx, req.(*AddFederationServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Universe_DeleteFederationServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFederationServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).DeleteFederationServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Universe_DeleteFederationServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).DeleteFederationServer(ctx, req.(*DeleteFederationServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Universe_UniverseStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).UniverseStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Universe_UniverseStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).UniverseStats(ctx, req.(*StatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Universe_QueryAssetStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssetStatsQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).QueryAssetStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Universe_QueryAssetStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).QueryAssetStats(ctx, req.(*AssetStatsQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Universe_QueryEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).QueryEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Universe_QueryEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).QueryEvents(ctx, req.(*QueryEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Universe_SetFederationSyncConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetFederationSyncConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).SetFederationSyncConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Universe_SetFederationSyncConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).SetFederationSyncConfig(ctx, req.(*SetFederationSyncConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Universe_QueryFederationSyncConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryFederationSyncConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).QueryFederationSyncConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Universe_QueryFederationSyncConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).QueryFederationSyncConfig(ctx, req.(*QueryFederationSyncConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Universe_ServiceDesc is the grpc.ServiceDesc for Universe service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Universe_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "universerpc.Universe",
	HandlerType: (*UniverseServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MultiverseRoot",
			Handler:    _Universe_MultiverseRoot_Handler,
		},
		{
			MethodName: "AssetRoots",
			Handler:    _Universe_AssetRoots_Handler,
		},
		{
			MethodName: "QueryAssetRoots",
			Handler:    _Universe_QueryAssetRoots_Handler,
		},
		{
			MethodName: "DeleteAssetRoot",
			Handler:    _Universe_DeleteAssetRoot_Handler,
		},
		{
			MethodName: "AssetLeafKeys",
			Handler:    _Universe_AssetLeafKeys_Handler,
		},
		{
			MethodName: "AssetLeaves",
			Handler:    _Universe_AssetLeaves_Handler,
		},
		{
			MethodName: "QueryProof",
			Handler:    _Universe_QueryProof_Handler,
		},
		{
			MethodName: "InsertProof",
			Handler:    _Universe_InsertProof_Handler,
		},
		{
			MethodName: "PushProof",
			Handler:    _Universe_PushProof_Handler,
		},
		{
			MethodName: "Info",
			Handler:    _Universe_Info_Handler,
		},
		{
			MethodName: "SyncUniverse",
			Handler:    _Universe_SyncUniverse_Handler,
		},
		{
			MethodName: "ListFederationServers",
			Handler:    _Universe_ListFederationServers_Handler,
		},
		{
			MethodName: "AddFederationServer",
			Handler:    _Universe_AddFederationServer_Handler,
		},
		{
			MethodName: "DeleteFederationServer",
			Handler:    _Universe_DeleteFederationServer_Handler,
		},
		{
			MethodName: "UniverseStats",
			Handler:    _Universe_UniverseStats_Handler,
		},
		{
			MethodName: "QueryAssetStats",
			Handler:    _Universe_QueryAssetStats_Handler,
		},
		{
			MethodName: "QueryEvents",
			Handler:    _Universe_QueryEvents_Handler,
		},
		{
			MethodName: "SetFederationSyncConfig",
			Handler:    _Universe_SetFederationSyncConfig_Handler,
		},
		{
			MethodName: "QueryFederationSyncConfig",
			Handler:    _Universe_QueryFederationSyncConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "universerpc/universe.proto",
}
