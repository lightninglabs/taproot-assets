// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: assets.sql

package sqlite

import (
	"context"
	"database/sql"
	"time"
)

const allAssets = `-- name: AllAssets :many

SELECT asset_id, version, script_key_id, asset_family_sig_id, script_version, amount, lock_time, relative_lock_time, split_commitment_root_hash, split_commitment_root_value, anchor_utxo_id 
FROM assets
`

// TODO(roasbeef): join on managed utxo ID
// * group by asset_id
func (q *Queries) AllAssets(ctx context.Context) ([]Asset, error) {
	rows, err := q.db.QueryContext(ctx, allAssets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.Version,
			&i.ScriptKeyID,
			&i.AssetFamilySigID,
			&i.ScriptVersion,
			&i.Amount,
			&i.LockTime,
			&i.RelativeLockTime,
			&i.SplitCommitmentRootHash,
			&i.SplitCommitmentRootValue,
			&i.AnchorUtxoID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allInternalKeys = `-- name: AllInternalKeys :many
SELECT key_id, raw_key, tweak, key_family, key_index 
FROM internal_keys
`

func (q *Queries) AllInternalKeys(ctx context.Context) ([]InternalKey, error) {
	rows, err := q.db.QueryContext(ctx, allInternalKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InternalKey
	for rows.Next() {
		var i InternalKey
		if err := rows.Scan(
			&i.KeyID,
			&i.RawKey,
			&i.Tweak,
			&i.KeyFamily,
			&i.KeyIndex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allMintingBatches = `-- name: AllMintingBatches :many
SELECT batch_id, batch_state, minting_tx_psbt, minting_output_index, genesis_id, creation_time_unix, key_id, raw_key, tweak, key_family, key_index 
FROM asset_minting_batches
JOIN internal_keys 
ON asset_minting_batches.batch_id = internal_keys.key_id
`

type AllMintingBatchesRow struct {
	BatchID            int32
	BatchState         int16
	MintingTxPsbt      []byte
	MintingOutputIndex sql.NullInt16
	GenesisID          sql.NullInt32
	CreationTimeUnix   time.Time
	KeyID              int32
	RawKey             []byte
	Tweak              []byte
	KeyFamily          int32
	KeyIndex           int32
}

func (q *Queries) AllMintingBatches(ctx context.Context) ([]AllMintingBatchesRow, error) {
	rows, err := q.db.QueryContext(ctx, allMintingBatches)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AllMintingBatchesRow
	for rows.Next() {
		var i AllMintingBatchesRow
		if err := rows.Scan(
			&i.BatchID,
			&i.BatchState,
			&i.MintingTxPsbt,
			&i.MintingOutputIndex,
			&i.GenesisID,
			&i.CreationTimeUnix,
			&i.KeyID,
			&i.RawKey,
			&i.Tweak,
			&i.KeyFamily,
			&i.KeyIndex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const anchorGenesisPoint = `-- name: AnchorGenesisPoint :exec
WITH target_point(genesis_id) AS (
    SELECT genesis_id
    FROM genesis_points
    WHERE genesis_points.prev_out = ?
)
UPDATE genesis_points
SET anchor_tx_id = ?
WHERE genesis_id in (SELECT genesis_id FROM target_point)
`

type AnchorGenesisPointParams struct {
	PrevOut    []byte
	AnchorTxID sql.NullInt32
}

func (q *Queries) AnchorGenesisPoint(ctx context.Context, arg AnchorGenesisPointParams) error {
	_, err := q.db.ExecContext(ctx, anchorGenesisPoint, arg.PrevOut, arg.AnchorTxID)
	return err
}

const anchorPendingAssets = `-- name: AnchorPendingAssets :exec
WITH assets_to_update AS (
    SELECT script_key_id
    FROM assets 
    JOIN genesis_assets 
        ON assets.asset_id = genesis_assets.gen_asset_id
    JOIN genesis_points
        ON genesis_points.genesis_id = genesis_assets.genesis_point_id
    WHERE prev_out = ?
)
UPDATE assets
SET anchor_utxo_id = ?
WHERE script_key_id in (SELECT script_key_id FROM assets_to_update)
`

type AnchorPendingAssetsParams struct {
	PrevOut      []byte
	AnchorUtxoID sql.NullInt32
}

func (q *Queries) AnchorPendingAssets(ctx context.Context, arg AnchorPendingAssetsParams) error {
	_, err := q.db.ExecContext(ctx, anchorPendingAssets, arg.PrevOut, arg.AnchorUtxoID)
	return err
}

const assetsByGenesisPoint = `-- name: AssetsByGenesisPoint :many
SELECT assets.asset_id, version, script_key_id, asset_family_sig_id, script_version, amount, lock_time, relative_lock_time, split_commitment_root_hash, split_commitment_root_value, anchor_utxo_id, gen_asset_id, genesis_assets.asset_id, asset_tag, meta_data, output_index, asset_type, genesis_point_id, genesis_id, prev_out, anchor_tx_id
FROM assets 
JOIN genesis_assets 
    ON assets.asset_id = genesis_assets.gen_asset_id
JOIN genesis_points
    ON genesis_points.genesis_id = genesis_assets.genesis_point_id
WHERE prev_out = ?
`

type AssetsByGenesisPointRow struct {
	AssetID                  int32
	Version                  int32
	ScriptKeyID              int32
	AssetFamilySigID         sql.NullInt32
	ScriptVersion            int32
	Amount                   int64
	LockTime                 sql.NullInt32
	RelativeLockTime         sql.NullInt32
	SplitCommitmentRootHash  []byte
	SplitCommitmentRootValue sql.NullInt64
	AnchorUtxoID             sql.NullInt32
	GenAssetID               int32
	AssetID_2                []byte
	AssetTag                 string
	MetaData                 []byte
	OutputIndex              int32
	AssetType                int16
	GenesisPointID           int32
	GenesisID                int32
	PrevOut                  []byte
	AnchorTxID               sql.NullInt32
}

func (q *Queries) AssetsByGenesisPoint(ctx context.Context, prevOut []byte) ([]AssetsByGenesisPointRow, error) {
	rows, err := q.db.QueryContext(ctx, assetsByGenesisPoint, prevOut)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssetsByGenesisPointRow
	for rows.Next() {
		var i AssetsByGenesisPointRow
		if err := rows.Scan(
			&i.AssetID,
			&i.Version,
			&i.ScriptKeyID,
			&i.AssetFamilySigID,
			&i.ScriptVersion,
			&i.Amount,
			&i.LockTime,
			&i.RelativeLockTime,
			&i.SplitCommitmentRootHash,
			&i.SplitCommitmentRootValue,
			&i.AnchorUtxoID,
			&i.GenAssetID,
			&i.AssetID_2,
			&i.AssetTag,
			&i.MetaData,
			&i.OutputIndex,
			&i.AssetType,
			&i.GenesisPointID,
			&i.GenesisID,
			&i.PrevOut,
			&i.AnchorTxID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const assetsInBatch = `-- name: AssetsInBatch :many
SELECT
    gen_asset_id, asset_id, asset_tag, meta_data, output_index, asset_type,
    genesis_points.prev_out prev_out
FROM genesis_assets
JOIN genesis_points
    ON genesis_assets.genesis_point_id = genesis_points.genesis_id
JOIN asset_minting_batches batches
    ON genesis_points.genesis_id = batches.genesis_id
JOIN internal_keys keys
    ON keys.key_id = batches.batch_id
WHERE keys.raw_key = ?
`

type AssetsInBatchRow struct {
	GenAssetID  int32
	AssetID     []byte
	AssetTag    string
	MetaData    []byte
	OutputIndex int32
	AssetType   int16
	PrevOut     []byte
}

func (q *Queries) AssetsInBatch(ctx context.Context, rawKey []byte) ([]AssetsInBatchRow, error) {
	rows, err := q.db.QueryContext(ctx, assetsInBatch, rawKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssetsInBatchRow
	for rows.Next() {
		var i AssetsInBatchRow
		if err := rows.Scan(
			&i.GenAssetID,
			&i.AssetID,
			&i.AssetTag,
			&i.MetaData,
			&i.OutputIndex,
			&i.AssetType,
			&i.PrevOut,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bindMintingBatchWithTx = `-- name: BindMintingBatchWithTx :exec
WITH target_batch AS (
    SELECT batch_id
    FROM asset_minting_batches batches
    JOIN internal_keys keys
        ON batches.batch_id = keys.key_id
    WHERE keys.raw_key = ?
)
UPDATE asset_minting_batches 
SET minting_tx_psbt = ?, minting_output_index = ?, genesis_id = ?
WHERE batch_id IN (SELECT batch_id FROM target_batch)
`

type BindMintingBatchWithTxParams struct {
	RawKey             []byte
	MintingTxPsbt      []byte
	MintingOutputIndex sql.NullInt16
	GenesisID          sql.NullInt32
}

func (q *Queries) BindMintingBatchWithTx(ctx context.Context, arg BindMintingBatchWithTxParams) error {
	_, err := q.db.ExecContext(ctx, bindMintingBatchWithTx,
		arg.RawKey,
		arg.MintingTxPsbt,
		arg.MintingOutputIndex,
		arg.GenesisID,
	)
	return err
}

const confirmChainTx = `-- name: ConfirmChainTx :exec
WITH target_txn(txn_id) AS (
    SELECT anchor_tx_id
    FROM genesis_points points
    JOIN asset_minting_batches batches
        ON batches.genesis_id = points.genesis_id
    JOIN internal_keys keys
        ON batches.batch_id = keys.key_id
    WHERE keys.raw_key = ?
)
UPDATE chain_txns
SET block_height = ?, block_hash = ?, tx_index = ?
WHERE txn_id in (SELECT txn_id FROm target_txn)
`

type ConfirmChainTxParams struct {
	RawKey      []byte
	BlockHeight sql.NullInt32
	BlockHash   []byte
	TxIndex     sql.NullInt32
}

func (q *Queries) ConfirmChainTx(ctx context.Context, arg ConfirmChainTxParams) error {
	_, err := q.db.ExecContext(ctx, confirmChainTx,
		arg.RawKey,
		arg.BlockHeight,
		arg.BlockHash,
		arg.TxIndex,
	)
	return err
}

const fetchAssetProof = `-- name: FetchAssetProof :one
WITH asset_info AS (
    SELECT assets.asset_id, keys.raw_key
    FROM assets
    JOIN internal_keys keys
        ON keys.key_id = assets.script_key_id
    WHERE keys.raw_key = ?
)
SELECT asset_info.raw_key AS script_key, asset_proofs.proof_file
FROM asset_proofs
JOIN asset_info
    ON asset_info.asset_id = asset_proofs.asset_id
`

type FetchAssetProofRow struct {
	ScriptKey []byte
	ProofFile []byte
}

func (q *Queries) FetchAssetProof(ctx context.Context, rawKey []byte) (FetchAssetProofRow, error) {
	row := q.db.QueryRowContext(ctx, fetchAssetProof, rawKey)
	var i FetchAssetProofRow
	err := row.Scan(&i.ScriptKey, &i.ProofFile)
	return i, err
}

const fetchAssetProofs = `-- name: FetchAssetProofs :many
WITH asset_info AS (
    SELECT assets.asset_id, keys.raw_key
    FROM assets
    JOIN internal_keys keys
        ON keys.key_id = assets.script_key_id
)
SELECT asset_info.raw_key AS script_key, asset_proofs.proof_file
FROM asset_proofs
JOIN asset_info
    ON asset_info.asset_id = asset_proofs.asset_id
`

type FetchAssetProofsRow struct {
	ScriptKey []byte
	ProofFile []byte
}

func (q *Queries) FetchAssetProofs(ctx context.Context) ([]FetchAssetProofsRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchAssetProofs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchAssetProofsRow
	for rows.Next() {
		var i FetchAssetProofsRow
		if err := rows.Scan(&i.ScriptKey, &i.ProofFile); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchAssetWitnesses = `-- name: FetchAssetWitnesses :many
SELECT 
    assets.asset_id, prev_out_point, prev_asset_id, prev_script_key, 
    witness_stack, split_commitment_proof
FROM asset_witnesses
JOIN assets
    ON asset_witnesses.asset_id = assets.asset_id
WHERE (
    (assets.asset_id = $1) OR ($1 IS NULL)
)
`

type FetchAssetWitnessesRow struct {
	AssetID              int32
	PrevOutPoint         []byte
	PrevAssetID          []byte
	PrevScriptKey        []byte
	WitnessStack         []byte
	SplitCommitmentProof []byte
}

func (q *Queries) FetchAssetWitnesses(ctx context.Context, assetID sql.NullInt32) ([]FetchAssetWitnessesRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchAssetWitnesses, assetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchAssetWitnessesRow
	for rows.Next() {
		var i FetchAssetWitnessesRow
		if err := rows.Scan(
			&i.AssetID,
			&i.PrevOutPoint,
			&i.PrevAssetID,
			&i.PrevScriptKey,
			&i.WitnessStack,
			&i.SplitCommitmentProof,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchAssetsByAnchorTx = `-- name: FetchAssetsByAnchorTx :many
SELECT asset_id, version, script_key_id, asset_family_sig_id, script_version, amount, lock_time, relative_lock_time, split_commitment_root_hash, split_commitment_root_value, anchor_utxo_id
FROM assets
WHERE anchor_utxo_id = ?
`

func (q *Queries) FetchAssetsByAnchorTx(ctx context.Context, anchorUtxoID sql.NullInt32) ([]Asset, error) {
	rows, err := q.db.QueryContext(ctx, fetchAssetsByAnchorTx, anchorUtxoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.Version,
			&i.ScriptKeyID,
			&i.AssetFamilySigID,
			&i.ScriptVersion,
			&i.Amount,
			&i.LockTime,
			&i.RelativeLockTime,
			&i.SplitCommitmentRootHash,
			&i.SplitCommitmentRootValue,
			&i.AnchorUtxoID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchAssetsForBatch = `-- name: FetchAssetsForBatch :many
WITH genesis_info AS (
    -- This CTE is used to fetch the base asset information from disk based on
    -- the raw key of the batch that will ultimately create this set of assets.
    -- To do so, we'll need to traverse a few tables to join the set of assets
    -- with the genesis points, then with the batches that reference this
    -- points, to the internal key that reference the batch, then restricted
    -- for internal keys that match our main batch key.
    SELECT
        gen_asset_id, asset_id, asset_tag, meta_data, output_index, asset_type,
        genesis_points.prev_out prev_out
    FROM genesis_assets
    JOIN genesis_points
        ON genesis_assets.genesis_point_id = genesis_points.genesis_id
    JOIN asset_minting_batches batches
        ON genesis_points.genesis_id = batches.genesis_id
    JOIN internal_keys keys
        ON keys.key_id = batches.batch_id
    WHERE keys.raw_key = ?
), key_fam_info AS (
    -- This CTE is used to perform a series of joins that allow us to extract
    -- the family key information, as well as the family sigs for the series of
    -- assets we care about. We obtain only the assets found in the batch
    -- above, with the WHERE query at the bottom.
    SELECT 
        sig_id, gen_asset_id, genesis_sig, tweaked_fam_key, raw_key, key_index, key_family
    FROM asset_family_sigs sigs
    JOIN asset_families fams
        ON sigs.key_fam_id = fams.family_id
    JOIN internal_keys keys
        ON keys.key_id = fams.internal_key_id
    -- TODO(roasbeef): or can join do this below?
    WHERE sigs.gen_asset_id IN (SELECT gen_asset_id FROM genesis_info)
)
SELECT 
    version, internal_keys.raw_key AS script_key_raw, 
    internal_keys.tweak AS script_key_tweak,
    internal_keys.key_family AS script_key_fam,
    internal_keys.key_index AS script_key_index, key_fam_info.genesis_sig, 
    key_fam_info.tweaked_fam_key, key_fam_info.raw_key AS fam_key_raw,
    key_fam_info.key_family AS fam_key_family, key_fam_info.key_index AS fam_key_index,
    script_version, amount, lock_time, relative_lock_time, 
    genesis_info.asset_id, genesis_info.asset_tag, genesis_info.meta_data, 
    genesis_info.output_index AS genesis_output_index, genesis_info.asset_type,
    genesis_info.prev_out AS genesis_prev_out
FROM assets
JOIN genesis_info
    ON assets.asset_id = genesis_info.gen_asset_id
LEFT JOIN key_fam_info
    ON assets.asset_id = key_fam_info.gen_asset_id
JOIN internal_keys
    ON assets.script_key_id = internal_keys.key_id
`

type FetchAssetsForBatchRow struct {
	Version            int32
	ScriptKeyRaw       []byte
	ScriptKeyTweak     []byte
	ScriptKeyFam       int32
	ScriptKeyIndex     int32
	GenesisSig         []byte
	TweakedFamKey      []byte
	FamKeyRaw          []byte
	FamKeyFamily       sql.NullInt32
	FamKeyIndex        sql.NullInt32
	ScriptVersion      int32
	Amount             int64
	LockTime           sql.NullInt32
	RelativeLockTime   sql.NullInt32
	AssetID            []byte
	AssetTag           string
	MetaData           []byte
	GenesisOutputIndex int32
	AssetType          int16
	GenesisPrevOut     []byte
}

// We use a LEFT JOIN here as not every asset has a family key, so this'll
// generate rows that have NULL values for the faily key fields if an asset
// doesn't have a family key. See the comment in fetchAssetSprouts for a work
// around that needs to be used with this query until a sqlc bug is fixed.
func (q *Queries) FetchAssetsForBatch(ctx context.Context, rawKey []byte) ([]FetchAssetsForBatchRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchAssetsForBatch, rawKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchAssetsForBatchRow
	for rows.Next() {
		var i FetchAssetsForBatchRow
		if err := rows.Scan(
			&i.Version,
			&i.ScriptKeyRaw,
			&i.ScriptKeyTweak,
			&i.ScriptKeyFam,
			&i.ScriptKeyIndex,
			&i.GenesisSig,
			&i.TweakedFamKey,
			&i.FamKeyRaw,
			&i.FamKeyFamily,
			&i.FamKeyIndex,
			&i.ScriptVersion,
			&i.Amount,
			&i.LockTime,
			&i.RelativeLockTime,
			&i.AssetID,
			&i.AssetTag,
			&i.MetaData,
			&i.GenesisOutputIndex,
			&i.AssetType,
			&i.GenesisPrevOut,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChainTx = `-- name: FetchChainTx :one
SELECT txn_id, txid, raw_tx, block_height, block_hash, tx_index
FROM chain_txns
WHERE txid = ?
`

func (q *Queries) FetchChainTx(ctx context.Context, txid []byte) (ChainTxn, error) {
	row := q.db.QueryRowContext(ctx, fetchChainTx, txid)
	var i ChainTxn
	err := row.Scan(
		&i.TxnID,
		&i.Txid,
		&i.RawTx,
		&i.BlockHeight,
		&i.BlockHash,
		&i.TxIndex,
	)
	return i, err
}

const fetchGenesisPointByAnchorTx = `-- name: FetchGenesisPointByAnchorTx :one
SELECT genesis_id, prev_out, anchor_tx_id 
FROM genesis_points
WHERE anchor_tx_id = ?
`

func (q *Queries) FetchGenesisPointByAnchorTx(ctx context.Context, anchorTxID sql.NullInt32) (GenesisPoint, error) {
	row := q.db.QueryRowContext(ctx, fetchGenesisPointByAnchorTx, anchorTxID)
	var i GenesisPoint
	err := row.Scan(&i.GenesisID, &i.PrevOut, &i.AnchorTxID)
	return i, err
}

const fetchManagedUTXO = `-- name: FetchManagedUTXO :one
SELECT utxo_id, outpoint, amt_sats, internal_key_id, tapscript_sibling, taro_root, txn_id, key_id, raw_key, tweak, key_family, key_index
FROM managed_utxos utxos
JOIN internal_keys keys
    ON utxos.internal_key_id = keys.key_id
WHERE (
    txn_id = COALESCE($1, txn_id) AND
    (length(hex($2)) == 0 OR utxos.outpoint = $2)
)
`

type FetchManagedUTXOParams struct {
	TxnID    sql.NullInt32
	Outpoint interface{}
}

type FetchManagedUTXORow struct {
	UtxoID           int32
	Outpoint         []byte
	AmtSats          int64
	InternalKeyID    int32
	TapscriptSibling []byte
	TaroRoot         []byte
	TxnID            int32
	KeyID            int32
	RawKey           []byte
	Tweak            []byte
	KeyFamily        int32
	KeyIndex         int32
}

func (q *Queries) FetchManagedUTXO(ctx context.Context, arg FetchManagedUTXOParams) (FetchManagedUTXORow, error) {
	row := q.db.QueryRowContext(ctx, fetchManagedUTXO, arg.TxnID, arg.Outpoint)
	var i FetchManagedUTXORow
	err := row.Scan(
		&i.UtxoID,
		&i.Outpoint,
		&i.AmtSats,
		&i.InternalKeyID,
		&i.TapscriptSibling,
		&i.TaroRoot,
		&i.TxnID,
		&i.KeyID,
		&i.RawKey,
		&i.Tweak,
		&i.KeyFamily,
		&i.KeyIndex,
	)
	return i, err
}

const fetchMintingBatch = `-- name: FetchMintingBatch :one
SELECT batch_id, batch_state, minting_tx_psbt, minting_output_index, genesis_id, creation_time_unix, key_id, raw_key, tweak, key_family, key_index
FROM asset_minting_batches batches
JOIN internal_keys keys
    ON batches.batch_id = keys.key_id
WHERE keys.raw_key = ?
`

type FetchMintingBatchRow struct {
	BatchID            int32
	BatchState         int16
	MintingTxPsbt      []byte
	MintingOutputIndex sql.NullInt16
	GenesisID          sql.NullInt32
	CreationTimeUnix   time.Time
	KeyID              int32
	RawKey             []byte
	Tweak              []byte
	KeyFamily          int32
	KeyIndex           int32
}

func (q *Queries) FetchMintingBatch(ctx context.Context, rawKey []byte) (FetchMintingBatchRow, error) {
	row := q.db.QueryRowContext(ctx, fetchMintingBatch, rawKey)
	var i FetchMintingBatchRow
	err := row.Scan(
		&i.BatchID,
		&i.BatchState,
		&i.MintingTxPsbt,
		&i.MintingOutputIndex,
		&i.GenesisID,
		&i.CreationTimeUnix,
		&i.KeyID,
		&i.RawKey,
		&i.Tweak,
		&i.KeyFamily,
		&i.KeyIndex,
	)
	return i, err
}

const fetchMintingBatchesByInverseState = `-- name: FetchMintingBatchesByInverseState :many
SELECT batch_id, batch_state, minting_tx_psbt, minting_output_index, genesis_id, creation_time_unix, key_id, raw_key, tweak, key_family, key_index
FROM asset_minting_batches batches
JOIN internal_keys keys
    ON batches.batch_id = keys.key_id
WHERE batches.batch_state != ?
`

type FetchMintingBatchesByInverseStateRow struct {
	BatchID            int32
	BatchState         int16
	MintingTxPsbt      []byte
	MintingOutputIndex sql.NullInt16
	GenesisID          sql.NullInt32
	CreationTimeUnix   time.Time
	KeyID              int32
	RawKey             []byte
	Tweak              []byte
	KeyFamily          int32
	KeyIndex           int32
}

func (q *Queries) FetchMintingBatchesByInverseState(ctx context.Context, batchState int16) ([]FetchMintingBatchesByInverseStateRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchMintingBatchesByInverseState, batchState)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchMintingBatchesByInverseStateRow
	for rows.Next() {
		var i FetchMintingBatchesByInverseStateRow
		if err := rows.Scan(
			&i.BatchID,
			&i.BatchState,
			&i.MintingTxPsbt,
			&i.MintingOutputIndex,
			&i.GenesisID,
			&i.CreationTimeUnix,
			&i.KeyID,
			&i.RawKey,
			&i.Tweak,
			&i.KeyFamily,
			&i.KeyIndex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchMintingBatchesByState = `-- name: FetchMintingBatchesByState :many
SELECT batch_id, batch_state, minting_tx_psbt, minting_output_index, genesis_id, creation_time_unix, key_id, raw_key, tweak, key_family, key_index
FROM asset_minting_batches batches
JOIN internal_keys keys
    ON batches.batch_id = keys.key_id
WHERE batches.batch_state = ?
`

type FetchMintingBatchesByStateRow struct {
	BatchID            int32
	BatchState         int16
	MintingTxPsbt      []byte
	MintingOutputIndex sql.NullInt16
	GenesisID          sql.NullInt32
	CreationTimeUnix   time.Time
	KeyID              int32
	RawKey             []byte
	Tweak              []byte
	KeyFamily          int32
	KeyIndex           int32
}

func (q *Queries) FetchMintingBatchesByState(ctx context.Context, batchState int16) ([]FetchMintingBatchesByStateRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchMintingBatchesByState, batchState)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchMintingBatchesByStateRow
	for rows.Next() {
		var i FetchMintingBatchesByStateRow
		if err := rows.Scan(
			&i.BatchID,
			&i.BatchState,
			&i.MintingTxPsbt,
			&i.MintingOutputIndex,
			&i.GenesisID,
			&i.CreationTimeUnix,
			&i.KeyID,
			&i.RawKey,
			&i.Tweak,
			&i.KeyFamily,
			&i.KeyIndex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchSeedlingsForBatch = `-- name: FetchSeedlingsForBatch :many
WITH target_batch(batch_id) AS (
    SELECT batch_id
    FROM asset_minting_batches batches
    JOIN internal_keys keys
        ON batches.batch_id = keys.key_id
    WHERE keys.raw_key = ?
)
SELECT seedling_id, asset_name, asset_type, asset_supply, asset_meta,
    emission_enabled, asset_id, batch_id
FROM asset_seedlings 
WHERE asset_seedlings.batch_id in (SELECT batch_id FROM target_batch)
`

func (q *Queries) FetchSeedlingsForBatch(ctx context.Context, rawKey []byte) ([]AssetSeedling, error) {
	rows, err := q.db.QueryContext(ctx, fetchSeedlingsForBatch, rawKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssetSeedling
	for rows.Next() {
		var i AssetSeedling
		if err := rows.Scan(
			&i.SeedlingID,
			&i.AssetName,
			&i.AssetType,
			&i.AssetSupply,
			&i.AssetMeta,
			&i.EmissionEnabled,
			&i.AssetID,
			&i.BatchID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const genesisAssets = `-- name: GenesisAssets :many
SELECT gen_asset_id, asset_id, asset_tag, meta_data, output_index, asset_type, genesis_point_id 
FROM genesis_assets
`

func (q *Queries) GenesisAssets(ctx context.Context) ([]GenesisAsset, error) {
	rows, err := q.db.QueryContext(ctx, genesisAssets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GenesisAsset
	for rows.Next() {
		var i GenesisAsset
		if err := rows.Scan(
			&i.GenAssetID,
			&i.AssetID,
			&i.AssetTag,
			&i.MetaData,
			&i.OutputIndex,
			&i.AssetType,
			&i.GenesisPointID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const genesisPoints = `-- name: GenesisPoints :many
SELECT genesis_id, prev_out, anchor_tx_id 
FROM genesis_points
`

func (q *Queries) GenesisPoints(ctx context.Context) ([]GenesisPoint, error) {
	rows, err := q.db.QueryContext(ctx, genesisPoints)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GenesisPoint
	for rows.Next() {
		var i GenesisPoint
		if err := rows.Scan(&i.GenesisID, &i.PrevOut, &i.AnchorTxID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAssetFamilySig = `-- name: InsertAssetFamilySig :one
INSERT INTO asset_family_sigs (
    genesis_sig, gen_asset_id, key_fam_id
) VALUES (
    ?, ?, ?
) RETURNING sig_id
`

type InsertAssetFamilySigParams struct {
	GenesisSig []byte
	GenAssetID int32
	KeyFamID   int32
}

func (q *Queries) InsertAssetFamilySig(ctx context.Context, arg InsertAssetFamilySigParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertAssetFamilySig, arg.GenesisSig, arg.GenAssetID, arg.KeyFamID)
	var sig_id int32
	err := row.Scan(&sig_id)
	return sig_id, err
}

const insertAssetSeedling = `-- name: InsertAssetSeedling :exec
INSERT INTO asset_seedlings (
    asset_name, asset_type, asset_supply, asset_meta,
    emission_enabled, batch_id
) VALUES (
    ?, ?, ?, ?, ?, ?
)
`

type InsertAssetSeedlingParams struct {
	AssetName       string
	AssetType       int16
	AssetSupply     int64
	AssetMeta       []byte
	EmissionEnabled bool
	BatchID         int32
}

func (q *Queries) InsertAssetSeedling(ctx context.Context, arg InsertAssetSeedlingParams) error {
	_, err := q.db.ExecContext(ctx, insertAssetSeedling,
		arg.AssetName,
		arg.AssetType,
		arg.AssetSupply,
		arg.AssetMeta,
		arg.EmissionEnabled,
		arg.BatchID,
	)
	return err
}

const insertAssetSeedlingIntoBatch = `-- name: InsertAssetSeedlingIntoBatch :exec
WITH target_key_id AS (
    -- We use this CTE to fetch the key_id of the internal key that's
    -- associated with a given batch. This can only return one value in
    -- practice since raw_key is a unique field. We then use this value below
    -- to insert the seedling and point to the proper batch_id, which is a
    -- foreign key that references the key_id of the internal key.
    SELECT key_id 
    FROM internal_keys keys
    WHERE keys.raw_key = ?
)
INSERT INTO asset_seedlings(
    asset_name, asset_type, asset_supply, asset_meta,
    emission_enabled, batch_id
) VALUES (
    ?, ?, ?, ?, ?, (SELECT key_id FROM target_key_id)
)
`

type InsertAssetSeedlingIntoBatchParams struct {
	RawKey          []byte
	AssetName       string
	AssetType       int16
	AssetSupply     int64
	AssetMeta       []byte
	EmissionEnabled bool
}

func (q *Queries) InsertAssetSeedlingIntoBatch(ctx context.Context, arg InsertAssetSeedlingIntoBatchParams) error {
	_, err := q.db.ExecContext(ctx, insertAssetSeedlingIntoBatch,
		arg.RawKey,
		arg.AssetName,
		arg.AssetType,
		arg.AssetSupply,
		arg.AssetMeta,
		arg.EmissionEnabled,
	)
	return err
}

const insertAssetWitness = `-- name: InsertAssetWitness :exec
INSERT INTO asset_witnesses (
    asset_id, prev_out_point, prev_asset_id, prev_script_key, witness_stack,
    split_commitment_proof
) VALUES (
    ?, ?, ?, ?, ?, ?
)
`

type InsertAssetWitnessParams struct {
	AssetID              int32
	PrevOutPoint         []byte
	PrevAssetID          []byte
	PrevScriptKey        []byte
	WitnessStack         []byte
	SplitCommitmentProof []byte
}

func (q *Queries) InsertAssetWitness(ctx context.Context, arg InsertAssetWitnessParams) error {
	_, err := q.db.ExecContext(ctx, insertAssetWitness,
		arg.AssetID,
		arg.PrevOutPoint,
		arg.PrevAssetID,
		arg.PrevScriptKey,
		arg.WitnessStack,
		arg.SplitCommitmentProof,
	)
	return err
}

const insertGenesisAsset = `-- name: InsertGenesisAsset :one
INSERT INTO genesis_assets (
    asset_id, asset_tag, meta_data, output_index, asset_type, genesis_point_id
) VALUES (
    ?, ?, ?, ?, ?, ?
) RETURNING gen_asset_id
`

type InsertGenesisAssetParams struct {
	AssetID        []byte
	AssetTag       string
	MetaData       []byte
	OutputIndex    int32
	AssetType      int16
	GenesisPointID int32
}

func (q *Queries) InsertGenesisAsset(ctx context.Context, arg InsertGenesisAssetParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertGenesisAsset,
		arg.AssetID,
		arg.AssetTag,
		arg.MetaData,
		arg.OutputIndex,
		arg.AssetType,
		arg.GenesisPointID,
	)
	var gen_asset_id int32
	err := row.Scan(&gen_asset_id)
	return gen_asset_id, err
}

const insertNewAsset = `-- name: InsertNewAsset :one
INSERT INTO assets (
    version, script_key_id, asset_id, asset_family_sig_id, script_version, 
    amount, lock_time, relative_lock_time, anchor_utxo_id
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?
) RETURNING asset_id
`

type InsertNewAssetParams struct {
	Version          int32
	ScriptKeyID      int32
	AssetID          int32
	AssetFamilySigID sql.NullInt32
	ScriptVersion    int32
	Amount           int64
	LockTime         sql.NullInt32
	RelativeLockTime sql.NullInt32
	AnchorUtxoID     sql.NullInt32
}

func (q *Queries) InsertNewAsset(ctx context.Context, arg InsertNewAssetParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertNewAsset,
		arg.Version,
		arg.ScriptKeyID,
		arg.AssetID,
		arg.AssetFamilySigID,
		arg.ScriptVersion,
		arg.Amount,
		arg.LockTime,
		arg.RelativeLockTime,
		arg.AnchorUtxoID,
	)
	var asset_id int32
	err := row.Scan(&asset_id)
	return asset_id, err
}

const newMintingBatch = `-- name: NewMintingBatch :exec
INSERT INTO asset_minting_batches (
    batch_state, batch_id, creation_time_unix
) VALUES (0, ?, ?)
`

type NewMintingBatchParams struct {
	BatchID          int32
	CreationTimeUnix time.Time
}

func (q *Queries) NewMintingBatch(ctx context.Context, arg NewMintingBatchParams) error {
	_, err := q.db.ExecContext(ctx, newMintingBatch, arg.BatchID, arg.CreationTimeUnix)
	return err
}

const queryAssets = `-- name: QueryAssets :many
WITH genesis_info AS (
    -- This CTE is used to fetch the base asset information from disk based on
    -- the raw key of the batch that will ultimately create this set of assets.
    -- To do so, we'll need to traverse a few tables to join the set of assets
    -- with the genesis points, then with the batches that reference this
    -- points, to the internal key that reference the batch, then restricted
    -- for internal keys that match our main batch key.
    SELECT
        gen_asset_id, asset_id, asset_tag, meta_data, output_index, asset_type,
        genesis_points.prev_out prev_out
    FROM genesis_assets
    JOIN genesis_points
        ON genesis_assets.genesis_point_id = genesis_points.genesis_id
    -- This filter only runs if the asset_id_filter arg was passed in. This
    -- lets us fetch only the assets for this particular asset ID.
    WHERE length(hex($3)) == 0 OR genesis_assets.asset_id = $3
), key_fam_info AS (
    -- This CTE is used to perform a series of joins that allow us to extract
    -- the family key information, as well as the family sigs for the series of
    -- assets we care about. We obtain only the assets found in the batch
    -- above, with the WHERE query at the bottom.
    SELECT 
        sig_id, gen_asset_id, genesis_sig, tweaked_fam_key, raw_key, key_index, key_family
    FROM asset_family_sigs sigs
    JOIN asset_families fams
        ON sigs.key_fam_id = fams.family_id
    JOIN internal_keys keys
        ON keys.key_id = fams.internal_key_id
    -- TODO(roasbeef): or can join do this below?
    WHERE sigs.gen_asset_id IN (SELECT gen_asset_id FROM genesis_info) AND
        -- This filter only runs if the asset_id_filter arg was passed in. This
        -- lets us fetch only the assets for this particular key family.
       (length(hex($4)) == 0 OR fams.tweaked_fam_key = $4)
)
SELECT 
    assets.asset_id, version, internal_keys.raw_key AS script_key_raw,
    internal_keys.tweak AS script_key_tweak,
    internal_keys.key_family AS script_key_fam,
    internal_keys.key_index AS script_key_index, key_fam_info.genesis_sig, 
    key_fam_info.tweaked_fam_key, key_fam_info.raw_key AS fam_key_raw,
    key_fam_info.key_family AS fam_key_family, key_fam_info.key_index AS fam_key_index,
    script_version, amount, lock_time, relative_lock_time, 
    genesis_info.asset_id, genesis_info.asset_tag, genesis_info.meta_data, 
    genesis_info.output_index AS genesis_output_index, genesis_info.asset_type,
    genesis_info.prev_out AS genesis_prev_out,
    txns.raw_tx AS anchor_tx, txns.txid AS anchor_txid, txns.block_hash AS anchor_block_hash,
    utxos.outpoint AS anchor_outpoint
FROM assets
JOIN genesis_info
    ON assets.asset_id = genesis_info.gen_asset_id
LEFT JOIN key_fam_info
    ON assets.asset_id = key_fam_info.gen_asset_id
JOIN internal_keys
    ON assets.script_key_id = internal_keys.key_id
JOIN managed_utxos utxos
    ON assets.anchor_utxo_id = utxos.utxo_id AND
        (length(hex($1)) == 0 OR utxos.outpoint = $1)
JOIN chain_txns txns
    ON utxos.txn_id = txns.txn_id
WHERE (
    assets.amount >= COALESCE($2, assets.amount)
)
`

type QueryAssetsParams struct {
	AnchorPoint   interface{}
	MinAmt        sql.NullInt64
	AssetIDFilter interface{}
	KeyFamFilter  interface{}
}

type QueryAssetsRow struct {
	AssetID            int32
	Version            int32
	ScriptKeyRaw       []byte
	ScriptKeyTweak     []byte
	ScriptKeyFam       int32
	ScriptKeyIndex     int32
	GenesisSig         []byte
	TweakedFamKey      []byte
	FamKeyRaw          []byte
	FamKeyFamily       sql.NullInt32
	FamKeyIndex        sql.NullInt32
	ScriptVersion      int32
	Amount             int64
	LockTime           sql.NullInt32
	RelativeLockTime   sql.NullInt32
	AssetID_2          []byte
	AssetTag           string
	MetaData           []byte
	GenesisOutputIndex int32
	AssetType          int16
	GenesisPrevOut     []byte
	AnchorTx           []byte
	AnchorTxid         []byte
	AnchorBlockHash    []byte
	AnchorOutpoint     []byte
}

// We use a LEFT JOIN here as not every asset has a family key, so this'll
// generate rows that have NULL values for the family key fields if an asset
// doesn't have a family key. See the comment in fetchAssetSprouts for a work
// around that needs to be used with this query until a sqlc bug is fixed.
// This clause is used to select specific assets for a asset ID, general
// channel balances, and also coin selection. We use the sqlc.narg feature to
// make the entire statement evaluate to true, if none of these extra args are
// specified.
func (q *Queries) QueryAssets(ctx context.Context, arg QueryAssetsParams) ([]QueryAssetsRow, error) {
	rows, err := q.db.QueryContext(ctx, queryAssets,
		arg.AnchorPoint,
		arg.MinAmt,
		arg.AssetIDFilter,
		arg.KeyFamFilter,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryAssetsRow
	for rows.Next() {
		var i QueryAssetsRow
		if err := rows.Scan(
			&i.AssetID,
			&i.Version,
			&i.ScriptKeyRaw,
			&i.ScriptKeyTweak,
			&i.ScriptKeyFam,
			&i.ScriptKeyIndex,
			&i.GenesisSig,
			&i.TweakedFamKey,
			&i.FamKeyRaw,
			&i.FamKeyFamily,
			&i.FamKeyIndex,
			&i.ScriptVersion,
			&i.Amount,
			&i.LockTime,
			&i.RelativeLockTime,
			&i.AssetID_2,
			&i.AssetTag,
			&i.MetaData,
			&i.GenesisOutputIndex,
			&i.AssetType,
			&i.GenesisPrevOut,
			&i.AnchorTx,
			&i.AnchorTxid,
			&i.AnchorBlockHash,
			&i.AnchorOutpoint,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBatchGenesisTx = `-- name: UpdateBatchGenesisTx :exec
WITH target_batch AS (
    SELECT batch_id
    FROM asset_minting_batches batches
    JOIN internal_keys keys
        ON batches.batch_id = keys.key_id
    WHERE keys.raw_key = ?
)
UPDATE asset_minting_batches
SET minting_tx_psbt = ?
WHERE batch_id in (SELECT batch_id FROM target_batch)
`

type UpdateBatchGenesisTxParams struct {
	RawKey        []byte
	MintingTxPsbt []byte
}

func (q *Queries) UpdateBatchGenesisTx(ctx context.Context, arg UpdateBatchGenesisTxParams) error {
	_, err := q.db.ExecContext(ctx, updateBatchGenesisTx, arg.RawKey, arg.MintingTxPsbt)
	return err
}

const updateMintingBatchState = `-- name: UpdateMintingBatchState :exec
WITH target_batch AS (
    -- This CTE is used to fetch the ID of a batch, based on the serialized
    -- internal key associated with the batch. This internal key is as the
    -- actual Taproot internal key to ultimately mint the batch. This pattern
    -- is used in several other queries.
    SELECT batch_id
    FROM asset_minting_batches batches
    JOIN internal_keys keys
        ON batches.batch_id = keys.key_id
    WHERE keys.raw_key = ?
)
UPDATE asset_minting_batches 
SET batch_state = ? 
WHERE batch_id in (SELECT batch_id FROM target_batch)
`

type UpdateMintingBatchStateParams struct {
	RawKey     []byte
	BatchState int16
}

func (q *Queries) UpdateMintingBatchState(ctx context.Context, arg UpdateMintingBatchStateParams) error {
	_, err := q.db.ExecContext(ctx, updateMintingBatchState, arg.RawKey, arg.BatchState)
	return err
}

const upsertAssetFamilyKey = `-- name: UpsertAssetFamilyKey :one
INSERT INTO asset_families (
    tweaked_fam_key, internal_key_id, genesis_point_id 
) VALUES (
    ?, ?, ?
) ON CONFLICT (tweaked_fam_key)
    -- This is not a NOP, update the genesis point ID in case it wasn't set
    -- before.
    DO UPDATE SET genesis_point_id = EXCLUDED.genesis_point_id
RETURNING family_id
`

type UpsertAssetFamilyKeyParams struct {
	TweakedFamKey  []byte
	InternalKeyID  int32
	GenesisPointID int32
}

func (q *Queries) UpsertAssetFamilyKey(ctx context.Context, arg UpsertAssetFamilyKeyParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, upsertAssetFamilyKey, arg.TweakedFamKey, arg.InternalKeyID, arg.GenesisPointID)
	var family_id int32
	err := row.Scan(&family_id)
	return family_id, err
}

const upsertAssetProof = `-- name: UpsertAssetProof :exec
WITH target_asset(asset_id) AS (
    SELECT asset_id
    FROM assets
    JOIN internal_keys keys
        ON keys.key_id = assets.script_key_id
    WHERE keys.raw_key = ?
)
INSERT INTO asset_proofs (
    asset_id, proof_file
) VALUES (
    (SELECT asset_id FROM target_asset), ?
) ON CONFLICT (asset_id)
    -- This is not a NOP, update the proof file in case it wasn't set before.
    DO UPDATE SET proof_file = EXCLUDED.proof_file
`

type UpsertAssetProofParams struct {
	RawKey    []byte
	ProofFile []byte
}

func (q *Queries) UpsertAssetProof(ctx context.Context, arg UpsertAssetProofParams) error {
	_, err := q.db.ExecContext(ctx, upsertAssetProof, arg.RawKey, arg.ProofFile)
	return err
}

const upsertChainTx = `-- name: UpsertChainTx :one
INSERT INTO chain_txns (
    txid, raw_tx, block_height, block_hash, tx_index
) VALUES (
    ?, ?, ?, ?,
    ?
) ON CONFLICT (txid)
    -- Not a NOP but instead update any nullable fields that aren't null in the
    -- args.
    DO UPDATE SET block_height = IFNULL(EXCLUDED.block_height, block_height),
                  block_hash = IFNULL(EXCLUDED.block_hash, block_hash),
                  tx_index = IFNULL(EXCLUDED.tx_index, tx_index)
RETURNING txn_id
`

type UpsertChainTxParams struct {
	Txid        []byte
	RawTx       []byte
	BlockHeight sql.NullInt32
	BlockHash   []byte
	TxIndex     sql.NullInt32
}

func (q *Queries) UpsertChainTx(ctx context.Context, arg UpsertChainTxParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, upsertChainTx,
		arg.Txid,
		arg.RawTx,
		arg.BlockHeight,
		arg.BlockHash,
		arg.TxIndex,
	)
	var txn_id int32
	err := row.Scan(&txn_id)
	return txn_id, err
}

const upsertGenesisPoint = `-- name: UpsertGenesisPoint :one
INSERT INTO genesis_points(
    prev_out
) VALUES (
    ?
) ON CONFLICT (prev_out)
    -- This is a NOP, prev_out is the unique field that caused the conflict.
    DO UPDATE SET prev_out = EXCLUDED.prev_out
RETURNING genesis_id
`

func (q *Queries) UpsertGenesisPoint(ctx context.Context, prevOut []byte) (int32, error) {
	row := q.db.QueryRowContext(ctx, upsertGenesisPoint, prevOut)
	var genesis_id int32
	err := row.Scan(&genesis_id)
	return genesis_id, err
}

const upsertInternalKey = `-- name: UpsertInternalKey :one
INSERT INTO internal_keys (
    raw_key, tweak, key_family, key_index
) VALUES (
    ?, ?, ?, ?
) ON CONFLICT (raw_key)
    -- This is a NOP, raw_key is the unique field that caused the conflict.
    DO UPDATE SET raw_key = EXCLUDED.raw_key
RETURNING key_id
`

type UpsertInternalKeyParams struct {
	RawKey    []byte
	Tweak     []byte
	KeyFamily int32
	KeyIndex  int32
}

func (q *Queries) UpsertInternalKey(ctx context.Context, arg UpsertInternalKeyParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, upsertInternalKey,
		arg.RawKey,
		arg.Tweak,
		arg.KeyFamily,
		arg.KeyIndex,
	)
	var key_id int32
	err := row.Scan(&key_id)
	return key_id, err
}

const upsertManagedUTXO = `-- name: UpsertManagedUTXO :one
WITH target_key(key_id) AS (
    SELECT key_id
    FROM internal_keys
    WHERE raw_key = ?
)
INSERT INTO managed_utxos (
    outpoint, amt_sats, internal_key_id, tapscript_sibling, taro_root, txn_id
) VALUES (
    ?, ?, (SELECT key_id FROM target_key), ?, ?, ?
) ON CONFLICT (outpoint)
   -- Not a NOP but instead update any nullable fields that aren't null in the
   -- args.
   DO UPDATE SET tapscript_sibling = IFNULL(EXCLUDED.tapscript_sibling, tapscript_sibling)
RETURNING utxo_id
`

type UpsertManagedUTXOParams struct {
	RawKey           []byte
	Outpoint         []byte
	AmtSats          int64
	TapscriptSibling []byte
	TaroRoot         []byte
	TxnID            int32
}

func (q *Queries) UpsertManagedUTXO(ctx context.Context, arg UpsertManagedUTXOParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, upsertManagedUTXO,
		arg.RawKey,
		arg.Outpoint,
		arg.AmtSats,
		arg.TapscriptSibling,
		arg.TaroRoot,
		arg.TxnID,
	)
	var utxo_id int32
	err := row.Scan(&utxo_id)
	return utxo_id, err
}
