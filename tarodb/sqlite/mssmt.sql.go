// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: mssmt.sql

package sqlite

import (
	"context"
)

const deleteNode = `-- name: DeleteNode :execrows
DELETE FROM mssmt_nodes WHERE hash_key=?
`

func (q *Queries) DeleteNode(ctx context.Context, hashKey []byte) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteNode, hashKey)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const fetchChildren = `-- name: FetchChildren :many
WITH RECURSIVE mssmt_branches_cte (
    hash_key, l_hash_key, r_hash_key, key, value, sum
)
AS (
    SELECT r.hash_key, r.l_hash_key, r.r_hash_key, r.key, r.value, r.sum
    FROM mssmt_nodes r
    WHERE r.hash_key=?
    UNION ALL
        SELECT n.hash_key, n.l_hash_key, n.r_hash_key, n.key, n.value, n.sum
        FROM mssmt_nodes n, mssmt_branches_cte b
        WHERE n.hash_key=b.l_hash_key OR n.hash_key=b.r_hash_key
    /*
    Limit the result set to 3 items. The first is always the root node, while
    the following 0, 1 or 2 nodes represent children of the root node. These
    children can either be the next level children, or one next level and one
    from the level after that. In the future we may use this limit to fetch
    entire subtrees too.
    */
    LIMIT 3
) SELECT hash_key, l_hash_key, r_hash_key, key, value, sum FROM mssmt_branches_cte
`

type FetchChildrenRow struct {
	HashKey  []byte
	LHashKey []byte
	RHashKey []byte
	Key      []byte
	Value    []byte
	Sum      int64
}

func (q *Queries) FetchChildren(ctx context.Context, hashKey []byte) ([]FetchChildrenRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchChildren, hashKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchChildrenRow
	for rows.Next() {
		var i FetchChildrenRow
		if err := rows.Scan(
			&i.HashKey,
			&i.LHashKey,
			&i.RHashKey,
			&i.Key,
			&i.Value,
			&i.Sum,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChildrenSelfJoin = `-- name: FetchChildrenSelfJoin :many
WITH subtree AS (
  SELECT hash_key, l_hash_key, r_hash_key, key, value, sum FROM mssmt_nodes r
  WHERE r.hash_key=?
  UNION ALL
    SELECT c.hash_key, c.l_hash_key, c.r_hash_key, c.key, c.value, c.sum FROM mssmt_nodes c
    INNER JOIN subtree r ON r.l_hash_key=c.hash_key OR r.r_hash_key=c.hash_key
) SELECT hash_key, l_hash_key, r_hash_key, key, value, sum from subtree LIMIT 3
`

type FetchChildrenSelfJoinRow struct {
	HashKey  []byte
	LHashKey []byte
	RHashKey []byte
	Key      []byte
	Value    []byte
	Sum      int64
}

func (q *Queries) FetchChildrenSelfJoin(ctx context.Context, hashKey []byte) ([]FetchChildrenSelfJoinRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchChildrenSelfJoin, hashKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchChildrenSelfJoinRow
	for rows.Next() {
		var i FetchChildrenSelfJoinRow
		if err := rows.Scan(
			&i.HashKey,
			&i.LHashKey,
			&i.RHashKey,
			&i.Key,
			&i.Value,
			&i.Sum,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertBranch = `-- name: InsertBranch :exec
INSERT INTO mssmt_nodes (
    hash_key, l_hash_key, r_hash_key, key, value, sum 
) VALUES (?, ?, ?, NULL, NULL, ?)
`

type InsertBranchParams struct {
	HashKey  []byte
	LHashKey []byte
	RHashKey []byte
	Sum      int64
}

func (q *Queries) InsertBranch(ctx context.Context, arg InsertBranchParams) error {
	_, err := q.db.ExecContext(ctx, insertBranch,
		arg.HashKey,
		arg.LHashKey,
		arg.RHashKey,
		arg.Sum,
	)
	return err
}

const insertCompactedLeaf = `-- name: InsertCompactedLeaf :exec
INSERT INTO mssmt_nodes (
    hash_key, l_hash_key, r_hash_key, key, value, sum 
) VALUES (?, NULL, NULL, ?, ?, ?)
`

type InsertCompactedLeafParams struct {
	HashKey []byte
	Key     []byte
	Value   []byte
	Sum     int64
}

func (q *Queries) InsertCompactedLeaf(ctx context.Context, arg InsertCompactedLeafParams) error {
	_, err := q.db.ExecContext(ctx, insertCompactedLeaf,
		arg.HashKey,
		arg.Key,
		arg.Value,
		arg.Sum,
	)
	return err
}

const insertLeaf = `-- name: InsertLeaf :exec
INSERT INTO mssmt_nodes (
    hash_key, l_hash_key, r_hash_key, key, value, sum 
) VALUES (?, NULL, NULL, NULL, ?, ?)
`

type InsertLeafParams struct {
	HashKey []byte
	Value   []byte
	Sum     int64
}

func (q *Queries) InsertLeaf(ctx context.Context, arg InsertLeafParams) error {
	_, err := q.db.ExecContext(ctx, insertLeaf, arg.HashKey, arg.Value, arg.Sum)
	return err
}
