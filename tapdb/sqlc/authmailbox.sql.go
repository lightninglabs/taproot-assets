// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: authmailbox.sql

package sqlc

import (
	"context"
	"database/sql"
)

const ContainsTxProof = `-- name: ContainsTxProof :one
SELECT EXISTS (
    SELECT 1
    FROM tx_proof_claimed_outpoints
    WHERE outpoint = $1
)
`

func (q *Queries) ContainsTxProof(ctx context.Context, outpoint []byte) (bool, error) {
	row := q.db.QueryRowContext(ctx, ContainsTxProof, outpoint)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const CountAuthMailboxMessages = `-- name: CountAuthMailboxMessages :one
SELECT COUNT(*) AS count
FROM authmailbox_messages m
`

func (q *Queries) CountAuthMailboxMessages(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountAuthMailboxMessages)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const FetchAuthMailboxMessage = `-- name: FetchAuthMailboxMessage :one
SELECT 
    m.id,
    m.claimed_outpoint,
    m.receiver_key,
    m.encrypted_payload,
    m.arrival_timestamp,
    m.expiry_block_height,
    op.block_height
FROM authmailbox_messages m
JOIN tx_proof_claimed_outpoints op
    ON m.claimed_outpoint = op.outpoint
WHERE id = $1
`

type FetchAuthMailboxMessageRow struct {
	ID                int64
	ClaimedOutpoint   []byte
	ReceiverKey       []byte
	EncryptedPayload  []byte
	ArrivalTimestamp  int64
	ExpiryBlockHeight sql.NullInt32
	BlockHeight       int32
}

func (q *Queries) FetchAuthMailboxMessage(ctx context.Context, id int64) (FetchAuthMailboxMessageRow, error) {
	row := q.db.QueryRowContext(ctx, FetchAuthMailboxMessage, id)
	var i FetchAuthMailboxMessageRow
	err := row.Scan(
		&i.ID,
		&i.ClaimedOutpoint,
		&i.ReceiverKey,
		&i.EncryptedPayload,
		&i.ArrivalTimestamp,
		&i.ExpiryBlockHeight,
		&i.BlockHeight,
	)
	return i, err
}

const FetchAuthMailboxMessageByOutpoint = `-- name: FetchAuthMailboxMessageByOutpoint :one
SELECT
    m.id,
    m.claimed_outpoint,
    m.receiver_key,
    m.encrypted_payload,
    m.arrival_timestamp,
    m.expiry_block_height,
    op.block_height
FROM authmailbox_messages m
JOIN tx_proof_claimed_outpoints op
    ON m.claimed_outpoint = op.outpoint
WHERE m.claimed_outpoint = $1
`

type FetchAuthMailboxMessageByOutpointRow struct {
	ID                int64
	ClaimedOutpoint   []byte
	ReceiverKey       []byte
	EncryptedPayload  []byte
	ArrivalTimestamp  int64
	ExpiryBlockHeight sql.NullInt32
	BlockHeight       int32
}

func (q *Queries) FetchAuthMailboxMessageByOutpoint(ctx context.Context, claimedOutpoint []byte) (FetchAuthMailboxMessageByOutpointRow, error) {
	row := q.db.QueryRowContext(ctx, FetchAuthMailboxMessageByOutpoint, claimedOutpoint)
	var i FetchAuthMailboxMessageByOutpointRow
	err := row.Scan(
		&i.ID,
		&i.ClaimedOutpoint,
		&i.ReceiverKey,
		&i.EncryptedPayload,
		&i.ArrivalTimestamp,
		&i.ExpiryBlockHeight,
		&i.BlockHeight,
	)
	return i, err
}

const InsertAuthMailboxMessage = `-- name: InsertAuthMailboxMessage :one
INSERT INTO authmailbox_messages (
    claimed_outpoint, receiver_key, encrypted_payload, arrival_timestamp,
                                  expiry_block_height
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id
`

type InsertAuthMailboxMessageParams struct {
	ClaimedOutpoint   []byte
	ReceiverKey       []byte
	EncryptedPayload  []byte
	ArrivalTimestamp  int64
	ExpiryBlockHeight sql.NullInt32
}

func (q *Queries) InsertAuthMailboxMessage(ctx context.Context, arg InsertAuthMailboxMessageParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, InsertAuthMailboxMessage,
		arg.ClaimedOutpoint,
		arg.ReceiverKey,
		arg.EncryptedPayload,
		arg.ArrivalTimestamp,
		arg.ExpiryBlockHeight,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const InsertTxProof = `-- name: InsertTxProof :exec
INSERT INTO tx_proof_claimed_outpoints (
    outpoint, block_hash, block_height, internal_key, merkle_root
) VALUES (
    $1, $2, $3, $4, $5
)
`

type InsertTxProofParams struct {
	Outpoint    []byte
	BlockHash   []byte
	BlockHeight int32
	InternalKey []byte
	MerkleRoot  []byte
}

func (q *Queries) InsertTxProof(ctx context.Context, arg InsertTxProofParams) error {
	_, err := q.db.ExecContext(ctx, InsertTxProof,
		arg.Outpoint,
		arg.BlockHash,
		arg.BlockHeight,
		arg.InternalKey,
		arg.MerkleRoot,
	)
	return err
}

const QueryAuthMailboxMessages = `-- name: QueryAuthMailboxMessages :many
SELECT
    m.id,
    m.claimed_outpoint,
    m.receiver_key,
    m.encrypted_payload,
    m.arrival_timestamp,
    m.expiry_block_height,
    op.block_height
FROM authmailbox_messages m
JOIN tx_proof_claimed_outpoints op
    ON m.claimed_outpoint = op.outpoint
WHERE
    m.receiver_key = $1
    -- The after_time and after_id are exclusive, so we query greater than.
    AND (
        m.arrival_timestamp > $2
        OR $2 IS NULL
    )
    AND (
        m.id > $3
        OR $3 IS NULL
    )
    -- The start_block is inclusive, so we query greater than or equal.
    AND (
        op.block_height >= $4
        OR $4 IS NULL
    )
`

type QueryAuthMailboxMessagesParams struct {
	ReceiverKey []byte
	AfterTime   sql.NullInt64
	AfterID     sql.NullInt64
	StartBlock  sql.NullInt32
}

type QueryAuthMailboxMessagesRow struct {
	ID                int64
	ClaimedOutpoint   []byte
	ReceiverKey       []byte
	EncryptedPayload  []byte
	ArrivalTimestamp  int64
	ExpiryBlockHeight sql.NullInt32
	BlockHeight       int32
}

func (q *Queries) QueryAuthMailboxMessages(ctx context.Context, arg QueryAuthMailboxMessagesParams) ([]QueryAuthMailboxMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, QueryAuthMailboxMessages,
		arg.ReceiverKey,
		arg.AfterTime,
		arg.AfterID,
		arg.StartBlock,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryAuthMailboxMessagesRow
	for rows.Next() {
		var i QueryAuthMailboxMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ClaimedOutpoint,
			&i.ReceiverKey,
			&i.EncryptedPayload,
			&i.ArrivalTimestamp,
			&i.ExpiryBlockHeight,
			&i.BlockHeight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
