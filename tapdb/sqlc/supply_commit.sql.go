// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: supply_commit.sql

package sqlc

import (
	"context"
	"database/sql"
)

const DeleteSupplyCommitTransition = `-- name: DeleteSupplyCommitTransition :exec
DELETE FROM supply_commit_transitions
WHERE transition_id = $1
`

func (q *Queries) DeleteSupplyCommitTransition(ctx context.Context, transitionID int64) error {
	_, err := q.db.ExecContext(ctx, DeleteSupplyCommitTransition, transitionID)
	return err
}

const DeleteSupplyUpdateEvents = `-- name: DeleteSupplyUpdateEvents :exec
DELETE FROM supply_update_events
WHERE transition_id = $1
`

func (q *Queries) DeleteSupplyUpdateEvents(ctx context.Context, transitionID int64) error {
	_, err := q.db.ExecContext(ctx, DeleteSupplyUpdateEvents, transitionID)
	return err
}

const FetchChainTxByID = `-- name: FetchChainTxByID :one
SELECT raw_tx, block_height -- Include block_height needed by FetchState
FROM chain_txns
WHERE txn_id = $1
`

type FetchChainTxByIDRow struct {
	RawTx       []byte
	BlockHeight sql.NullInt32
}

func (q *Queries) FetchChainTxByID(ctx context.Context, txnID int64) (FetchChainTxByIDRow, error) {
	row := q.db.QueryRowContext(ctx, FetchChainTxByID, txnID)
	var i FetchChainTxByIDRow
	err := row.Scan(&i.RawTx, &i.BlockHeight)
	return i, err
}

const FetchInternalKeyByID = `-- name: FetchInternalKeyByID :one
SELECT raw_key, key_family, key_index
FROM internal_keys
WHERE key_id = $1
`

type FetchInternalKeyByIDRow struct {
	RawKey    []byte
	KeyFamily int32
	KeyIndex  int32
}

func (q *Queries) FetchInternalKeyByID(ctx context.Context, keyID int64) (FetchInternalKeyByIDRow, error) {
	row := q.db.QueryRowContext(ctx, FetchInternalKeyByID, keyID)
	var i FetchInternalKeyByIDRow
	err := row.Scan(&i.RawKey, &i.KeyFamily, &i.KeyIndex)
	return i, err
}

const FetchSupplyCommit = `-- name: FetchSupplyCommit :one
SELECT
    sc.commit_id,
    sc.output_index,
    sc.output_key,
    ik.raw_key AS internal_key,
    txn.raw_tx,
    sc.supply_root_hash AS root_hash,
    sc.supply_root_sum AS root_sum 
FROM supply_commit_state_machines sm
JOIN supply_commitments sc
    ON sm.latest_commitment_id = sc.commit_id
JOIN chain_txns txn
    ON sc.chain_txn_id = txn.txn_id
JOIN internal_keys ik
    ON sc.internal_key_id = ik.key_id
WHERE
    sm.group_key = $1 AND
    txn.block_hash IS NOT NULL
`

type FetchSupplyCommitRow struct {
	CommitID    int64
	OutputIndex sql.NullInt32
	OutputKey   []byte
	InternalKey []byte
	RawTx       []byte
	RootHash    []byte
	RootSum     sql.NullInt64
}

func (q *Queries) FetchSupplyCommit(ctx context.Context, groupKey []byte) (FetchSupplyCommitRow, error) {
	row := q.db.QueryRowContext(ctx, FetchSupplyCommit, groupKey)
	var i FetchSupplyCommitRow
	err := row.Scan(
		&i.CommitID,
		&i.OutputIndex,
		&i.OutputKey,
		&i.InternalKey,
		&i.RawTx,
		&i.RootHash,
		&i.RootSum,
	)
	return i, err
}

const FetchUnspentPrecommits = `-- name: FetchUnspentPrecommits :many
SELECT
    mac.tx_output_index,
    ik.raw_key AS taproot_internal_key,
    mac.group_key,
    mint_txn.block_height,
    mint_txn.raw_tx
FROM mint_anchor_uni_commitments mac
JOIN asset_minting_batches amb ON mac.batch_id = amb.batch_id
JOIN genesis_points gp ON amb.genesis_id = gp.genesis_id
JOIN chain_txns mint_txn ON gp.anchor_tx_id = mint_txn.txn_id
JOIN internal_keys ik ON mac.taproot_internal_key_id = ik.key_id
LEFT JOIN supply_commitments sc ON mac.spent_by = sc.commit_id
LEFT JOIN chain_txns commit_txn ON sc.chain_txn_id = commit_txn.txn_id
WHERE
    mac.group_key = $1 AND
    (mac.spent_by IS NULL OR commit_txn.block_hash IS NULL)
`

type FetchUnspentPrecommitsRow struct {
	TxOutputIndex      int32
	TaprootInternalKey []byte
	GroupKey           []byte
	BlockHeight        sql.NullInt32
	RawTx              []byte
}

func (q *Queries) FetchUnspentPrecommits(ctx context.Context, groupKey []byte) ([]FetchUnspentPrecommitsRow, error) {
	rows, err := q.db.QueryContext(ctx, FetchUnspentPrecommits, groupKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchUnspentPrecommitsRow
	for rows.Next() {
		var i FetchUnspentPrecommitsRow
		if err := rows.Scan(
			&i.TxOutputIndex,
			&i.TaprootInternalKey,
			&i.GroupKey,
			&i.BlockHeight,
			&i.RawTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const FinalizeSupplyCommitTransition = `-- name: FinalizeSupplyCommitTransition :exec
UPDATE supply_commit_transitions
SET finalized = TRUE
WHERE transition_id = $1
`

func (q *Queries) FinalizeSupplyCommitTransition(ctx context.Context, transitionID int64) error {
	_, err := q.db.ExecContext(ctx, FinalizeSupplyCommitTransition, transitionID)
	return err
}

const InsertSupplyCommitTransition = `-- name: InsertSupplyCommitTransition :one
INSERT INTO supply_commit_transitions (
    state_machine_group_key, old_commitment_id, new_commitment_id,
    pending_commit_txn_id, finalized, creation_time
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING transition_id
`

type InsertSupplyCommitTransitionParams struct {
	StateMachineGroupKey []byte
	OldCommitmentID      sql.NullInt64
	NewCommitmentID      sql.NullInt64
	PendingCommitTxnID   sql.NullInt64
	Finalized            bool
	CreationTime         int64
}

func (q *Queries) InsertSupplyCommitTransition(ctx context.Context, arg InsertSupplyCommitTransitionParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, InsertSupplyCommitTransition,
		arg.StateMachineGroupKey,
		arg.OldCommitmentID,
		arg.NewCommitmentID,
		arg.PendingCommitTxnID,
		arg.Finalized,
		arg.CreationTime,
	)
	var transition_id int64
	err := row.Scan(&transition_id)
	return transition_id, err
}

const InsertSupplyCommitment = `-- name: InsertSupplyCommitment :one
INSERT INTO supply_commitments (
    group_key, chain_txn_id,
    output_index, internal_key_id, output_key, -- Core fields
    block_height, block_header, merkle_proof, -- Nullable chain details
    supply_root_hash, supply_root_sum -- Nullable root details
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING commit_id
`

type InsertSupplyCommitmentParams struct {
	GroupKey       []byte
	ChainTxnID     int64
	OutputIndex    sql.NullInt32
	InternalKeyID  int64
	OutputKey      []byte
	BlockHeight    sql.NullInt32
	BlockHeader    []byte
	MerkleProof    []byte
	SupplyRootHash []byte
	SupplyRootSum  sql.NullInt64
}

func (q *Queries) InsertSupplyCommitment(ctx context.Context, arg InsertSupplyCommitmentParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, InsertSupplyCommitment,
		arg.GroupKey,
		arg.ChainTxnID,
		arg.OutputIndex,
		arg.InternalKeyID,
		arg.OutputKey,
		arg.BlockHeight,
		arg.BlockHeader,
		arg.MerkleProof,
		arg.SupplyRootHash,
		arg.SupplyRootSum,
	)
	var commit_id int64
	err := row.Scan(&commit_id)
	return commit_id, err
}

const InsertSupplyUpdateEvent = `-- name: InsertSupplyUpdateEvent :exec
INSERT INTO supply_update_events (
    transition_id, update_type_id, event_data
) VALUES (
    $1, $2, $3
)
`

type InsertSupplyUpdateEventParams struct {
	TransitionID int64
	UpdateTypeID int32
	EventData    []byte
}

func (q *Queries) InsertSupplyUpdateEvent(ctx context.Context, arg InsertSupplyUpdateEventParams) error {
	_, err := q.db.ExecContext(ctx, InsertSupplyUpdateEvent, arg.TransitionID, arg.UpdateTypeID, arg.EventData)
	return err
}

const QueryExistingPendingTransition = `-- name: QueryExistingPendingTransition :one
SELECT transition_id
FROM supply_commit_transitions sct
WHERE sct.state_machine_group_key = $1 AND finalized = FALSE
LIMIT 1
`

// Find the ID of an existing non-finalized transition for the group key
func (q *Queries) QueryExistingPendingTransition(ctx context.Context, groupKey []byte) (int64, error) {
	row := q.db.QueryRowContext(ctx, QueryExistingPendingTransition, groupKey)
	var transition_id int64
	err := row.Scan(&transition_id)
	return transition_id, err
}

const QueryPendingSupplyCommitTransition = `-- name: QueryPendingSupplyCommitTransition :one
WITH target_machine AS (
    SELECT group_key
    FROM supply_commit_state_machines
    WHERE group_key = $1
)
SELECT
    t.transition_id,
    t.state_machine_group_key,
    t.old_commitment_id,
    t.new_commitment_id,
    t.pending_commit_txn_id,
    t.finalized,
    t.creation_time
FROM supply_commit_transitions t
JOIN target_machine tm
    ON t.state_machine_group_key = tm.group_key
WHERE t.finalized = FALSE
ORDER BY t.creation_time DESC
LIMIT 1
`

func (q *Queries) QueryPendingSupplyCommitTransition(ctx context.Context, groupKey []byte) (SupplyCommitTransition, error) {
	row := q.db.QueryRowContext(ctx, QueryPendingSupplyCommitTransition, groupKey)
	var i SupplyCommitTransition
	err := row.Scan(
		&i.TransitionID,
		&i.StateMachineGroupKey,
		&i.OldCommitmentID,
		&i.NewCommitmentID,
		&i.PendingCommitTxnID,
		&i.Finalized,
		&i.CreationTime,
	)
	return i, err
}

const QuerySupplyCommitStateMachine = `-- name: QuerySupplyCommitStateMachine :one
SELECT
    sm.group_key,
    sm.current_state_id,
    states.state_name,
    sm.latest_commitment_id
FROM supply_commit_state_machines sm
JOIN supply_commit_states states
    ON sm.current_state_id = states.id
WHERE sm.group_key = $1
`

type QuerySupplyCommitStateMachineRow struct {
	GroupKey           []byte
	CurrentStateID     int32
	StateName          string
	LatestCommitmentID sql.NullInt64
}

func (q *Queries) QuerySupplyCommitStateMachine(ctx context.Context, groupKey []byte) (QuerySupplyCommitStateMachineRow, error) {
	row := q.db.QueryRowContext(ctx, QuerySupplyCommitStateMachine, groupKey)
	var i QuerySupplyCommitStateMachineRow
	err := row.Scan(
		&i.GroupKey,
		&i.CurrentStateID,
		&i.StateName,
		&i.LatestCommitmentID,
	)
	return i, err
}

const QuerySupplyCommitment = `-- name: QuerySupplyCommitment :one
SELECT commit_id, group_key, chain_txn_id, output_index, internal_key_id, output_key, block_header, block_height, merkle_proof, supply_root_hash, supply_root_sum
FROM supply_commitments
WHERE commit_id = $1
`

func (q *Queries) QuerySupplyCommitment(ctx context.Context, commitID int64) (SupplyCommitment, error) {
	row := q.db.QueryRowContext(ctx, QuerySupplyCommitment, commitID)
	var i SupplyCommitment
	err := row.Scan(
		&i.CommitID,
		&i.GroupKey,
		&i.ChainTxnID,
		&i.OutputIndex,
		&i.InternalKeyID,
		&i.OutputKey,
		&i.BlockHeader,
		&i.BlockHeight,
		&i.MerkleProof,
		&i.SupplyRootHash,
		&i.SupplyRootSum,
	)
	return i, err
}

const QuerySupplyUpdateEvents = `-- name: QuerySupplyUpdateEvents :many
SELECT
    ue.event_id,
    ue.transition_id,
    ue.update_type_id,
    types.update_type_name,
    ue.event_data
FROM supply_update_events ue
JOIN supply_commit_update_types types
    ON ue.update_type_id = types.id
WHERE ue.transition_id = $1
ORDER BY ue.event_id ASC
`

type QuerySupplyUpdateEventsRow struct {
	EventID        int64
	TransitionID   int64
	UpdateTypeID   int32
	UpdateTypeName string
	EventData      []byte
}

func (q *Queries) QuerySupplyUpdateEvents(ctx context.Context, transitionID int64) ([]QuerySupplyUpdateEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, QuerySupplyUpdateEvents, transitionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QuerySupplyUpdateEventsRow
	for rows.Next() {
		var i QuerySupplyUpdateEventsRow
		if err := rows.Scan(
			&i.EventID,
			&i.TransitionID,
			&i.UpdateTypeID,
			&i.UpdateTypeName,
			&i.EventData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateSupplyCommitTransitionCommitment = `-- name: UpdateSupplyCommitTransitionCommitment :exec
UPDATE supply_commit_transitions
SET new_commitment_id = $1,
    pending_commit_txn_id = $2
WHERE transition_id = $3
`

type UpdateSupplyCommitTransitionCommitmentParams struct {
	NewCommitmentID    sql.NullInt64
	PendingCommitTxnID sql.NullInt64
	TransitionID       int64
}

func (q *Queries) UpdateSupplyCommitTransitionCommitment(ctx context.Context, arg UpdateSupplyCommitTransitionCommitmentParams) error {
	_, err := q.db.ExecContext(ctx, UpdateSupplyCommitTransitionCommitment, arg.NewCommitmentID, arg.PendingCommitTxnID, arg.TransitionID)
	return err
}

const UpdateSupplyCommitmentChainDetails = `-- name: UpdateSupplyCommitmentChainDetails :exec
UPDATE supply_commitments
SET merkle_proof = $1,
    output_index = $2,
    block_header = $3,
    chain_txn_id = $4,
    block_height = $5
WHERE commit_id = $6
`

type UpdateSupplyCommitmentChainDetailsParams struct {
	MerkleProof []byte
	OutputIndex sql.NullInt32
	BlockHeader []byte
	ChainTxnID  int64
	BlockHeight sql.NullInt32
	CommitID    int64
}

func (q *Queries) UpdateSupplyCommitmentChainDetails(ctx context.Context, arg UpdateSupplyCommitmentChainDetailsParams) error {
	_, err := q.db.ExecContext(ctx, UpdateSupplyCommitmentChainDetails,
		arg.MerkleProof,
		arg.OutputIndex,
		arg.BlockHeader,
		arg.ChainTxnID,
		arg.BlockHeight,
		arg.CommitID,
	)
	return err
}

const UpdateSupplyCommitmentRoot = `-- name: UpdateSupplyCommitmentRoot :exec
UPDATE supply_commitments
SET supply_root_hash = $1,
    supply_root_sum = $2
WHERE commit_id = $3
`

type UpdateSupplyCommitmentRootParams struct {
	SupplyRootHash []byte
	SupplyRootSum  sql.NullInt64
	CommitID       int64
}

func (q *Queries) UpdateSupplyCommitmentRoot(ctx context.Context, arg UpdateSupplyCommitmentRootParams) error {
	_, err := q.db.ExecContext(ctx, UpdateSupplyCommitmentRoot, arg.SupplyRootHash, arg.SupplyRootSum, arg.CommitID)
	return err
}

const UpsertSupplyCommitStateMachine = `-- name: UpsertSupplyCommitStateMachine :one
WITH target_state AS (
    -- Select the ID for the provided state name, if it exists.
    SELECT id
    FROM supply_commit_states s1
    WHERE s1.state_name = $3
), default_state AS (
    -- Select the ID for the 'DefaultState'.
    SELECT id
    FROM supply_commit_states s2
    WHERE s2.state_name = 'DefaultState'
)
INSERT INTO supply_commit_state_machines (
    group_key, current_state_id, latest_commitment_id
) VALUES (
    $1,
    -- Use the target state ID if found, otherwise use the default state ID.
    coalesce((SELECT id FROM target_state), (SELECT id FROM default_state)),
    $2
)
ON CONFLICT (group_key)
DO UPDATE SET
    -- Update state ID only if a target state ID was found, otherwise keep existing.
    current_state_id = coalesce((SELECT id FROM target_state), supply_commit_state_machines.current_state_id),
    latest_commitment_id = coalesce($2, supply_commit_state_machines.latest_commitment_id)
RETURNING current_state_id, latest_commitment_id
`

type UpsertSupplyCommitStateMachineParams struct {
	GroupKey           []byte
	LatestCommitmentID sql.NullInt64
	StateName          sql.NullString
}

type UpsertSupplyCommitStateMachineRow struct {
	CurrentStateID     int32
	LatestCommitmentID sql.NullInt64
}

// Return the ID of the state that was actually set (either inserted or updated),
// and the latest commitment ID that was set.
func (q *Queries) UpsertSupplyCommitStateMachine(ctx context.Context, arg UpsertSupplyCommitStateMachineParams) (UpsertSupplyCommitStateMachineRow, error) {
	row := q.db.QueryRowContext(ctx, UpsertSupplyCommitStateMachine, arg.GroupKey, arg.LatestCommitmentID, arg.StateName)
	var i UpsertSupplyCommitStateMachineRow
	err := row.Scan(&i.CurrentStateID, &i.LatestCommitmentID)
	return i, err
}
