// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.21.0
// source: mssmt.sql

package sqlc

import (
	"context"
)

const deleteAllNodes = `-- name: DeleteAllNodes :execrows
DELETE FROM mssmt_nodes WHERE namespace = $1
`

func (q *Queries) DeleteAllNodes(ctx context.Context, namespace string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteAllNodes, namespace)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteNode = `-- name: DeleteNode :execrows
DELETE FROM mssmt_nodes WHERE hash_key = $1 AND namespace = $2
`

type DeleteNodeParams struct {
	HashKey   []byte
	Namespace string
}

func (q *Queries) DeleteNode(ctx context.Context, arg DeleteNodeParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteNode, arg.HashKey, arg.Namespace)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteRoot = `-- name: DeleteRoot :execrows
DELETE FROM mssmt_roots WHERE namespace = $1
`

func (q *Queries) DeleteRoot(ctx context.Context, namespace string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteRoot, namespace)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const fetchAllNodes = `-- name: FetchAllNodes :many
SELECT hash_key, l_hash_key, r_hash_key, key, value, sum, namespace FROM mssmt_nodes
`

func (q *Queries) FetchAllNodes(ctx context.Context) ([]MssmtNode, error) {
	rows, err := q.db.QueryContext(ctx, fetchAllNodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MssmtNode
	for rows.Next() {
		var i MssmtNode
		if err := rows.Scan(
			&i.HashKey,
			&i.LHashKey,
			&i.RHashKey,
			&i.Key,
			&i.Value,
			&i.Sum,
			&i.Namespace,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChildren = `-- name: FetchChildren :many
WITH RECURSIVE mssmt_branches_cte (
    hash_key, l_hash_key, r_hash_key, key, value, sum, namespace, depth
)
AS (
    SELECT r.hash_key, r.l_hash_key, r.r_hash_key, r.key, r.value, r.sum, r.namespace, 0 as depth
    FROM mssmt_nodes r
    WHERE r.hash_key = $1 AND r.namespace = $2
    UNION ALL
        SELECT n.hash_key, n.l_hash_key, n.r_hash_key, n.key, n.value, n.sum, n.namespace, depth+1
        FROM mssmt_nodes n, mssmt_branches_cte b
        WHERE n.namespace=b.namespace AND (n.hash_key=b.l_hash_key OR n.hash_key=b.r_hash_key)
    /*
    Limit the result set to 3 items. The first is always the root node, while
    the following 0, 1 or 2 nodes represent children of the root node. These
    children can either be the next level children, or one next level and one
    from the level after that. In the future we may use this limit to fetch
    entire subtrees too.
    */
) SELECT hash_key, l_hash_key, r_hash_key, key, value, sum, namespace, depth FROM mssmt_branches_cte WHERE depth < 3
`

type FetchChildrenParams struct {
	HashKey   []byte
	Namespace string
}

type FetchChildrenRow struct {
	HashKey   []byte
	LHashKey  []byte
	RHashKey  []byte
	Key       []byte
	Value     []byte
	Sum       int64
	Namespace string
	Depth     int32
}

func (q *Queries) FetchChildren(ctx context.Context, arg FetchChildrenParams) ([]FetchChildrenRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchChildren, arg.HashKey, arg.Namespace)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchChildrenRow
	for rows.Next() {
		var i FetchChildrenRow
		if err := rows.Scan(
			&i.HashKey,
			&i.LHashKey,
			&i.RHashKey,
			&i.Key,
			&i.Value,
			&i.Sum,
			&i.Namespace,
			&i.Depth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChildrenSelfJoin = `-- name: FetchChildrenSelfJoin :many
WITH subtree_cte (
    hash_key, l_hash_key, r_hash_key, key, value, sum, namespace, depth
) AS (
  SELECT r.hash_key, r.l_hash_key, r.r_hash_key, r.key, r.value, r.sum, r.namespace, 0 as depth
  FROM mssmt_nodes r
  WHERE r.hash_key = $1 AND r.namespace = $2
  UNION ALL
    SELECT c.hash_key, c.l_hash_key, c.r_hash_key, c.key, c.value, c.sum, c.namespace, depth+1
    FROM mssmt_nodes c
    INNER JOIN subtree_cte r ON r.l_hash_key=c.hash_key OR r.r_hash_key=c.hash_key
) SELECT hash_key, l_hash_key, r_hash_key, key, value, sum, namespace, depth from subtree_cte WHERE depth < 3
`

type FetchChildrenSelfJoinParams struct {
	HashKey   []byte
	Namespace string
}

type FetchChildrenSelfJoinRow struct {
	HashKey   []byte
	LHashKey  []byte
	RHashKey  []byte
	Key       []byte
	Value     []byte
	Sum       int64
	Namespace string
	Depth     int32
}

func (q *Queries) FetchChildrenSelfJoin(ctx context.Context, arg FetchChildrenSelfJoinParams) ([]FetchChildrenSelfJoinRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchChildrenSelfJoin, arg.HashKey, arg.Namespace)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchChildrenSelfJoinRow
	for rows.Next() {
		var i FetchChildrenSelfJoinRow
		if err := rows.Scan(
			&i.HashKey,
			&i.LHashKey,
			&i.RHashKey,
			&i.Key,
			&i.Value,
			&i.Sum,
			&i.Namespace,
			&i.Depth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchRootNode = `-- name: FetchRootNode :one
SELECT nodes.hash_key, nodes.l_hash_key, nodes.r_hash_key, nodes.key, nodes.value, nodes.sum, nodes.namespace
FROM mssmt_nodes nodes
JOIN mssmt_roots roots
    ON roots.root_hash = nodes.hash_key AND
        roots.namespace = $1
`

func (q *Queries) FetchRootNode(ctx context.Context, namespace string) (MssmtNode, error) {
	row := q.db.QueryRowContext(ctx, fetchRootNode, namespace)
	var i MssmtNode
	err := row.Scan(
		&i.HashKey,
		&i.LHashKey,
		&i.RHashKey,
		&i.Key,
		&i.Value,
		&i.Sum,
		&i.Namespace,
	)
	return i, err
}

const insertBranch = `-- name: InsertBranch :exec
INSERT INTO mssmt_nodes (
    hash_key, l_hash_key, r_hash_key, key, value, sum, namespace
) VALUES ($1, $2, $3, NULL, NULL, $4, $5)
`

type InsertBranchParams struct {
	HashKey   []byte
	LHashKey  []byte
	RHashKey  []byte
	Sum       int64
	Namespace string
}

func (q *Queries) InsertBranch(ctx context.Context, arg InsertBranchParams) error {
	_, err := q.db.ExecContext(ctx, insertBranch,
		arg.HashKey,
		arg.LHashKey,
		arg.RHashKey,
		arg.Sum,
		arg.Namespace,
	)
	return err
}

const insertCompactedLeaf = `-- name: InsertCompactedLeaf :exec
INSERT INTO mssmt_nodes (
    hash_key, l_hash_key, r_hash_key, key, value, sum, namespace
) VALUES ($1, NULL, NULL, $2, $3, $4, $5)
`

type InsertCompactedLeafParams struct {
	HashKey   []byte
	Key       []byte
	Value     []byte
	Sum       int64
	Namespace string
}

func (q *Queries) InsertCompactedLeaf(ctx context.Context, arg InsertCompactedLeafParams) error {
	_, err := q.db.ExecContext(ctx, insertCompactedLeaf,
		arg.HashKey,
		arg.Key,
		arg.Value,
		arg.Sum,
		arg.Namespace,
	)
	return err
}

const insertLeaf = `-- name: InsertLeaf :exec
INSERT INTO mssmt_nodes (
    hash_key, l_hash_key, r_hash_key, key, value, sum, namespace
) VALUES ($1, NULL, NULL, NULL, $2, $3, $4)
`

type InsertLeafParams struct {
	HashKey   []byte
	Value     []byte
	Sum       int64
	Namespace string
}

func (q *Queries) InsertLeaf(ctx context.Context, arg InsertLeafParams) error {
	_, err := q.db.ExecContext(ctx, insertLeaf,
		arg.HashKey,
		arg.Value,
		arg.Sum,
		arg.Namespace,
	)
	return err
}

const upsertRootNode = `-- name: UpsertRootNode :exec
INSERT INTO mssmt_roots (
    root_hash, namespace
) VALUES (
    $1, $2
) ON CONFLICT (namespace)
    -- Not a NOP, we always overwrite the root hash.
    DO UPDATE SET root_hash = EXCLUDED.root_hash
`

type UpsertRootNodeParams struct {
	RootHash  []byte
	Namespace string
}

func (q *Queries) UpsertRootNode(ctx context.Context, arg UpsertRootNodeParams) error {
	_, err := q.db.ExecContext(ctx, upsertRootNode, arg.RootHash, arg.Namespace)
	return err
}
