// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: addrs.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const FetchAddrEvent = `-- name: FetchAddrEvent :one
SELECT
    creation_time,
    status,
    chain_txns.txid as txid,
    chain_txns.block_height as confirmation_height,
    chain_txn_output_index as output_index,
    managed_utxos.amt_sats as amt_sats,
    managed_utxos.tapscript_sibling as tapscript_sibling,
    internal_keys.raw_key as internal_key,
    (SELECT count(*) FROM addr_event_proofs ap 
     WHERE ap.addr_event_id = addr_events.id) AS num_proofs
FROM addr_events
LEFT JOIN chain_txns
       ON addr_events.chain_txn_id = chain_txns.txn_id
LEFT JOIN managed_utxos
       ON addr_events.managed_utxo_id = managed_utxos.utxo_id
LEFT JOIN internal_keys
       ON managed_utxos.internal_key_id = internal_keys.key_id
WHERE addr_events.id = $1
`

type FetchAddrEventRow struct {
	CreationTime       time.Time
	Status             int16
	Txid               []byte
	ConfirmationHeight sql.NullInt32
	OutputIndex        int32
	AmtSats            sql.NullInt64
	TapscriptSibling   []byte
	InternalKey        []byte
	NumProofs          int64
}

func (q *Queries) FetchAddrEvent(ctx context.Context, id int64) (FetchAddrEventRow, error) {
	row := q.db.QueryRowContext(ctx, FetchAddrEvent, id)
	var i FetchAddrEventRow
	err := row.Scan(
		&i.CreationTime,
		&i.Status,
		&i.Txid,
		&i.ConfirmationHeight,
		&i.OutputIndex,
		&i.AmtSats,
		&i.TapscriptSibling,
		&i.InternalKey,
		&i.NumProofs,
	)
	return i, err
}

const FetchAddrEventByAddrKeyAndOutpoint = `-- name: FetchAddrEventByAddrKeyAndOutpoint :one
WITH target_addr(addr_id) AS (
    SELECT id
    FROM addrs
    WHERE addrs.taproot_output_key = $1
)
SELECT
    addr_events.id,
    creation_time,
    status,
    chain_txns.txid as txid,
    chain_txns.block_height as confirmation_height,
    chain_txn_output_index as output_index,
    managed_utxos.amt_sats as amt_sats,
    managed_utxos.tapscript_sibling as tapscript_sibling,
    internal_keys.raw_key as internal_key,
    (SELECT count(*) FROM addr_event_proofs ap
     WHERE ap.addr_event_id = addr_events.id) AS num_proofs
FROM addr_events
JOIN target_addr
  ON addr_events.addr_id = target_addr.addr_id
LEFT JOIN chain_txns
       ON addr_events.chain_txn_id = chain_txns.txn_id
LEFT JOIN managed_utxos
       ON addr_events.managed_utxo_id = managed_utxos.utxo_id
LEFT JOIN internal_keys
       ON managed_utxos.internal_key_id = internal_keys.key_id
WHERE chain_txns.txid = $2
  AND chain_txn_output_index = $3
`

type FetchAddrEventByAddrKeyAndOutpointParams struct {
	TaprootOutputKey    []byte
	Txid                []byte
	ChainTxnOutputIndex int32
}

type FetchAddrEventByAddrKeyAndOutpointRow struct {
	ID                 int64
	CreationTime       time.Time
	Status             int16
	Txid               []byte
	ConfirmationHeight sql.NullInt32
	OutputIndex        int32
	AmtSats            sql.NullInt64
	TapscriptSibling   []byte
	InternalKey        []byte
	NumProofs          int64
}

func (q *Queries) FetchAddrEventByAddrKeyAndOutpoint(ctx context.Context, arg FetchAddrEventByAddrKeyAndOutpointParams) (FetchAddrEventByAddrKeyAndOutpointRow, error) {
	row := q.db.QueryRowContext(ctx, FetchAddrEventByAddrKeyAndOutpoint, arg.TaprootOutputKey, arg.Txid, arg.ChainTxnOutputIndex)
	var i FetchAddrEventByAddrKeyAndOutpointRow
	err := row.Scan(
		&i.ID,
		&i.CreationTime,
		&i.Status,
		&i.Txid,
		&i.ConfirmationHeight,
		&i.OutputIndex,
		&i.AmtSats,
		&i.TapscriptSibling,
		&i.InternalKey,
		&i.NumProofs,
	)
	return i, err
}

const FetchAddrEventOutputs = `-- name: FetchAddrEventOutputs :many
SELECT
    addr_event_outputs.amount,
    addr_event_outputs.asset_id,
    addr_event_outputs.script_key_id,
    script_keys.script_key_id, script_keys.internal_key_id, script_keys.tweaked_script_key, script_keys.tweak, script_keys.key_type,
    internal_keys.key_id, internal_keys.raw_key, internal_keys.key_family, internal_keys.key_index
FROM addr_event_outputs
JOIN script_keys
    ON addr_event_outputs.script_key_id = script_keys.script_key_id
JOIN internal_keys
    ON script_keys.internal_key_id = internal_keys.key_id
WHERE addr_event_outputs.addr_event_id = $1
`

type FetchAddrEventOutputsRow struct {
	Amount      int64
	AssetID     []byte
	ScriptKeyID int64
	ScriptKey   ScriptKey
	InternalKey InternalKey
}

func (q *Queries) FetchAddrEventOutputs(ctx context.Context, addrEventID int64) ([]FetchAddrEventOutputsRow, error) {
	rows, err := q.db.QueryContext(ctx, FetchAddrEventOutputs, addrEventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchAddrEventOutputsRow
	for rows.Next() {
		var i FetchAddrEventOutputsRow
		if err := rows.Scan(
			&i.Amount,
			&i.AssetID,
			&i.ScriptKeyID,
			&i.ScriptKey.ScriptKeyID,
			&i.ScriptKey.InternalKeyID,
			&i.ScriptKey.TweakedScriptKey,
			&i.ScriptKey.Tweak,
			&i.ScriptKey.KeyType,
			&i.InternalKey.KeyID,
			&i.InternalKey.RawKey,
			&i.InternalKey.KeyFamily,
			&i.InternalKey.KeyIndex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const FetchAddrEventProofs = `-- name: FetchAddrEventProofs :many
SELECT
    addr_event_proofs.asset_proof_id,
    asset_proofs.proof_file
FROM addr_event_proofs
JOIN asset_proofs
    ON addr_event_proofs.asset_proof_id = asset_proofs.proof_id
WHERE addr_event_proofs.addr_event_id = $1
`

type FetchAddrEventProofsRow struct {
	AssetProofID int64
	ProofFile    []byte
}

func (q *Queries) FetchAddrEventProofs(ctx context.Context, addrEventID int64) ([]FetchAddrEventProofsRow, error) {
	rows, err := q.db.QueryContext(ctx, FetchAddrEventProofs, addrEventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchAddrEventProofsRow
	for rows.Next() {
		var i FetchAddrEventProofsRow
		if err := rows.Scan(&i.AssetProofID, &i.ProofFile); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const FetchAddrs = `-- name: FetchAddrs :many
SELECT 
    version, asset_version, genesis_asset_id, group_key, tapscript_sibling,
    taproot_output_key, amount, asset_type, creation_time, managed_from,
    proof_courier_addr,
    script_keys.script_key_id, script_keys.internal_key_id, script_keys.tweaked_script_key, script_keys.tweak, script_keys.key_type,
    raw_script_keys.key_id, raw_script_keys.raw_key, raw_script_keys.key_family, raw_script_keys.key_index,
    taproot_keys.raw_key AS raw_taproot_key, 
    taproot_keys.key_family AS taproot_key_family,
    taproot_keys.key_index AS taproot_key_index
FROM addrs
JOIN script_keys
    ON addrs.script_key_id = script_keys.script_key_id
JOIN internal_keys raw_script_keys
    ON script_keys.internal_key_id = raw_script_keys.key_id
JOIN internal_keys taproot_keys
    ON addrs.taproot_key_id = taproot_keys.key_id
WHERE creation_time >= $1
    AND creation_time <= $2
    AND ($3 = false OR
         (CASE WHEN managed_from IS NULL THEN true ELSE false END) = $3)
ORDER BY addrs.creation_time
LIMIT $5 OFFSET $4
`

type FetchAddrsParams struct {
	CreatedAfter  time.Time
	CreatedBefore time.Time
	UnmanagedOnly interface{}
	NumOffset     int32
	NumLimit      int32
}

type FetchAddrsRow struct {
	Version          int16
	AssetVersion     int16
	GenesisAssetID   int64
	GroupKey         []byte
	TapscriptSibling []byte
	TaprootOutputKey []byte
	Amount           int64
	AssetType        int16
	CreationTime     time.Time
	ManagedFrom      sql.NullTime
	ProofCourierAddr []byte
	ScriptKey        ScriptKey
	InternalKey      InternalKey
	RawTaprootKey    []byte
	TaprootKeyFamily int32
	TaprootKeyIndex  int32
}

func (q *Queries) FetchAddrs(ctx context.Context, arg FetchAddrsParams) ([]FetchAddrsRow, error) {
	rows, err := q.db.QueryContext(ctx, FetchAddrs,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.UnmanagedOnly,
		arg.NumOffset,
		arg.NumLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchAddrsRow
	for rows.Next() {
		var i FetchAddrsRow
		if err := rows.Scan(
			&i.Version,
			&i.AssetVersion,
			&i.GenesisAssetID,
			&i.GroupKey,
			&i.TapscriptSibling,
			&i.TaprootOutputKey,
			&i.Amount,
			&i.AssetType,
			&i.CreationTime,
			&i.ManagedFrom,
			&i.ProofCourierAddr,
			&i.ScriptKey.ScriptKeyID,
			&i.ScriptKey.InternalKeyID,
			&i.ScriptKey.TweakedScriptKey,
			&i.ScriptKey.Tweak,
			&i.ScriptKey.KeyType,
			&i.InternalKey.KeyID,
			&i.InternalKey.RawKey,
			&i.InternalKey.KeyFamily,
			&i.InternalKey.KeyIndex,
			&i.RawTaprootKey,
			&i.TaprootKeyFamily,
			&i.TaprootKeyIndex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const QueryAddr = `-- name: QueryAddr :one
SELECT
    addrs.id, addrs.version, addrs.asset_version, addrs.genesis_asset_id, addrs.group_key, addrs.script_key_id, addrs.taproot_key_id, addrs.tapscript_sibling, addrs.taproot_output_key, addrs.amount, addrs.asset_type, addrs.creation_time, addrs.managed_from, addrs.proof_courier_addr,
    script_keys.script_key_id, script_keys.internal_key_id, script_keys.tweaked_script_key, script_keys.tweak, script_keys.key_type,
    raw_script_keys.key_id, raw_script_keys.raw_key, raw_script_keys.key_family, raw_script_keys.key_index,
    taproot_keys.key_id, taproot_keys.raw_key, taproot_keys.key_family, taproot_keys.key_index
FROM addrs
JOIN script_keys
  ON addrs.script_key_id = script_keys.script_key_id
JOIN internal_keys raw_script_keys
  ON script_keys.internal_key_id = raw_script_keys.key_id
JOIN internal_keys taproot_keys
  ON addrs.taproot_key_id = taproot_keys.key_id
WHERE
    (addrs.taproot_output_key = $1 OR
      $1 IS NULL)
    AND (addrs.version = $2 OR
      $2 IS NULL)
    AND (substr(script_keys.tweaked_script_key, 2) = $3 OR
      $3 IS NULL)
`

type QueryAddrParams struct {
	TaprootOutputKey []byte
	Version          sql.NullInt16
	XOnlyScriptKey   []byte
}

type QueryAddrRow struct {
	Addr          Addr
	ScriptKey     ScriptKey
	InternalKey   InternalKey
	InternalKey_2 InternalKey
}

func (q *Queries) QueryAddr(ctx context.Context, arg QueryAddrParams) (QueryAddrRow, error) {
	row := q.db.QueryRowContext(ctx, QueryAddr, arg.TaprootOutputKey, arg.Version, arg.XOnlyScriptKey)
	var i QueryAddrRow
	err := row.Scan(
		&i.Addr.ID,
		&i.Addr.Version,
		&i.Addr.AssetVersion,
		&i.Addr.GenesisAssetID,
		&i.Addr.GroupKey,
		&i.Addr.ScriptKeyID,
		&i.Addr.TaprootKeyID,
		&i.Addr.TapscriptSibling,
		&i.Addr.TaprootOutputKey,
		&i.Addr.Amount,
		&i.Addr.AssetType,
		&i.Addr.CreationTime,
		&i.Addr.ManagedFrom,
		&i.Addr.ProofCourierAddr,
		&i.ScriptKey.ScriptKeyID,
		&i.ScriptKey.InternalKeyID,
		&i.ScriptKey.TweakedScriptKey,
		&i.ScriptKey.Tweak,
		&i.ScriptKey.KeyType,
		&i.InternalKey.KeyID,
		&i.InternalKey.RawKey,
		&i.InternalKey.KeyFamily,
		&i.InternalKey.KeyIndex,
		&i.InternalKey_2.KeyID,
		&i.InternalKey_2.RawKey,
		&i.InternalKey_2.KeyFamily,
		&i.InternalKey_2.KeyIndex,
	)
	return i, err
}

const QueryEventIDs = `-- name: QueryEventIDs :many
SELECT
    addr_events.id as event_id, addrs.taproot_output_key as taproot_output_key
FROM addr_events
JOIN addrs
  ON addr_events.addr_id = addrs.id
WHERE addr_events.status >= $1 
  AND addr_events.status <= $2
  AND COALESCE($3, addrs.taproot_output_key) = addrs.taproot_output_key
  AND addr_events.creation_time >= $4
ORDER by addr_events.creation_time
`

type QueryEventIDsParams struct {
	StatusFrom     int16
	StatusTo       int16
	AddrTaprootKey []byte
	CreatedAfter   time.Time
}

type QueryEventIDsRow struct {
	EventID          int64
	TaprootOutputKey []byte
}

func (q *Queries) QueryEventIDs(ctx context.Context, arg QueryEventIDsParams) ([]QueryEventIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, QueryEventIDs,
		arg.StatusFrom,
		arg.StatusTo,
		arg.AddrTaprootKey,
		arg.CreatedAfter,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryEventIDsRow
	for rows.Next() {
		var i QueryEventIDsRow
		if err := rows.Scan(&i.EventID, &i.TaprootOutputKey); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const QueryLastEventHeight = `-- name: QueryLastEventHeight :one
SELECT cast(coalesce(max(chain_txns.block_height), 0) AS BIGINT) AS last_height
FROM addr_events
JOIN chain_txns
    ON addr_events.chain_txn_id = chain_txns.txn_id
JOIN addrs
    ON addr_events.addr_id = addrs.id
WHERE addrs.version = $1
`

func (q *Queries) QueryLastEventHeight(ctx context.Context, version int16) (int64, error) {
	row := q.db.QueryRowContext(ctx, QueryLastEventHeight, version)
	var last_height int64
	err := row.Scan(&last_height)
	return last_height, err
}

const SetAddrManaged = `-- name: SetAddrManaged :exec
WITH target_addr(addr_id) AS (
    SELECT id
    FROM addrs
    WHERE addrs.taproot_output_key = $1
)
UPDATE addrs
SET managed_from = $2
WHERE id = (SELECT addr_id FROM target_addr)
`

type SetAddrManagedParams struct {
	TaprootOutputKey []byte
	ManagedFrom      sql.NullTime
}

func (q *Queries) SetAddrManaged(ctx context.Context, arg SetAddrManagedParams) error {
	_, err := q.db.ExecContext(ctx, SetAddrManaged, arg.TaprootOutputKey, arg.ManagedFrom)
	return err
}

const UpsertAddr = `-- name: UpsertAddr :one
INSERT INTO addrs (
    version,
    asset_version,
    genesis_asset_id,
    group_key,
    script_key_id,
    taproot_key_id,
    tapscript_sibling,
    taproot_output_key,
    amount,
    asset_type,
    creation_time,
    proof_courier_addr
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) 
ON CONFLICT (taproot_output_key) DO UPDATE
SET
    -- If the WHERE clause below is true (exact match on all other fields,
    -- except for creation_time), we set taproot_output_key to its current
    -- conflicting value. This is a no-op in terms of data change but allows
    -- RETURNING id to work on the existing row.
    taproot_output_key = excluded.taproot_output_key
WHERE 
    addrs.version = excluded.version
    AND addrs.asset_version = excluded.asset_version
    AND addrs.genesis_asset_id = excluded.genesis_asset_id
    AND (
        (addrs.group_key IS NULL AND excluded.group_key IS NULL)
        OR addrs.group_key = excluded.group_key
    )
    AND addrs.script_key_id = excluded.script_key_id
    AND addrs.taproot_key_id = excluded.taproot_key_id
    AND (
        (addrs.tapscript_sibling IS NULL AND excluded.tapscript_sibling IS NULL)
        OR addrs.tapscript_sibling = excluded.tapscript_sibling
    )
    AND addrs.amount = excluded.amount
    AND addrs.asset_type = excluded.asset_type
    AND addrs.proof_courier_addr = excluded.proof_courier_addr
RETURNING id
`

type UpsertAddrParams struct {
	Version          int16
	AssetVersion     int16
	GenesisAssetID   int64
	GroupKey         []byte
	ScriptKeyID      int64
	TaprootKeyID     int64
	TapscriptSibling []byte
	TaprootOutputKey []byte
	Amount           int64
	AssetType        int16
	CreationTime     time.Time
	ProofCourierAddr []byte
}

func (q *Queries) UpsertAddr(ctx context.Context, arg UpsertAddrParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, UpsertAddr,
		arg.Version,
		arg.AssetVersion,
		arg.GenesisAssetID,
		arg.GroupKey,
		arg.ScriptKeyID,
		arg.TaprootKeyID,
		arg.TapscriptSibling,
		arg.TaprootOutputKey,
		arg.Amount,
		arg.AssetType,
		arg.CreationTime,
		arg.ProofCourierAddr,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const UpsertAddrEvent = `-- name: UpsertAddrEvent :one
WITH target_addr(addr_id) AS (
    SELECT id
    FROM addrs
    WHERE addrs.taproot_output_key = $1
), target_chain_txn(txn_id) AS (
    SELECT txn_id
    FROM chain_txns
    WHERE chain_txns.txid = $2
)
INSERT INTO addr_events (
    creation_time, addr_id, status, chain_txn_id, chain_txn_output_index,
    managed_utxo_id
) VALUES (
    $3, (SELECT addr_id FROM target_addr), $4,
    (SELECT txn_id FROM target_chain_txn), $5, $6
)
ON CONFLICT (addr_id, chain_txn_id, chain_txn_output_index)
    DO UPDATE SET status = EXCLUDED.status
RETURNING id
`

type UpsertAddrEventParams struct {
	TaprootOutputKey    []byte
	Txid                []byte
	CreationTime        time.Time
	Status              int16
	ChainTxnOutputIndex int32
	ManagedUtxoID       int64
}

func (q *Queries) UpsertAddrEvent(ctx context.Context, arg UpsertAddrEventParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, UpsertAddrEvent,
		arg.TaprootOutputKey,
		arg.Txid,
		arg.CreationTime,
		arg.Status,
		arg.ChainTxnOutputIndex,
		arg.ManagedUtxoID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const UpsertAddrEventOutput = `-- name: UpsertAddrEventOutput :one
INSERT INTO addr_event_outputs (
    addr_event_id, amount, asset_id, script_key_id
) VALUES (
    $1, $2, $3, $4
)
ON CONFLICT (addr_event_id, asset_id) DO UPDATE
SET
    -- We allow the amount and script key to be updated.
    amount = EXCLUDED.amount,
    script_key_id = EXCLUDED.script_key_id
RETURNING id
`

type UpsertAddrEventOutputParams struct {
	AddrEventID int64
	Amount      int64
	AssetID     []byte
	ScriptKeyID int64
}

func (q *Queries) UpsertAddrEventOutput(ctx context.Context, arg UpsertAddrEventOutputParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, UpsertAddrEventOutput,
		arg.AddrEventID,
		arg.Amount,
		arg.AssetID,
		arg.ScriptKeyID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const UpsertAddrEventProof = `-- name: UpsertAddrEventProof :one
INSERT INTO addr_event_proofs (
    addr_event_id, asset_proof_id, asset_id_fk
) VALUES (
    $1, $2, $3
)
ON CONFLICT (addr_event_id, asset_proof_id) DO UPDATE
SET
    -- We allow the asset_id_fk to be updated.
    asset_id_fk = EXCLUDED.asset_id_fk
RETURNING id
`

type UpsertAddrEventProofParams struct {
	AddrEventID  int64
	AssetProofID int64
	AssetIDFk    sql.NullInt64
}

func (q *Queries) UpsertAddrEventProof(ctx context.Context, arg UpsertAddrEventProofParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, UpsertAddrEventProof, arg.AddrEventID, arg.AssetProofID, arg.AssetIDFk)
	var id int64
	err := row.Scan(&id)
	return id, err
}
