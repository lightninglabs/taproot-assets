// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: assets.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const AllAssets = `-- name: AllAssets :many
SELECT asset_id, genesis_id, version, script_key_id, asset_group_witness_id, script_version, amount, lock_time, relative_lock_time, split_commitment_root_hash, split_commitment_root_value, anchor_utxo_id, spent 
FROM assets
`

func (q *Queries) AllAssets(ctx context.Context) ([]Asset, error) {
	rows, err := q.db.QueryContext(ctx, AllAssets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.GenesisID,
			&i.Version,
			&i.ScriptKeyID,
			&i.AssetGroupWitnessID,
			&i.ScriptVersion,
			&i.Amount,
			&i.LockTime,
			&i.RelativeLockTime,
			&i.SplitCommitmentRootHash,
			&i.SplitCommitmentRootValue,
			&i.AnchorUtxoID,
			&i.Spent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const AllInternalKeys = `-- name: AllInternalKeys :many
SELECT key_id, raw_key, key_family, key_index 
FROM internal_keys
`

func (q *Queries) AllInternalKeys(ctx context.Context) ([]InternalKey, error) {
	rows, err := q.db.QueryContext(ctx, AllInternalKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InternalKey
	for rows.Next() {
		var i InternalKey
		if err := rows.Scan(
			&i.KeyID,
			&i.RawKey,
			&i.KeyFamily,
			&i.KeyIndex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const AllMintingBatches = `-- name: AllMintingBatches :many
SELECT batch_id, batch_state, minting_tx_psbt, change_output_index, genesis_id, height_hint, creation_time_unix, tapscript_sibling, assets_output_index, universe_commitments, key_id, raw_key, key_family, key_index 
FROM asset_minting_batches
JOIN internal_keys 
ON asset_minting_batches.batch_id = internal_keys.key_id
`

type AllMintingBatchesRow struct {
	BatchID             int64
	BatchState          int16
	MintingTxPsbt       []byte
	ChangeOutputIndex   sql.NullInt32
	GenesisID           sql.NullInt64
	HeightHint          int32
	CreationTimeUnix    time.Time
	TapscriptSibling    []byte
	AssetsOutputIndex   sql.NullInt32
	UniverseCommitments bool
	KeyID               int64
	RawKey              []byte
	KeyFamily           int32
	KeyIndex            int32
}

func (q *Queries) AllMintingBatches(ctx context.Context) ([]AllMintingBatchesRow, error) {
	rows, err := q.db.QueryContext(ctx, AllMintingBatches)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AllMintingBatchesRow
	for rows.Next() {
		var i AllMintingBatchesRow
		if err := rows.Scan(
			&i.BatchID,
			&i.BatchState,
			&i.MintingTxPsbt,
			&i.ChangeOutputIndex,
			&i.GenesisID,
			&i.HeightHint,
			&i.CreationTimeUnix,
			&i.TapscriptSibling,
			&i.AssetsOutputIndex,
			&i.UniverseCommitments,
			&i.KeyID,
			&i.RawKey,
			&i.KeyFamily,
			&i.KeyIndex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const AnchorGenesisPoint = `-- name: AnchorGenesisPoint :exec
WITH target_point(genesis_id) AS (
    SELECT genesis_id
    FROM genesis_points
    WHERE genesis_points.prev_out = $1
)
UPDATE genesis_points
SET anchor_tx_id = $2
WHERE genesis_id in (SELECT genesis_id FROM target_point)
`

type AnchorGenesisPointParams struct {
	PrevOut    []byte
	AnchorTxID sql.NullInt64
}

func (q *Queries) AnchorGenesisPoint(ctx context.Context, arg AnchorGenesisPointParams) error {
	_, err := q.db.ExecContext(ctx, AnchorGenesisPoint, arg.PrevOut, arg.AnchorTxID)
	return err
}

const AnchorPendingAssets = `-- name: AnchorPendingAssets :exec
WITH assets_to_update AS (
    SELECT script_key_id
    FROM assets 
    JOIN genesis_assets 
        ON assets.genesis_id = genesis_assets.gen_asset_id
    JOIN genesis_points
        ON genesis_points.genesis_id = genesis_assets.genesis_point_id
    WHERE prev_out = $1
)
UPDATE assets
SET anchor_utxo_id = $2
WHERE script_key_id in (SELECT script_key_id FROM assets_to_update)
`

type AnchorPendingAssetsParams struct {
	PrevOut      []byte
	AnchorUtxoID sql.NullInt64
}

func (q *Queries) AnchorPendingAssets(ctx context.Context, arg AnchorPendingAssetsParams) error {
	_, err := q.db.ExecContext(ctx, AnchorPendingAssets, arg.PrevOut, arg.AnchorUtxoID)
	return err
}

const AssetsByGenesisPoint = `-- name: AssetsByGenesisPoint :many
SELECT assets.asset_id, assets.genesis_id, version, script_key_id, asset_group_witness_id, script_version, amount, lock_time, relative_lock_time, split_commitment_root_hash, split_commitment_root_value, anchor_utxo_id, spent, gen_asset_id, genesis_assets.asset_id, asset_tag, meta_data_id, output_index, asset_type, genesis_point_id, genesis_points.genesis_id, prev_out, anchor_tx_id
FROM assets 
JOIN genesis_assets 
    ON assets.genesis_id = genesis_assets.gen_asset_id
JOIN genesis_points
    ON genesis_points.genesis_id = genesis_assets.genesis_point_id
WHERE prev_out = $1
`

type AssetsByGenesisPointRow struct {
	AssetID                  int64
	GenesisID                int64
	Version                  int32
	ScriptKeyID              int64
	AssetGroupWitnessID      sql.NullInt64
	ScriptVersion            int32
	Amount                   int64
	LockTime                 sql.NullInt32
	RelativeLockTime         sql.NullInt32
	SplitCommitmentRootHash  []byte
	SplitCommitmentRootValue sql.NullInt64
	AnchorUtxoID             sql.NullInt64
	Spent                    bool
	GenAssetID               int64
	AssetID_2                []byte
	AssetTag                 string
	MetaDataID               sql.NullInt64
	OutputIndex              int32
	AssetType                int16
	GenesisPointID           int64
	GenesisID_2              int64
	PrevOut                  []byte
	AnchorTxID               sql.NullInt64
}

func (q *Queries) AssetsByGenesisPoint(ctx context.Context, prevOut []byte) ([]AssetsByGenesisPointRow, error) {
	rows, err := q.db.QueryContext(ctx, AssetsByGenesisPoint, prevOut)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssetsByGenesisPointRow
	for rows.Next() {
		var i AssetsByGenesisPointRow
		if err := rows.Scan(
			&i.AssetID,
			&i.GenesisID,
			&i.Version,
			&i.ScriptKeyID,
			&i.AssetGroupWitnessID,
			&i.ScriptVersion,
			&i.Amount,
			&i.LockTime,
			&i.RelativeLockTime,
			&i.SplitCommitmentRootHash,
			&i.SplitCommitmentRootValue,
			&i.AnchorUtxoID,
			&i.Spent,
			&i.GenAssetID,
			&i.AssetID_2,
			&i.AssetTag,
			&i.MetaDataID,
			&i.OutputIndex,
			&i.AssetType,
			&i.GenesisPointID,
			&i.GenesisID_2,
			&i.PrevOut,
			&i.AnchorTxID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const AssetsInBatch = `-- name: AssetsInBatch :many
SELECT
    gen_asset_id, asset_id, asset_tag, assets_meta.meta_data_hash, 
    output_index, asset_type, genesis_points.prev_out prev_out
FROM genesis_assets
LEFT JOIN assets_meta
    ON genesis_assets.meta_data_id = assets_meta.meta_id
JOIN genesis_points
    ON genesis_assets.genesis_point_id = genesis_points.genesis_id
JOIN asset_minting_batches batches
    ON genesis_points.genesis_id = batches.genesis_id
JOIN internal_keys keys
    ON keys.key_id = batches.batch_id
WHERE keys.raw_key = $1
`

type AssetsInBatchRow struct {
	GenAssetID   int64
	AssetID      []byte
	AssetTag     string
	MetaDataHash []byte
	OutputIndex  int32
	AssetType    int16
	PrevOut      []byte
}

func (q *Queries) AssetsInBatch(ctx context.Context, rawKey []byte) ([]AssetsInBatchRow, error) {
	rows, err := q.db.QueryContext(ctx, AssetsInBatch, rawKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssetsInBatchRow
	for rows.Next() {
		var i AssetsInBatchRow
		if err := rows.Scan(
			&i.GenAssetID,
			&i.AssetID,
			&i.AssetTag,
			&i.MetaDataHash,
			&i.OutputIndex,
			&i.AssetType,
			&i.PrevOut,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const BindMintingBatchWithTapSibling = `-- name: BindMintingBatchWithTapSibling :exec
WITH target_batch AS (
    SELECT batch_id
    FROM asset_minting_batches batches
    JOIN internal_keys keys
        ON batches.batch_id = keys.key_id
    WHERE keys.raw_key = $1
)
UPDATE asset_minting_batches
SET tapscript_sibling = $2
WHERE batch_id IN (SELECT batch_id FROM target_batch)
`

type BindMintingBatchWithTapSiblingParams struct {
	RawKey           []byte
	TapscriptSibling []byte
}

func (q *Queries) BindMintingBatchWithTapSibling(ctx context.Context, arg BindMintingBatchWithTapSiblingParams) error {
	_, err := q.db.ExecContext(ctx, BindMintingBatchWithTapSibling, arg.RawKey, arg.TapscriptSibling)
	return err
}

const BindMintingBatchWithTx = `-- name: BindMintingBatchWithTx :one
WITH target_batch AS (
    SELECT batch_id
    FROM asset_minting_batches batches
    JOIN internal_keys keys
        ON batches.batch_id = keys.key_id
    WHERE keys.raw_key = $1
)
UPDATE asset_minting_batches
SET minting_tx_psbt = $2, change_output_index = $3, assets_output_index = $4,
    genesis_id = $5, universe_commitments = $6
WHERE batch_id IN (SELECT batch_id FROM target_batch)
RETURNING batch_id
`

type BindMintingBatchWithTxParams struct {
	RawKey              []byte
	MintingTxPsbt       []byte
	ChangeOutputIndex   sql.NullInt32
	AssetsOutputIndex   sql.NullInt32
	GenesisID           sql.NullInt64
	UniverseCommitments bool
}

func (q *Queries) BindMintingBatchWithTx(ctx context.Context, arg BindMintingBatchWithTxParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, BindMintingBatchWithTx,
		arg.RawKey,
		arg.MintingTxPsbt,
		arg.ChangeOutputIndex,
		arg.AssetsOutputIndex,
		arg.GenesisID,
		arg.UniverseCommitments,
	)
	var batch_id int64
	err := row.Scan(&batch_id)
	return batch_id, err
}

const ConfirmChainAnchorTx = `-- name: ConfirmChainAnchorTx :exec
UPDATE chain_txns
SET block_height = $2, block_hash = $3, tx_index = $4
WHERE txid = $1
`

type ConfirmChainAnchorTxParams struct {
	Txid        []byte
	BlockHeight sql.NullInt32
	BlockHash   []byte
	TxIndex     sql.NullInt32
}

func (q *Queries) ConfirmChainAnchorTx(ctx context.Context, arg ConfirmChainAnchorTxParams) error {
	_, err := q.db.ExecContext(ctx, ConfirmChainAnchorTx,
		arg.Txid,
		arg.BlockHeight,
		arg.BlockHash,
		arg.TxIndex,
	)
	return err
}

const ConfirmChainTx = `-- name: ConfirmChainTx :exec
WITH target_txn(txn_id) AS (
    SELECT anchor_tx_id
    FROM genesis_points points
    JOIN asset_minting_batches batches
        ON batches.genesis_id = points.genesis_id
    JOIN internal_keys keys
        ON batches.batch_id = keys.key_id
    WHERE keys.raw_key = $1
)
UPDATE chain_txns
SET block_height = $2, block_hash = $3, tx_index = $4
WHERE txn_id in (SELECT txn_id FROM target_txn)
`

type ConfirmChainTxParams struct {
	RawKey      []byte
	BlockHeight sql.NullInt32
	BlockHash   []byte
	TxIndex     sql.NullInt32
}

func (q *Queries) ConfirmChainTx(ctx context.Context, arg ConfirmChainTxParams) error {
	_, err := q.db.ExecContext(ctx, ConfirmChainTx,
		arg.RawKey,
		arg.BlockHeight,
		arg.BlockHash,
		arg.TxIndex,
	)
	return err
}

const DeleteExpiredUTXOLeases = `-- name: DeleteExpiredUTXOLeases :exec
UPDATE managed_utxos
SET lease_owner = NULL, lease_expiry = NULL
WHERE lease_owner IS NOT NULL AND
      lease_expiry IS NOT NULL AND
      lease_expiry < $1
`

func (q *Queries) DeleteExpiredUTXOLeases(ctx context.Context, now sql.NullTime) error {
	_, err := q.db.ExecContext(ctx, DeleteExpiredUTXOLeases, now)
	return err
}

const DeleteManagedUTXO = `-- name: DeleteManagedUTXO :exec
DELETE FROM managed_utxos
WHERE outpoint = $1
`

func (q *Queries) DeleteManagedUTXO(ctx context.Context, outpoint []byte) error {
	_, err := q.db.ExecContext(ctx, DeleteManagedUTXO, outpoint)
	return err
}

const DeleteTapscriptTreeEdges = `-- name: DeleteTapscriptTreeEdges :exec
WITH tree_info AS (
    -- This CTE is used to fetch all edges that link the given tapscript tree
    -- root hash to child nodes.
    SELECT tapscript_edges.edge_id
    FROM tapscript_edges
    JOIN tapscript_roots
        ON tapscript_edges.root_hash_id = tapscript_roots.root_id
    WHERE tapscript_roots.root_hash = $1
)
DELETE FROM tapscript_edges
WHERE edge_id IN (SELECT edge_id FROM tree_info)
`

func (q *Queries) DeleteTapscriptTreeEdges(ctx context.Context, rootHash []byte) error {
	_, err := q.db.ExecContext(ctx, DeleteTapscriptTreeEdges, rootHash)
	return err
}

const DeleteTapscriptTreeNodes = `-- name: DeleteTapscriptTreeNodes :exec
DELETE FROM tapscript_nodes
WHERE NOT EXISTS (
    SELECT 1
        FROM tapscript_edges
        -- Delete any node that is not referenced by any edge.
        WHERE tapscript_edges.raw_node_id = tapscript_nodes.node_id
)
`

func (q *Queries) DeleteTapscriptTreeNodes(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, DeleteTapscriptTreeNodes)
	return err
}

const DeleteTapscriptTreeRoot = `-- name: DeleteTapscriptTreeRoot :exec
DELETE FROM tapscript_roots
WHERE root_hash = $1
`

func (q *Queries) DeleteTapscriptTreeRoot(ctx context.Context, rootHash []byte) error {
	_, err := q.db.ExecContext(ctx, DeleteTapscriptTreeRoot, rootHash)
	return err
}

const DeleteUTXOLease = `-- name: DeleteUTXOLease :exec
UPDATE managed_utxos
SET lease_owner = NULL, lease_expiry = NULL
WHERE outpoint = $1
`

func (q *Queries) DeleteUTXOLease(ctx context.Context, outpoint []byte) error {
	_, err := q.db.ExecContext(ctx, DeleteUTXOLease, outpoint)
	return err
}

const FetchAssetID = `-- name: FetchAssetID :many
SELECT asset_id
    FROM assets
    JOIN script_keys 
        ON assets.script_key_id = script_keys.script_key_id
    JOIN managed_utxos utxos
        ON assets.anchor_utxo_id = utxos.utxo_id
    WHERE
        (script_keys.tweaked_script_key = $1
            OR $1 IS NULL)
        AND (utxos.outpoint = $2
            OR $2 IS NULL)
`

type FetchAssetIDParams struct {
	TweakedScriptKey []byte
	Outpoint         []byte
}

func (q *Queries) FetchAssetID(ctx context.Context, arg FetchAssetIDParams) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, FetchAssetID, arg.TweakedScriptKey, arg.Outpoint)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var asset_id int64
		if err := rows.Scan(&asset_id); err != nil {
			return nil, err
		}
		items = append(items, asset_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const FetchAssetMeta = `-- name: FetchAssetMeta :one
SELECT assets_meta.meta_id, assets_meta.meta_data_hash, assets_meta.meta_data_blob, assets_meta.meta_data_type, assets_meta.meta_decimal_display, assets_meta.meta_universe_commitments, assets_meta.meta_canonical_universes, assets_meta.meta_delegation_key
FROM assets_meta
WHERE meta_id = $1
`

type FetchAssetMetaRow struct {
	AssetsMetum AssetsMetum
}

func (q *Queries) FetchAssetMeta(ctx context.Context, metaID int64) (FetchAssetMetaRow, error) {
	row := q.db.QueryRowContext(ctx, FetchAssetMeta, metaID)
	var i FetchAssetMetaRow
	err := row.Scan(
		&i.AssetsMetum.MetaID,
		&i.AssetsMetum.MetaDataHash,
		&i.AssetsMetum.MetaDataBlob,
		&i.AssetsMetum.MetaDataType,
		&i.AssetsMetum.MetaDecimalDisplay,
		&i.AssetsMetum.MetaUniverseCommitments,
		&i.AssetsMetum.MetaCanonicalUniverses,
		&i.AssetsMetum.MetaDelegationKey,
	)
	return i, err
}

const FetchAssetMetaByHash = `-- name: FetchAssetMetaByHash :one
SELECT assets_meta.meta_id, assets_meta.meta_data_hash, assets_meta.meta_data_blob, assets_meta.meta_data_type, assets_meta.meta_decimal_display, assets_meta.meta_universe_commitments, assets_meta.meta_canonical_universes, assets_meta.meta_delegation_key
FROM assets_meta
WHERE meta_data_hash = $1
`

type FetchAssetMetaByHashRow struct {
	AssetsMetum AssetsMetum
}

func (q *Queries) FetchAssetMetaByHash(ctx context.Context, metaDataHash []byte) (FetchAssetMetaByHashRow, error) {
	row := q.db.QueryRowContext(ctx, FetchAssetMetaByHash, metaDataHash)
	var i FetchAssetMetaByHashRow
	err := row.Scan(
		&i.AssetsMetum.MetaID,
		&i.AssetsMetum.MetaDataHash,
		&i.AssetsMetum.MetaDataBlob,
		&i.AssetsMetum.MetaDataType,
		&i.AssetsMetum.MetaDecimalDisplay,
		&i.AssetsMetum.MetaUniverseCommitments,
		&i.AssetsMetum.MetaCanonicalUniverses,
		&i.AssetsMetum.MetaDelegationKey,
	)
	return i, err
}

const FetchAssetMetaForAsset = `-- name: FetchAssetMetaForAsset :one
SELECT assets_meta.meta_id, assets_meta.meta_data_hash, assets_meta.meta_data_blob, assets_meta.meta_data_type, assets_meta.meta_decimal_display, assets_meta.meta_universe_commitments, assets_meta.meta_canonical_universes, assets_meta.meta_delegation_key
FROM genesis_assets assets
JOIN assets_meta
    ON assets.meta_data_id = assets_meta.meta_id
WHERE assets.asset_id = $1
`

type FetchAssetMetaForAssetRow struct {
	AssetsMetum AssetsMetum
}

func (q *Queries) FetchAssetMetaForAsset(ctx context.Context, assetID []byte) (FetchAssetMetaForAssetRow, error) {
	row := q.db.QueryRowContext(ctx, FetchAssetMetaForAsset, assetID)
	var i FetchAssetMetaForAssetRow
	err := row.Scan(
		&i.AssetsMetum.MetaID,
		&i.AssetsMetum.MetaDataHash,
		&i.AssetsMetum.MetaDataBlob,
		&i.AssetsMetum.MetaDataType,
		&i.AssetsMetum.MetaDecimalDisplay,
		&i.AssetsMetum.MetaUniverseCommitments,
		&i.AssetsMetum.MetaCanonicalUniverses,
		&i.AssetsMetum.MetaDelegationKey,
	)
	return i, err
}

const FetchAssetProof = `-- name: FetchAssetProof :many
WITH asset_info AS (
    SELECT assets.asset_id, script_keys.tweaked_script_key, utxos.outpoint
    FROM assets
    JOIN script_keys
        ON assets.script_key_id = script_keys.script_key_id
    JOIN managed_utxos utxos
        ON assets.anchor_utxo_id = utxos.utxo_id
    JOIN genesis_assets
         ON assets.genesis_id = genesis_assets.gen_asset_id
   WHERE script_keys.tweaked_script_key = $1
     AND (utxos.outpoint = $2 OR $2 IS NULL)
     AND (genesis_assets.asset_id = $3 OR $3 IS NULL)
)
SELECT asset_info.tweaked_script_key AS script_key, asset_proofs.proof_file,
       asset_info.asset_id as asset_id, asset_proofs.proof_id as proof_id,
       asset_info.outpoint as outpoint
FROM asset_proofs
JOIN asset_info
  ON asset_info.asset_id = asset_proofs.asset_id
`

type FetchAssetProofParams struct {
	TweakedScriptKey []byte
	Outpoint         []byte
	AssetID          []byte
}

type FetchAssetProofRow struct {
	ScriptKey []byte
	ProofFile []byte
	AssetID   int64
	ProofID   int64
	Outpoint  []byte
}

func (q *Queries) FetchAssetProof(ctx context.Context, arg FetchAssetProofParams) ([]FetchAssetProofRow, error) {
	rows, err := q.db.QueryContext(ctx, FetchAssetProof, arg.TweakedScriptKey, arg.Outpoint, arg.AssetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchAssetProofRow
	for rows.Next() {
		var i FetchAssetProofRow
		if err := rows.Scan(
			&i.ScriptKey,
			&i.ProofFile,
			&i.AssetID,
			&i.ProofID,
			&i.Outpoint,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const FetchAssetProofs = `-- name: FetchAssetProofs :many
WITH asset_info AS (
    SELECT assets.asset_id, script_keys.tweaked_script_key
    FROM assets
    JOIN script_keys
        ON assets.script_key_id = script_keys.script_key_id
)
SELECT asset_info.tweaked_script_key AS script_key, asset_proofs.proof_file
FROM asset_proofs
JOIN asset_info
    ON asset_info.asset_id = asset_proofs.asset_id
`

type FetchAssetProofsRow struct {
	ScriptKey []byte
	ProofFile []byte
}

func (q *Queries) FetchAssetProofs(ctx context.Context) ([]FetchAssetProofsRow, error) {
	rows, err := q.db.QueryContext(ctx, FetchAssetProofs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchAssetProofsRow
	for rows.Next() {
		var i FetchAssetProofsRow
		if err := rows.Scan(&i.ScriptKey, &i.ProofFile); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const FetchAssetProofsByAssetID = `-- name: FetchAssetProofsByAssetID :many
WITH asset_info AS (
    SELECT assets.asset_id, script_keys.tweaked_script_key
    FROM assets
    JOIN script_keys
        ON assets.script_key_id = script_keys.script_key_id
    JOIN genesis_assets gen
        ON assets.genesis_id = gen.gen_asset_id
    WHERE gen.asset_id = $1
)
SELECT asset_info.tweaked_script_key AS script_key, asset_proofs.proof_file
FROM asset_proofs
JOIN asset_info
    ON asset_info.asset_id = asset_proofs.asset_id
`

type FetchAssetProofsByAssetIDRow struct {
	ScriptKey []byte
	ProofFile []byte
}

func (q *Queries) FetchAssetProofsByAssetID(ctx context.Context, assetID []byte) ([]FetchAssetProofsByAssetIDRow, error) {
	rows, err := q.db.QueryContext(ctx, FetchAssetProofsByAssetID, assetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchAssetProofsByAssetIDRow
	for rows.Next() {
		var i FetchAssetProofsByAssetIDRow
		if err := rows.Scan(&i.ScriptKey, &i.ProofFile); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const FetchAssetProofsSizes = `-- name: FetchAssetProofsSizes :many
SELECT script_keys.tweaked_script_key AS script_key, 
       LENGTH(asset_proofs.proof_file) AS proof_file_length
FROM asset_proofs
JOIN assets
    ON asset_proofs.asset_id = assets.asset_id
JOIN script_keys
    ON assets.script_key_id = script_keys.script_key_id
`

type FetchAssetProofsSizesRow struct {
	ScriptKey       []byte
	ProofFileLength float64
}

func (q *Queries) FetchAssetProofsSizes(ctx context.Context) ([]FetchAssetProofsSizesRow, error) {
	rows, err := q.db.QueryContext(ctx, FetchAssetProofsSizes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchAssetProofsSizesRow
	for rows.Next() {
		var i FetchAssetProofsSizesRow
		if err := rows.Scan(&i.ScriptKey, &i.ProofFileLength); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const FetchAssetWitnesses = `-- name: FetchAssetWitnesses :many
SELECT 
    assets.asset_id, prev_out_point, prev_asset_id, prev_script_key, 
    witness_stack, split_commitment_proof
FROM asset_witnesses
JOIN assets
    ON asset_witnesses.asset_id = assets.asset_id
WHERE (
    (assets.asset_id = $1) OR ($1 IS NULL)
)
ORDER BY witness_index
`

type FetchAssetWitnessesRow struct {
	AssetID              int64
	PrevOutPoint         []byte
	PrevAssetID          []byte
	PrevScriptKey        []byte
	WitnessStack         []byte
	SplitCommitmentProof []byte
}

func (q *Queries) FetchAssetWitnesses(ctx context.Context, assetID sql.NullInt64) ([]FetchAssetWitnessesRow, error) {
	rows, err := q.db.QueryContext(ctx, FetchAssetWitnesses, assetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchAssetWitnessesRow
	for rows.Next() {
		var i FetchAssetWitnessesRow
		if err := rows.Scan(
			&i.AssetID,
			&i.PrevOutPoint,
			&i.PrevAssetID,
			&i.PrevScriptKey,
			&i.WitnessStack,
			&i.SplitCommitmentProof,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const FetchAssetsByAnchorTx = `-- name: FetchAssetsByAnchorTx :many
SELECT asset_id, genesis_id, version, script_key_id, asset_group_witness_id, script_version, amount, lock_time, relative_lock_time, split_commitment_root_hash, split_commitment_root_value, anchor_utxo_id, spent
FROM assets
WHERE anchor_utxo_id = $1
`

func (q *Queries) FetchAssetsByAnchorTx(ctx context.Context, anchorUtxoID sql.NullInt64) ([]Asset, error) {
	rows, err := q.db.QueryContext(ctx, FetchAssetsByAnchorTx, anchorUtxoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.GenesisID,
			&i.Version,
			&i.ScriptKeyID,
			&i.AssetGroupWitnessID,
			&i.ScriptVersion,
			&i.Amount,
			&i.LockTime,
			&i.RelativeLockTime,
			&i.SplitCommitmentRootHash,
			&i.SplitCommitmentRootValue,
			&i.AnchorUtxoID,
			&i.Spent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const FetchAssetsForBatch = `-- name: FetchAssetsForBatch :many
WITH genesis_info AS (
    -- This CTE is used to fetch the base asset information from disk based on
    -- the raw key of the batch that will ultimately create this set of assets.
    -- To do so, we'll need to traverse a few tables to join the set of assets
    -- with the genesis points, then with the batches that reference this
    -- points, to the internal key that reference the batch, then restricted
    -- for internal keys that match our main batch key.
    SELECT
        gen_asset_id, asset_id, asset_tag, output_index, asset_type,
        genesis_points.prev_out prev_out,
        assets_meta.meta_id
    FROM genesis_assets
    LEFT JOIN assets_meta
        ON genesis_assets.meta_data_id = assets_meta.meta_id
    JOIN genesis_points
        ON genesis_assets.genesis_point_id = genesis_points.genesis_id
    JOIN asset_minting_batches batches
        ON genesis_points.genesis_id = batches.genesis_id
    JOIN internal_keys keys
        ON keys.key_id = batches.batch_id
    WHERE keys.raw_key = $1
), key_group_info AS (
    -- This CTE is used to perform a series of joins that allow us to extract
    -- the group key information, as well as the group sigs for the series of
    -- assets we care about. We obtain only the assets found in the batch
    -- above, with the WHERE query at the bottom.
    SELECT 
        witness_id, gen_asset_id, witness_stack, tapscript_root,
        tweaked_group_key, raw_key, key_index, key_family
    FROM asset_group_witnesses wit
    JOIN asset_groups groups
        ON wit.group_key_id = groups.group_id
    JOIN internal_keys keys
        ON keys.key_id = groups.internal_key_id
    -- TODO(roasbeef): or can join do this below?
    WHERE wit.gen_asset_id IN (SELECT gen_asset_id FROM genesis_info)
)
SELECT 
    version,
    script_keys.script_key_id, script_keys.internal_key_id, script_keys.tweaked_script_key, script_keys.tweak, script_keys.key_type,
    internal_keys.key_id, internal_keys.raw_key, internal_keys.key_family, internal_keys.key_index,
    key_group_info.tapscript_root, 
    key_group_info.witness_stack, 
    key_group_info.tweaked_group_key,
    key_group_info.raw_key AS group_key_raw,
    key_group_info.key_family AS group_key_family,
    key_group_info.key_index AS group_key_index,
    script_version, amount, lock_time, relative_lock_time, spent,
    genesis_info.asset_id, genesis_info.asset_tag,
    assets_meta.meta_id, assets_meta.meta_data_hash, assets_meta.meta_data_blob, assets_meta.meta_data_type, assets_meta.meta_decimal_display, assets_meta.meta_universe_commitments, assets_meta.meta_canonical_universes, assets_meta.meta_delegation_key,
    genesis_info.output_index AS genesis_output_index, genesis_info.asset_type,
    genesis_info.prev_out AS genesis_prev_out
FROM assets
JOIN genesis_info
    ON assets.genesis_id = genesis_info.gen_asset_id
LEFT JOIN assets_meta
    ON genesis_info.meta_id = assets_meta.meta_id
LEFT JOIN key_group_info
    ON assets.genesis_id = key_group_info.gen_asset_id
JOIN script_keys
    on assets.script_key_id = script_keys.script_key_id
JOIN internal_keys
    ON script_keys.internal_key_id = internal_keys.key_id
`

type FetchAssetsForBatchRow struct {
	Version            int32
	ScriptKey          ScriptKey
	InternalKey        InternalKey
	TapscriptRoot      []byte
	WitnessStack       []byte
	TweakedGroupKey    []byte
	GroupKeyRaw        []byte
	GroupKeyFamily     sql.NullInt32
	GroupKeyIndex      sql.NullInt32
	ScriptVersion      int32
	Amount             int64
	LockTime           sql.NullInt32
	RelativeLockTime   sql.NullInt32
	Spent              bool
	AssetID            []byte
	AssetTag           string
	AssetsMetum        AssetsMetum
	GenesisOutputIndex int32
	AssetType          int16
	GenesisPrevOut     []byte
}

// We use a LEFT JOIN here as not every asset has a meta data entry.
// We use a LEFT JOIN here as not every asset has a group key, so this'll
// generate rows that have NULL values for the group key fields if an asset
// doesn't have a group key. See the comment in fetchAssetSprouts for a work
// around that needs to be used with this query until a sqlc bug is fixed.
func (q *Queries) FetchAssetsForBatch(ctx context.Context, rawKey []byte) ([]FetchAssetsForBatchRow, error) {
	rows, err := q.db.QueryContext(ctx, FetchAssetsForBatch, rawKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchAssetsForBatchRow
	for rows.Next() {
		var i FetchAssetsForBatchRow
		if err := rows.Scan(
			&i.Version,
			&i.ScriptKey.ScriptKeyID,
			&i.ScriptKey.InternalKeyID,
			&i.ScriptKey.TweakedScriptKey,
			&i.ScriptKey.Tweak,
			&i.ScriptKey.KeyType,
			&i.InternalKey.KeyID,
			&i.InternalKey.RawKey,
			&i.InternalKey.KeyFamily,
			&i.InternalKey.KeyIndex,
			&i.TapscriptRoot,
			&i.WitnessStack,
			&i.TweakedGroupKey,
			&i.GroupKeyRaw,
			&i.GroupKeyFamily,
			&i.GroupKeyIndex,
			&i.ScriptVersion,
			&i.Amount,
			&i.LockTime,
			&i.RelativeLockTime,
			&i.Spent,
			&i.AssetID,
			&i.AssetTag,
			&i.AssetsMetum.MetaID,
			&i.AssetsMetum.MetaDataHash,
			&i.AssetsMetum.MetaDataBlob,
			&i.AssetsMetum.MetaDataType,
			&i.AssetsMetum.MetaDecimalDisplay,
			&i.AssetsMetum.MetaUniverseCommitments,
			&i.AssetsMetum.MetaCanonicalUniverses,
			&i.AssetsMetum.MetaDelegationKey,
			&i.GenesisOutputIndex,
			&i.AssetType,
			&i.GenesisPrevOut,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const FetchChainTx = `-- name: FetchChainTx :one
SELECT txn_id, txid, chain_fees, raw_tx, block_height, block_hash, tx_index
FROM chain_txns
WHERE txid = $1
`

func (q *Queries) FetchChainTx(ctx context.Context, txid []byte) (ChainTxn, error) {
	row := q.db.QueryRowContext(ctx, FetchChainTx, txid)
	var i ChainTxn
	err := row.Scan(
		&i.TxnID,
		&i.Txid,
		&i.ChainFees,
		&i.RawTx,
		&i.BlockHeight,
		&i.BlockHash,
		&i.TxIndex,
	)
	return i, err
}

const FetchGenesisByAssetID = `-- name: FetchGenesisByAssetID :one
SELECT gen_asset_id, asset_id, asset_tag, meta_hash, output_index, asset_type, prev_out, anchor_txid, block_height 
FROM genesis_info_view
WHERE asset_id = $1
`

func (q *Queries) FetchGenesisByAssetID(ctx context.Context, assetID []byte) (GenesisInfoView, error) {
	row := q.db.QueryRowContext(ctx, FetchGenesisByAssetID, assetID)
	var i GenesisInfoView
	err := row.Scan(
		&i.GenAssetID,
		&i.AssetID,
		&i.AssetTag,
		&i.MetaHash,
		&i.OutputIndex,
		&i.AssetType,
		&i.PrevOut,
		&i.AnchorTxid,
		&i.BlockHeight,
	)
	return i, err
}

const FetchGenesisByID = `-- name: FetchGenesisByID :one
SELECT
    asset_id, asset_tag, assets_meta.meta_data_hash, output_index, asset_type,
    genesis_points.prev_out prev_out
FROM genesis_assets
LEFT JOIN assets_meta
    ON genesis_assets.meta_data_id = assets_meta.meta_id
JOIN genesis_points
  ON genesis_assets.genesis_point_id = genesis_points.genesis_id
WHERE gen_asset_id = $1
`

type FetchGenesisByIDRow struct {
	AssetID      []byte
	AssetTag     string
	MetaDataHash []byte
	OutputIndex  int32
	AssetType    int16
	PrevOut      []byte
}

func (q *Queries) FetchGenesisByID(ctx context.Context, genAssetID int64) (FetchGenesisByIDRow, error) {
	row := q.db.QueryRowContext(ctx, FetchGenesisByID, genAssetID)
	var i FetchGenesisByIDRow
	err := row.Scan(
		&i.AssetID,
		&i.AssetTag,
		&i.MetaDataHash,
		&i.OutputIndex,
		&i.AssetType,
		&i.PrevOut,
	)
	return i, err
}

const FetchGenesisID = `-- name: FetchGenesisID :one
WITH target_point(genesis_id) AS (
    SELECT genesis_id
    FROM genesis_points
    WHERE genesis_points.prev_out = $6
)
SELECT gen_asset_id
FROM genesis_assets
LEFT JOIN assets_meta   
    ON genesis_assets.meta_data_id = assets_meta.meta_id
WHERE (
    genesis_assets.genesis_point_id IN (SELECT genesis_id FROM target_point) AND
    genesis_assets.asset_id = $1 AND
    genesis_assets.asset_tag = $2 AND
    assets_meta.meta_data_hash = $3 AND
    genesis_assets.output_index = $4 AND
    genesis_assets.asset_type = $5
)
`

type FetchGenesisIDParams struct {
	AssetID     []byte
	AssetTag    string
	MetaHash    []byte
	OutputIndex int32
	AssetType   int16
	PrevOut     []byte
}

func (q *Queries) FetchGenesisID(ctx context.Context, arg FetchGenesisIDParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, FetchGenesisID,
		arg.AssetID,
		arg.AssetTag,
		arg.MetaHash,
		arg.OutputIndex,
		arg.AssetType,
		arg.PrevOut,
	)
	var gen_asset_id int64
	err := row.Scan(&gen_asset_id)
	return gen_asset_id, err
}

const FetchGenesisIDByAssetID = `-- name: FetchGenesisIDByAssetID :one
SELECT gen_asset_id
FROM genesis_assets
WHERE asset_id = $1
`

func (q *Queries) FetchGenesisIDByAssetID(ctx context.Context, assetID []byte) (int64, error) {
	row := q.db.QueryRowContext(ctx, FetchGenesisIDByAssetID, assetID)
	var gen_asset_id int64
	err := row.Scan(&gen_asset_id)
	return gen_asset_id, err
}

const FetchGenesisPointByAnchorTx = `-- name: FetchGenesisPointByAnchorTx :one
SELECT genesis_id, prev_out, anchor_tx_id 
FROM genesis_points
WHERE anchor_tx_id = $1
`

func (q *Queries) FetchGenesisPointByAnchorTx(ctx context.Context, anchorTxID sql.NullInt64) (GenesisPoint, error) {
	row := q.db.QueryRowContext(ctx, FetchGenesisPointByAnchorTx, anchorTxID)
	var i GenesisPoint
	err := row.Scan(&i.GenesisID, &i.PrevOut, &i.AnchorTxID)
	return i, err
}

const FetchGroupByGenesis = `-- name: FetchGroupByGenesis :one
SELECT
    key_group_info_view.version AS version,
    key_group_info_view.tweaked_group_key AS tweaked_group_key,
    key_group_info_view.raw_key AS raw_key,
    key_group_info_view.key_index AS key_index,
    key_group_info_view.key_family AS key_family,
    key_group_info_view.tapscript_root AS tapscript_root,
    key_group_info_view.witness_stack AS witness_stack,
    key_group_info_view.custom_subtree_root AS custom_subtree_root
FROM key_group_info_view
WHERE (
    key_group_info_view.gen_asset_id = $1
)
`

type FetchGroupByGenesisRow struct {
	Version           int32
	TweakedGroupKey   []byte
	RawKey            []byte
	KeyIndex          int32
	KeyFamily         int32
	TapscriptRoot     []byte
	WitnessStack      []byte
	CustomSubtreeRoot []byte
}

func (q *Queries) FetchGroupByGenesis(ctx context.Context, genesisID int64) (FetchGroupByGenesisRow, error) {
	row := q.db.QueryRowContext(ctx, FetchGroupByGenesis, genesisID)
	var i FetchGroupByGenesisRow
	err := row.Scan(
		&i.Version,
		&i.TweakedGroupKey,
		&i.RawKey,
		&i.KeyIndex,
		&i.KeyFamily,
		&i.TapscriptRoot,
		&i.WitnessStack,
		&i.CustomSubtreeRoot,
	)
	return i, err
}

const FetchGroupByGroupKey = `-- name: FetchGroupByGroupKey :one
SELECT
    key_group_info_view.version AS version,
    key_group_info_view.gen_asset_id AS gen_asset_id,
    key_group_info_view.raw_key AS raw_key,
    key_group_info_view.key_index AS key_index,
    key_group_info_view.key_family AS key_family,
    key_group_info_view.tapscript_root AS tapscript_root,
    key_group_info_view.witness_stack AS witness_stack,
    key_group_info_view.custom_subtree_root AS custom_subtree_root
FROM key_group_info_view
WHERE (
    key_group_info_view.tweaked_group_key = $1
)
ORDER BY key_group_info_view.witness_id
LIMIT 1
`

type FetchGroupByGroupKeyRow struct {
	Version           int32
	GenAssetID        int64
	RawKey            []byte
	KeyIndex          int32
	KeyFamily         int32
	TapscriptRoot     []byte
	WitnessStack      []byte
	CustomSubtreeRoot []byte
}

// Sort and limit to return the genesis ID for initial genesis of the group.
func (q *Queries) FetchGroupByGroupKey(ctx context.Context, groupKey []byte) (FetchGroupByGroupKeyRow, error) {
	row := q.db.QueryRowContext(ctx, FetchGroupByGroupKey, groupKey)
	var i FetchGroupByGroupKeyRow
	err := row.Scan(
		&i.Version,
		&i.GenAssetID,
		&i.RawKey,
		&i.KeyIndex,
		&i.KeyFamily,
		&i.TapscriptRoot,
		&i.WitnessStack,
		&i.CustomSubtreeRoot,
	)
	return i, err
}

const FetchGroupedAssets = `-- name: FetchGroupedAssets :many
SELECT
    assets.asset_id AS asset_primary_key,
    amount, lock_time, relative_lock_time, spent, 
    genesis_info_view.asset_id AS asset_id,
    genesis_info_view.asset_tag,
    genesis_info_view.meta_Hash, 
    genesis_info_view.asset_type,
    key_group_info_view.tweaked_group_key,
    assets.version AS asset_version
FROM assets
JOIN genesis_info_view
    ON assets.genesis_id = genesis_info_view.gen_asset_id
JOIN key_group_info_view
    ON assets.genesis_id = key_group_info_view.gen_asset_id
WHERE spent = false
`

type FetchGroupedAssetsRow struct {
	AssetPrimaryKey  int64
	Amount           int64
	LockTime         sql.NullInt32
	RelativeLockTime sql.NullInt32
	Spent            bool
	AssetID          []byte
	AssetTag         string
	MetaHash         []byte
	AssetType        int16
	TweakedGroupKey  []byte
	AssetVersion     int32
}

func (q *Queries) FetchGroupedAssets(ctx context.Context) ([]FetchGroupedAssetsRow, error) {
	rows, err := q.db.QueryContext(ctx, FetchGroupedAssets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchGroupedAssetsRow
	for rows.Next() {
		var i FetchGroupedAssetsRow
		if err := rows.Scan(
			&i.AssetPrimaryKey,
			&i.Amount,
			&i.LockTime,
			&i.RelativeLockTime,
			&i.Spent,
			&i.AssetID,
			&i.AssetTag,
			&i.MetaHash,
			&i.AssetType,
			&i.TweakedGroupKey,
			&i.AssetVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const FetchInternalKeyLocator = `-- name: FetchInternalKeyLocator :one
SELECT key_family, key_index
FROM internal_keys
WHERE raw_key = $1
`

type FetchInternalKeyLocatorRow struct {
	KeyFamily int32
	KeyIndex  int32
}

func (q *Queries) FetchInternalKeyLocator(ctx context.Context, rawKey []byte) (FetchInternalKeyLocatorRow, error) {
	row := q.db.QueryRowContext(ctx, FetchInternalKeyLocator, rawKey)
	var i FetchInternalKeyLocatorRow
	err := row.Scan(&i.KeyFamily, &i.KeyIndex)
	return i, err
}

const FetchManagedUTXO = `-- name: FetchManagedUTXO :one
SELECT utxo_id, outpoint, amt_sats, internal_key_id, taproot_asset_root, tapscript_sibling, merkle_root, txn_id, lease_owner, lease_expiry, root_version, key_id, raw_key, key_family, key_index
FROM managed_utxos utxos
JOIN internal_keys keys
    ON utxos.internal_key_id = keys.key_id
WHERE (
    (txn_id = $1 OR $1 IS NULL) AND
    (utxos.outpoint = $2 OR $2 IS NULL)
)
`

type FetchManagedUTXOParams struct {
	TxnID    sql.NullInt64
	Outpoint []byte
}

type FetchManagedUTXORow struct {
	UtxoID           int64
	Outpoint         []byte
	AmtSats          int64
	InternalKeyID    int64
	TaprootAssetRoot []byte
	TapscriptSibling []byte
	MerkleRoot       []byte
	TxnID            int64
	LeaseOwner       []byte
	LeaseExpiry      sql.NullTime
	RootVersion      sql.NullInt16
	KeyID            int64
	RawKey           []byte
	KeyFamily        int32
	KeyIndex         int32
}

func (q *Queries) FetchManagedUTXO(ctx context.Context, arg FetchManagedUTXOParams) (FetchManagedUTXORow, error) {
	row := q.db.QueryRowContext(ctx, FetchManagedUTXO, arg.TxnID, arg.Outpoint)
	var i FetchManagedUTXORow
	err := row.Scan(
		&i.UtxoID,
		&i.Outpoint,
		&i.AmtSats,
		&i.InternalKeyID,
		&i.TaprootAssetRoot,
		&i.TapscriptSibling,
		&i.MerkleRoot,
		&i.TxnID,
		&i.LeaseOwner,
		&i.LeaseExpiry,
		&i.RootVersion,
		&i.KeyID,
		&i.RawKey,
		&i.KeyFamily,
		&i.KeyIndex,
	)
	return i, err
}

const FetchManagedUTXOs = `-- name: FetchManagedUTXOs :many
SELECT utxo_id, outpoint, amt_sats, internal_key_id, taproot_asset_root, tapscript_sibling, merkle_root, txn_id, lease_owner, lease_expiry, root_version, key_id, raw_key, key_family, key_index
FROM managed_utxos utxos
JOIN internal_keys keys
    ON utxos.internal_key_id = keys.key_id
`

type FetchManagedUTXOsRow struct {
	UtxoID           int64
	Outpoint         []byte
	AmtSats          int64
	InternalKeyID    int64
	TaprootAssetRoot []byte
	TapscriptSibling []byte
	MerkleRoot       []byte
	TxnID            int64
	LeaseOwner       []byte
	LeaseExpiry      sql.NullTime
	RootVersion      sql.NullInt16
	KeyID            int64
	RawKey           []byte
	KeyFamily        int32
	KeyIndex         int32
}

func (q *Queries) FetchManagedUTXOs(ctx context.Context) ([]FetchManagedUTXOsRow, error) {
	rows, err := q.db.QueryContext(ctx, FetchManagedUTXOs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchManagedUTXOsRow
	for rows.Next() {
		var i FetchManagedUTXOsRow
		if err := rows.Scan(
			&i.UtxoID,
			&i.Outpoint,
			&i.AmtSats,
			&i.InternalKeyID,
			&i.TaprootAssetRoot,
			&i.TapscriptSibling,
			&i.MerkleRoot,
			&i.TxnID,
			&i.LeaseOwner,
			&i.LeaseExpiry,
			&i.RootVersion,
			&i.KeyID,
			&i.RawKey,
			&i.KeyFamily,
			&i.KeyIndex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const FetchMintAnchorUniCommitment = `-- name: FetchMintAnchorUniCommitment :one
SELECT id, batch_id, tx_output_index, taproot_internal_key, group_key
FROM mint_anchor_uni_commitments
WHERE batch_id = $1
`

// Fetch a record from the mint_anchor_uni_commitments table by id.
func (q *Queries) FetchMintAnchorUniCommitment(ctx context.Context, batchID int32) (MintAnchorUniCommitment, error) {
	row := q.db.QueryRowContext(ctx, FetchMintAnchorUniCommitment, batchID)
	var i MintAnchorUniCommitment
	err := row.Scan(
		&i.ID,
		&i.BatchID,
		&i.TxOutputIndex,
		&i.TaprootInternalKey,
		&i.GroupKey,
	)
	return i, err
}

const FetchMintingBatch = `-- name: FetchMintingBatch :one
WITH target_batch AS (
    -- This CTE is used to fetch the ID of a batch, based on the serialized
    -- internal key associated with the batch. This internal key is used as the
    -- actual Taproot internal key to ultimately mint the batch. This pattern
    -- is used in several other queries.
    SELECT batch_id
    FROM asset_minting_batches batches
    JOIN internal_keys keys
        ON batches.batch_id = keys.key_id
    WHERE keys.raw_key = $1
)
SELECT batch_id, batch_state, minting_tx_psbt, change_output_index, genesis_id, height_hint, creation_time_unix, tapscript_sibling, assets_output_index, universe_commitments, key_id, raw_key, key_family, key_index
FROM asset_minting_batches batches
JOIN internal_keys keys
    ON batches.batch_id = keys.key_id
WHERE batch_id in (SELECT batch_id FROM target_batch)
`

type FetchMintingBatchRow struct {
	BatchID             int64
	BatchState          int16
	MintingTxPsbt       []byte
	ChangeOutputIndex   sql.NullInt32
	GenesisID           sql.NullInt64
	HeightHint          int32
	CreationTimeUnix    time.Time
	TapscriptSibling    []byte
	AssetsOutputIndex   sql.NullInt32
	UniverseCommitments bool
	KeyID               int64
	RawKey              []byte
	KeyFamily           int32
	KeyIndex            int32
}

func (q *Queries) FetchMintingBatch(ctx context.Context, rawKey []byte) (FetchMintingBatchRow, error) {
	row := q.db.QueryRowContext(ctx, FetchMintingBatch, rawKey)
	var i FetchMintingBatchRow
	err := row.Scan(
		&i.BatchID,
		&i.BatchState,
		&i.MintingTxPsbt,
		&i.ChangeOutputIndex,
		&i.GenesisID,
		&i.HeightHint,
		&i.CreationTimeUnix,
		&i.TapscriptSibling,
		&i.AssetsOutputIndex,
		&i.UniverseCommitments,
		&i.KeyID,
		&i.RawKey,
		&i.KeyFamily,
		&i.KeyIndex,
	)
	return i, err
}

const FetchMintingBatchesByInverseState = `-- name: FetchMintingBatchesByInverseState :many
SELECT batch_id, batch_state, minting_tx_psbt, change_output_index, genesis_id, height_hint, creation_time_unix, tapscript_sibling, assets_output_index, universe_commitments, key_id, raw_key, key_family, key_index
FROM asset_minting_batches batches
JOIN internal_keys keys
    ON batches.batch_id = keys.key_id
WHERE batches.batch_state != $1
`

type FetchMintingBatchesByInverseStateRow struct {
	BatchID             int64
	BatchState          int16
	MintingTxPsbt       []byte
	ChangeOutputIndex   sql.NullInt32
	GenesisID           sql.NullInt64
	HeightHint          int32
	CreationTimeUnix    time.Time
	TapscriptSibling    []byte
	AssetsOutputIndex   sql.NullInt32
	UniverseCommitments bool
	KeyID               int64
	RawKey              []byte
	KeyFamily           int32
	KeyIndex            int32
}

func (q *Queries) FetchMintingBatchesByInverseState(ctx context.Context, batchState int16) ([]FetchMintingBatchesByInverseStateRow, error) {
	rows, err := q.db.QueryContext(ctx, FetchMintingBatchesByInverseState, batchState)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchMintingBatchesByInverseStateRow
	for rows.Next() {
		var i FetchMintingBatchesByInverseStateRow
		if err := rows.Scan(
			&i.BatchID,
			&i.BatchState,
			&i.MintingTxPsbt,
			&i.ChangeOutputIndex,
			&i.GenesisID,
			&i.HeightHint,
			&i.CreationTimeUnix,
			&i.TapscriptSibling,
			&i.AssetsOutputIndex,
			&i.UniverseCommitments,
			&i.KeyID,
			&i.RawKey,
			&i.KeyFamily,
			&i.KeyIndex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const FetchScriptKeyByTweakedKey = `-- name: FetchScriptKeyByTweakedKey :one
SELECT script_keys.script_key_id, script_keys.internal_key_id, script_keys.tweaked_script_key, script_keys.tweak, script_keys.key_type, internal_keys.key_id, internal_keys.raw_key, internal_keys.key_family, internal_keys.key_index
FROM script_keys
JOIN internal_keys
  ON script_keys.internal_key_id = internal_keys.key_id
WHERE script_keys.tweaked_script_key = $1
`

type FetchScriptKeyByTweakedKeyRow struct {
	ScriptKey   ScriptKey
	InternalKey InternalKey
}

func (q *Queries) FetchScriptKeyByTweakedKey(ctx context.Context, tweakedScriptKey []byte) (FetchScriptKeyByTweakedKeyRow, error) {
	row := q.db.QueryRowContext(ctx, FetchScriptKeyByTweakedKey, tweakedScriptKey)
	var i FetchScriptKeyByTweakedKeyRow
	err := row.Scan(
		&i.ScriptKey.ScriptKeyID,
		&i.ScriptKey.InternalKeyID,
		&i.ScriptKey.TweakedScriptKey,
		&i.ScriptKey.Tweak,
		&i.ScriptKey.KeyType,
		&i.InternalKey.KeyID,
		&i.InternalKey.RawKey,
		&i.InternalKey.KeyFamily,
		&i.InternalKey.KeyIndex,
	)
	return i, err
}

const FetchScriptKeyIDByTweakedKey = `-- name: FetchScriptKeyIDByTweakedKey :one
SELECT script_key_id
FROM script_keys
WHERE tweaked_script_key = $1
`

func (q *Queries) FetchScriptKeyIDByTweakedKey(ctx context.Context, tweakedScriptKey []byte) (int64, error) {
	row := q.db.QueryRowContext(ctx, FetchScriptKeyIDByTweakedKey, tweakedScriptKey)
	var script_key_id int64
	err := row.Scan(&script_key_id)
	return script_key_id, err
}

const FetchSeedlingByID = `-- name: FetchSeedlingByID :one
SELECT seedling_id, asset_name, asset_version, asset_type, asset_supply, asset_meta_id, emission_enabled, batch_id, group_genesis_id, group_anchor_id, script_key_id, group_internal_key_id, group_tapscript_root
FROM asset_seedlings
WHERE seedling_id = $1
`

func (q *Queries) FetchSeedlingByID(ctx context.Context, seedlingID int64) (AssetSeedling, error) {
	row := q.db.QueryRowContext(ctx, FetchSeedlingByID, seedlingID)
	var i AssetSeedling
	err := row.Scan(
		&i.SeedlingID,
		&i.AssetName,
		&i.AssetVersion,
		&i.AssetType,
		&i.AssetSupply,
		&i.AssetMetaID,
		&i.EmissionEnabled,
		&i.BatchID,
		&i.GroupGenesisID,
		&i.GroupAnchorID,
		&i.ScriptKeyID,
		&i.GroupInternalKeyID,
		&i.GroupTapscriptRoot,
	)
	return i, err
}

const FetchSeedlingID = `-- name: FetchSeedlingID :one
WITH target_key_id AS (
    -- We use this CTE to fetch the key_id of the internal key that's
    -- associated with a given batch. This can only return one value in
    -- practice since raw_key is a unique field. We then use this value below
    -- to select only from seedlings in the specified batch.
    SELECT key_id
    FROM internal_keys keys
    WHERE keys.raw_key = $2
)
SELECT seedling_id
FROM asset_seedlings
WHERE (
    asset_seedlings.batch_id in (SELECT key_id FROM target_key_id) AND
    asset_seedlings.asset_name = $1
)
`

type FetchSeedlingIDParams struct {
	SeedlingName string
	BatchKey     []byte
}

func (q *Queries) FetchSeedlingID(ctx context.Context, arg FetchSeedlingIDParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, FetchSeedlingID, arg.SeedlingName, arg.BatchKey)
	var seedling_id int64
	err := row.Scan(&seedling_id)
	return seedling_id, err
}

const FetchSeedlingsForBatch = `-- name: FetchSeedlingsForBatch :many
WITH target_batch(batch_id) AS (
    SELECT batch_id
    FROM asset_minting_batches batches
    JOIN internal_keys keys
        ON batches.batch_id = keys.key_id
    WHERE keys.raw_key = $1
)
SELECT seedling_id, asset_name, asset_type, asset_version, asset_supply,
    assets_meta.meta_id, assets_meta.meta_data_hash, assets_meta.meta_data_blob, assets_meta.meta_data_type, assets_meta.meta_decimal_display, assets_meta.meta_universe_commitments, assets_meta.meta_canonical_universes, assets_meta.meta_delegation_key,
    emission_enabled, batch_id, 
    group_genesis_id, group_anchor_id, group_tapscript_root,
    -- TODO(guggero): We should use sqlc.embed() for the script key and internal
    -- key fields, but we can't because it's a LEFT JOIN. We should check if the
    -- LEFT JOIN is actually necessary or if we always have keys for seedlings.
    script_keys.tweak AS script_key_tweak,
    script_keys.tweaked_script_key,
    script_keys.key_type AS script_key_type,
    internal_keys.raw_key AS script_key_raw,
    internal_keys.key_family AS script_key_fam,
    internal_keys.key_index AS script_key_index,
    group_internal_keys.raw_key AS group_key_raw,
    group_internal_keys.key_family AS group_key_fam,
    group_internal_keys.key_index AS group_key_index
FROM asset_seedlings 
LEFT JOIN assets_meta
    ON asset_seedlings.asset_meta_id = assets_meta.meta_id
LEFT JOIN script_keys
    ON asset_seedlings.script_key_id = script_keys.script_key_id
LEFT JOIN internal_keys
    ON script_keys.internal_key_id = internal_keys.key_id
LEFT JOIN internal_keys group_internal_keys
    ON asset_seedlings.group_internal_key_id = group_internal_keys.key_id
WHERE asset_seedlings.batch_id in (SELECT batch_id FROM target_batch)
`

type FetchSeedlingsForBatchRow struct {
	SeedlingID         int64
	AssetName          string
	AssetType          int16
	AssetVersion       int16
	AssetSupply        int64
	AssetsMetum        AssetsMetum
	EmissionEnabled    bool
	BatchID            int64
	GroupGenesisID     sql.NullInt64
	GroupAnchorID      sql.NullInt64
	GroupTapscriptRoot []byte
	ScriptKeyTweak     []byte
	TweakedScriptKey   []byte
	ScriptKeyType      sql.NullInt16
	ScriptKeyRaw       []byte
	ScriptKeyFam       sql.NullInt32
	ScriptKeyIndex     sql.NullInt32
	GroupKeyRaw        []byte
	GroupKeyFam        sql.NullInt32
	GroupKeyIndex      sql.NullInt32
}

func (q *Queries) FetchSeedlingsForBatch(ctx context.Context, rawKey []byte) ([]FetchSeedlingsForBatchRow, error) {
	rows, err := q.db.QueryContext(ctx, FetchSeedlingsForBatch, rawKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchSeedlingsForBatchRow
	for rows.Next() {
		var i FetchSeedlingsForBatchRow
		if err := rows.Scan(
			&i.SeedlingID,
			&i.AssetName,
			&i.AssetType,
			&i.AssetVersion,
			&i.AssetSupply,
			&i.AssetsMetum.MetaID,
			&i.AssetsMetum.MetaDataHash,
			&i.AssetsMetum.MetaDataBlob,
			&i.AssetsMetum.MetaDataType,
			&i.AssetsMetum.MetaDecimalDisplay,
			&i.AssetsMetum.MetaUniverseCommitments,
			&i.AssetsMetum.MetaCanonicalUniverses,
			&i.AssetsMetum.MetaDelegationKey,
			&i.EmissionEnabled,
			&i.BatchID,
			&i.GroupGenesisID,
			&i.GroupAnchorID,
			&i.GroupTapscriptRoot,
			&i.ScriptKeyTweak,
			&i.TweakedScriptKey,
			&i.ScriptKeyType,
			&i.ScriptKeyRaw,
			&i.ScriptKeyFam,
			&i.ScriptKeyIndex,
			&i.GroupKeyRaw,
			&i.GroupKeyFam,
			&i.GroupKeyIndex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const FetchTapscriptTree = `-- name: FetchTapscriptTree :many
WITH tree_info AS (
    -- This CTE is used to fetch all edges that link the given tapscript tree
    -- root hash to child nodes. Each edge also contains the index of the child
    -- node in the tapscript tree.
    SELECT tapscript_roots.branch_only, tapscript_edges.raw_node_id,
        tapscript_edges.node_index
    FROM tapscript_roots
    JOIN tapscript_edges
        ON tapscript_roots.root_id = tapscript_edges.root_hash_id
    WHERE tapscript_roots.root_hash = $1
)
SELECT tree_info.branch_only, tapscript_nodes.raw_node
FROM tapscript_nodes
JOIN tree_info
    ON tree_info.raw_node_id = tapscript_nodes.node_id
ORDER BY tree_info.node_index ASC
`

type FetchTapscriptTreeRow struct {
	BranchOnly bool
	RawNode    []byte
}

// Sort the nodes by node_index here instead of returning the indices.
func (q *Queries) FetchTapscriptTree(ctx context.Context, rootHash []byte) ([]FetchTapscriptTreeRow, error) {
	rows, err := q.db.QueryContext(ctx, FetchTapscriptTree, rootHash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchTapscriptTreeRow
	for rows.Next() {
		var i FetchTapscriptTreeRow
		if err := rows.Scan(&i.BranchOnly, &i.RawNode); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const FetchUnknownTypeScriptKeys = `-- name: FetchUnknownTypeScriptKeys :many
SELECT script_keys.script_key_id, script_keys.internal_key_id, script_keys.tweaked_script_key, script_keys.tweak, script_keys.key_type, internal_keys.key_id, internal_keys.raw_key, internal_keys.key_family, internal_keys.key_index
FROM script_keys
JOIN internal_keys
  ON script_keys.internal_key_id = internal_keys.key_id
WHERE script_keys.key_type IS NULL
`

type FetchUnknownTypeScriptKeysRow struct {
	ScriptKey   ScriptKey
	InternalKey InternalKey
}

func (q *Queries) FetchUnknownTypeScriptKeys(ctx context.Context) ([]FetchUnknownTypeScriptKeysRow, error) {
	rows, err := q.db.QueryContext(ctx, FetchUnknownTypeScriptKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchUnknownTypeScriptKeysRow
	for rows.Next() {
		var i FetchUnknownTypeScriptKeysRow
		if err := rows.Scan(
			&i.ScriptKey.ScriptKeyID,
			&i.ScriptKey.InternalKeyID,
			&i.ScriptKey.TweakedScriptKey,
			&i.ScriptKey.Tweak,
			&i.ScriptKey.KeyType,
			&i.InternalKey.KeyID,
			&i.InternalKey.RawKey,
			&i.InternalKey.KeyFamily,
			&i.InternalKey.KeyIndex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GenesisAssets = `-- name: GenesisAssets :many
SELECT gen_asset_id, asset_id, asset_tag, meta_data_id, output_index, asset_type, genesis_point_id 
FROM genesis_assets
`

func (q *Queries) GenesisAssets(ctx context.Context) ([]GenesisAsset, error) {
	rows, err := q.db.QueryContext(ctx, GenesisAssets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GenesisAsset
	for rows.Next() {
		var i GenesisAsset
		if err := rows.Scan(
			&i.GenAssetID,
			&i.AssetID,
			&i.AssetTag,
			&i.MetaDataID,
			&i.OutputIndex,
			&i.AssetType,
			&i.GenesisPointID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GenesisPoints = `-- name: GenesisPoints :many
SELECT genesis_id, prev_out, anchor_tx_id
FROM genesis_points
`

func (q *Queries) GenesisPoints(ctx context.Context) ([]GenesisPoint, error) {
	rows, err := q.db.QueryContext(ctx, GenesisPoints)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GenesisPoint
	for rows.Next() {
		var i GenesisPoint
		if err := rows.Scan(&i.GenesisID, &i.PrevOut, &i.AnchorTxID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const HasAssetProof = `-- name: HasAssetProof :one
WITH asset_info AS (
    SELECT assets.asset_id
    FROM assets
    JOIN script_keys
        ON assets.script_key_id = script_keys.script_key_id
    WHERE script_keys.tweaked_script_key = $1
)
SELECT COUNT(asset_info.asset_id) > 0 as has_proof
FROM asset_proofs
JOIN asset_info
    ON asset_info.asset_id = asset_proofs.asset_id
`

func (q *Queries) HasAssetProof(ctx context.Context, tweakedScriptKey []byte) (bool, error) {
	row := q.db.QueryRowContext(ctx, HasAssetProof, tweakedScriptKey)
	var has_proof bool
	err := row.Scan(&has_proof)
	return has_proof, err
}

const InsertAssetSeedling = `-- name: InsertAssetSeedling :exec
INSERT INTO asset_seedlings (
    asset_name, asset_type, asset_version, asset_supply, asset_meta_id,
    emission_enabled, batch_id, group_genesis_id, group_anchor_id,
    script_key_id, group_internal_key_id, group_tapscript_root
) VALUES (
   $1, $2, $3, $4,
   $5, $6, $7,
   $8, $9,
   $10, $11,
   $12
)
`

type InsertAssetSeedlingParams struct {
	AssetName          string
	AssetType          int16
	AssetVersion       int16
	AssetSupply        int64
	AssetMetaID        int64
	EmissionEnabled    bool
	BatchID            int64
	GroupGenesisID     sql.NullInt64
	GroupAnchorID      sql.NullInt64
	ScriptKeyID        sql.NullInt64
	GroupInternalKeyID sql.NullInt64
	GroupTapscriptRoot []byte
}

func (q *Queries) InsertAssetSeedling(ctx context.Context, arg InsertAssetSeedlingParams) error {
	_, err := q.db.ExecContext(ctx, InsertAssetSeedling,
		arg.AssetName,
		arg.AssetType,
		arg.AssetVersion,
		arg.AssetSupply,
		arg.AssetMetaID,
		arg.EmissionEnabled,
		arg.BatchID,
		arg.GroupGenesisID,
		arg.GroupAnchorID,
		arg.ScriptKeyID,
		arg.GroupInternalKeyID,
		arg.GroupTapscriptRoot,
	)
	return err
}

const InsertAssetSeedlingIntoBatch = `-- name: InsertAssetSeedlingIntoBatch :exec
WITH target_key_id AS (
    -- We use this CTE to fetch the key_id of the internal key that's
    -- associated with a given batch. This can only return one value in
    -- practice since raw_key is a unique field. We then use this value below
    -- to insert the seedling and point to the proper batch_id, which is a
    -- foreign key that references the key_id of the internal key.
    SELECT key_id 
    FROM internal_keys keys
    WHERE keys.raw_key = $1
)
INSERT INTO asset_seedlings(
    asset_name, asset_type, asset_version, asset_supply, asset_meta_id,
    emission_enabled, batch_id, group_genesis_id, group_anchor_id,
    script_key_id, group_internal_key_id, group_tapscript_root
) VALUES (
    $2, $3, $4, $5,
    $6, $7,
    (SELECT key_id FROM target_key_id),
    $8, $9,
    $10, $11,
    $12
)
`

type InsertAssetSeedlingIntoBatchParams struct {
	RawKey             []byte
	AssetName          string
	AssetType          int16
	AssetVersion       int16
	AssetSupply        int64
	AssetMetaID        int64
	EmissionEnabled    bool
	GroupGenesisID     sql.NullInt64
	GroupAnchorID      sql.NullInt64
	ScriptKeyID        sql.NullInt64
	GroupInternalKeyID sql.NullInt64
	GroupTapscriptRoot []byte
}

func (q *Queries) InsertAssetSeedlingIntoBatch(ctx context.Context, arg InsertAssetSeedlingIntoBatchParams) error {
	_, err := q.db.ExecContext(ctx, InsertAssetSeedlingIntoBatch,
		arg.RawKey,
		arg.AssetName,
		arg.AssetType,
		arg.AssetVersion,
		arg.AssetSupply,
		arg.AssetMetaID,
		arg.EmissionEnabled,
		arg.GroupGenesisID,
		arg.GroupAnchorID,
		arg.ScriptKeyID,
		arg.GroupInternalKeyID,
		arg.GroupTapscriptRoot,
	)
	return err
}

const NewMintingBatch = `-- name: NewMintingBatch :exec
INSERT INTO asset_minting_batches (
    batch_state, batch_id, height_hint, creation_time_unix
) VALUES (0, $1, $2, $3)
`

type NewMintingBatchParams struct {
	BatchID          int64
	HeightHint       int32
	CreationTimeUnix time.Time
}

func (q *Queries) NewMintingBatch(ctx context.Context, arg NewMintingBatchParams) error {
	_, err := q.db.ExecContext(ctx, NewMintingBatch, arg.BatchID, arg.HeightHint, arg.CreationTimeUnix)
	return err
}

const QueryAssetBalancesByAsset = `-- name: QueryAssetBalancesByAsset :many
SELECT
    genesis_info_view.asset_id, SUM(amount) balance,
    genesis_info_view.asset_tag, genesis_info_view.meta_hash,
    genesis_info_view.asset_type, genesis_info_view.output_index,
    genesis_info_view.prev_out AS genesis_point
FROM assets
JOIN genesis_info_view
    ON assets.genesis_id = genesis_info_view.gen_asset_id AND
      (genesis_info_view.asset_id = $1 OR
        $1 IS NULL)
LEFT JOIN key_group_info_view
    ON assets.genesis_id = key_group_info_view.gen_asset_id
JOIN managed_utxos utxos
    ON assets.anchor_utxo_id = utxos.utxo_id AND
       CASE
           WHEN $2 = true THEN
               (utxos.lease_owner IS NOT NULL AND utxos.lease_expiry > $3)
           WHEN $2 = false THEN
               (utxos.lease_owner IS NULL OR 
                utxos.lease_expiry IS NULL OR
                utxos.lease_expiry <= $3)
           ELSE TRUE
       END
JOIN script_keys
    ON assets.script_key_id = script_keys.script_key_id
WHERE spent = FALSE AND 
      (script_keys.key_type != $4 OR
        $4 IS NULL) AND
      ($5 = script_keys.key_type OR 
        $5 IS NULL)
GROUP BY assets.genesis_id, genesis_info_view.asset_id,
         genesis_info_view.asset_tag, genesis_info_view.meta_hash,
         genesis_info_view.asset_type, genesis_info_view.output_index,
         genesis_info_view.prev_out
`

type QueryAssetBalancesByAssetParams struct {
	AssetIDFilter        []byte
	Leased               interface{}
	Now                  sql.NullTime
	ExcludeScriptKeyType sql.NullInt16
	ScriptKeyType        sql.NullInt16
}

type QueryAssetBalancesByAssetRow struct {
	AssetID      []byte
	Balance      int64
	AssetTag     string
	MetaHash     []byte
	AssetType    int16
	OutputIndex  int32
	GenesisPoint []byte
}

// We use a LEFT JOIN here as not every asset has a group key, so this'll
// generate rows that have NULL values for the group key fields if an asset
// doesn't have a group key. See the comment in fetchAssetSprouts for a work
// around that needs to be used with this query until a sqlc bug is fixed.
func (q *Queries) QueryAssetBalancesByAsset(ctx context.Context, arg QueryAssetBalancesByAssetParams) ([]QueryAssetBalancesByAssetRow, error) {
	rows, err := q.db.QueryContext(ctx, QueryAssetBalancesByAsset,
		arg.AssetIDFilter,
		arg.Leased,
		arg.Now,
		arg.ExcludeScriptKeyType,
		arg.ScriptKeyType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryAssetBalancesByAssetRow
	for rows.Next() {
		var i QueryAssetBalancesByAssetRow
		if err := rows.Scan(
			&i.AssetID,
			&i.Balance,
			&i.AssetTag,
			&i.MetaHash,
			&i.AssetType,
			&i.OutputIndex,
			&i.GenesisPoint,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const QueryAssetBalancesByGroup = `-- name: QueryAssetBalancesByGroup :many
SELECT
    key_group_info_view.tweaked_group_key, SUM(amount) balance
FROM assets
JOIN key_group_info_view
    ON assets.genesis_id = key_group_info_view.gen_asset_id AND
      (key_group_info_view.tweaked_group_key = $1 OR
        $1 IS NULL)
JOIN managed_utxos utxos
    ON assets.anchor_utxo_id = utxos.utxo_id AND
       CASE
           WHEN $2 = true THEN
               (utxos.lease_owner IS NOT NULL AND utxos.lease_expiry > $3)
           WHEN $2 = false THEN
               (utxos.lease_owner IS NULL OR 
                utxos.lease_expiry IS NULL OR
                utxos.lease_expiry <= $3)
           ELSE TRUE
       END
JOIN script_keys
    ON assets.script_key_id = script_keys.script_key_id
WHERE spent = FALSE AND
      (script_keys.key_type != $4 OR
        $4 IS NULL) AND
      ($5 = script_keys.key_type OR
        $5 IS NULL)
GROUP BY key_group_info_view.tweaked_group_key
`

type QueryAssetBalancesByGroupParams struct {
	KeyGroupFilter       []byte
	Leased               interface{}
	Now                  sql.NullTime
	ExcludeScriptKeyType sql.NullInt16
	ScriptKeyType        sql.NullInt16
}

type QueryAssetBalancesByGroupRow struct {
	TweakedGroupKey []byte
	Balance         int64
}

func (q *Queries) QueryAssetBalancesByGroup(ctx context.Context, arg QueryAssetBalancesByGroupParams) ([]QueryAssetBalancesByGroupRow, error) {
	rows, err := q.db.QueryContext(ctx, QueryAssetBalancesByGroup,
		arg.KeyGroupFilter,
		arg.Leased,
		arg.Now,
		arg.ExcludeScriptKeyType,
		arg.ScriptKeyType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryAssetBalancesByGroupRow
	for rows.Next() {
		var i QueryAssetBalancesByGroupRow
		if err := rows.Scan(&i.TweakedGroupKey, &i.Balance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const QueryAssets = `-- name: QueryAssets :many
SELECT
    assets.asset_id AS asset_primary_key,
    assets.genesis_id, assets.version, spent,
    script_keys.script_key_id, script_keys.internal_key_id, script_keys.tweaked_script_key, script_keys.tweak, script_keys.key_type,
    internal_keys.key_id, internal_keys.raw_key, internal_keys.key_family, internal_keys.key_index,
    key_group_info_view.tapscript_root, 
    key_group_info_view.witness_stack, 
    key_group_info_view.tweaked_group_key,
    key_group_info_view.raw_key AS group_key_raw,
    key_group_info_view.key_family AS group_key_family,
    key_group_info_view.key_index AS group_key_index,
    script_version, amount, lock_time, relative_lock_time, 
    genesis_info_view.asset_id AS asset_id,
    genesis_info_view.asset_tag,
    genesis_info_view.meta_hash, 
    genesis_info_view.output_index AS genesis_output_index,
    genesis_info_view.asset_type,
    genesis_info_view.prev_out AS genesis_prev_out,
    txns.raw_tx AS anchor_tx,
    txns.txid AS anchor_txid,
    txns.block_hash AS anchor_block_hash,
    txns.block_height AS anchor_block_height,
    utxos.outpoint AS anchor_outpoint,
    utxos.tapscript_sibling AS anchor_tapscript_sibling,
    utxos.merkle_root AS anchor_merkle_root,
    utxos.taproot_asset_root AS anchor_taproot_asset_root,
    utxos.root_version AS anchor_commitment_version,
    utxos.lease_owner AS anchor_lease_owner,
    utxos.lease_expiry AS anchor_lease_expiry,
    utxo_internal_keys.raw_key AS anchor_internal_key,
    split_commitment_root_hash, split_commitment_root_value
FROM assets
JOIN genesis_info_view
    ON assets.genesis_id = genesis_info_view.gen_asset_id AND
      (genesis_info_view.asset_id = $1 OR
        $1 IS NULL)
LEFT JOIN key_group_info_view
    ON assets.genesis_id = key_group_info_view.gen_asset_id
JOIN script_keys
    ON assets.script_key_id = script_keys.script_key_id AND
      (script_keys.tweaked_script_key = $2 OR
       $2 IS NULL)
JOIN internal_keys
    ON script_keys.internal_key_id = internal_keys.key_id
JOIN managed_utxos utxos
    ON assets.anchor_utxo_id = utxos.utxo_id AND
      (utxos.outpoint = $3 OR
       $3 IS NULL) AND
       CASE
           WHEN $4 = true THEN
               (utxos.lease_owner IS NOT NULL AND utxos.lease_expiry > $5)
           WHEN $4 = false THEN
               (utxos.lease_owner IS NULL OR 
                utxos.lease_expiry IS NULL OR
                utxos.lease_expiry <= $5)
           ELSE TRUE
       END
JOIN internal_keys utxo_internal_keys
    ON utxos.internal_key_id = utxo_internal_keys.key_id
JOIN chain_txns txns
    ON utxos.txn_id = txns.txn_id AND
      COALESCE(txns.block_height, 0) >= COALESCE($6, txns.block_height, 0)
WHERE (
    assets.amount >= COALESCE($7, assets.amount) AND
    assets.amount <= COALESCE($8, assets.amount) AND
    assets.spent = COALESCE($9, assets.spent) AND
    (key_group_info_view.tweaked_group_key = $10 OR
      $10 IS NULL) AND
    assets.anchor_utxo_id = COALESCE($11, assets.anchor_utxo_id) AND
    assets.genesis_id = COALESCE($12, assets.genesis_id) AND
    assets.script_key_id = COALESCE($13, assets.script_key_id) AND
    ($14 = script_keys.key_type OR
      $14 IS NULL)
)
`

type QueryAssetsParams struct {
	AssetIDFilter    []byte
	TweakedScriptKey []byte
	AnchorPoint      []byte
	Leased           interface{}
	Now              sql.NullTime
	MinAnchorHeight  sql.NullInt32
	MinAmt           sql.NullInt64
	MaxAmt           sql.NullInt64
	Spent            sql.NullBool
	KeyGroupFilter   []byte
	AnchorUtxoID     sql.NullInt64
	GenesisID        sql.NullInt64
	ScriptKeyID      sql.NullInt64
	ScriptKeyType    sql.NullInt16
}

type QueryAssetsRow struct {
	AssetPrimaryKey          int64
	GenesisID                int64
	Version                  int32
	Spent                    bool
	ScriptKey                ScriptKey
	InternalKey              InternalKey
	TapscriptRoot            []byte
	WitnessStack             []byte
	TweakedGroupKey          []byte
	GroupKeyRaw              []byte
	GroupKeyFamily           sql.NullInt32
	GroupKeyIndex            sql.NullInt32
	ScriptVersion            int32
	Amount                   int64
	LockTime                 sql.NullInt32
	RelativeLockTime         sql.NullInt32
	AssetID                  []byte
	AssetTag                 string
	MetaHash                 []byte
	GenesisOutputIndex       int32
	AssetType                int16
	GenesisPrevOut           []byte
	AnchorTx                 []byte
	AnchorTxid               []byte
	AnchorBlockHash          []byte
	AnchorBlockHeight        sql.NullInt32
	AnchorOutpoint           []byte
	AnchorTapscriptSibling   []byte
	AnchorMerkleRoot         []byte
	AnchorTaprootAssetRoot   []byte
	AnchorCommitmentVersion  sql.NullInt16
	AnchorLeaseOwner         []byte
	AnchorLeaseExpiry        sql.NullTime
	AnchorInternalKey        []byte
	SplitCommitmentRootHash  []byte
	SplitCommitmentRootValue sql.NullInt64
}

// We use a LEFT JOIN here as not every asset has a group key, so this'll
// generate rows that have NULL values for the group key fields if an asset
// doesn't have a group key. See the comment in fetchAssetSprouts for a work
// around that needs to be used with this query until a sqlc bug is fixed.
// This clause is used to select specific assets for a asset ID, general
// channel balances, and also coin selection. We use the sqlc.narg feature to
// make the entire statement evaluate to true, if none of these extra args are
// specified.
func (q *Queries) QueryAssets(ctx context.Context, arg QueryAssetsParams) ([]QueryAssetsRow, error) {
	rows, err := q.db.QueryContext(ctx, QueryAssets,
		arg.AssetIDFilter,
		arg.TweakedScriptKey,
		arg.AnchorPoint,
		arg.Leased,
		arg.Now,
		arg.MinAnchorHeight,
		arg.MinAmt,
		arg.MaxAmt,
		arg.Spent,
		arg.KeyGroupFilter,
		arg.AnchorUtxoID,
		arg.GenesisID,
		arg.ScriptKeyID,
		arg.ScriptKeyType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryAssetsRow
	for rows.Next() {
		var i QueryAssetsRow
		if err := rows.Scan(
			&i.AssetPrimaryKey,
			&i.GenesisID,
			&i.Version,
			&i.Spent,
			&i.ScriptKey.ScriptKeyID,
			&i.ScriptKey.InternalKeyID,
			&i.ScriptKey.TweakedScriptKey,
			&i.ScriptKey.Tweak,
			&i.ScriptKey.KeyType,
			&i.InternalKey.KeyID,
			&i.InternalKey.RawKey,
			&i.InternalKey.KeyFamily,
			&i.InternalKey.KeyIndex,
			&i.TapscriptRoot,
			&i.WitnessStack,
			&i.TweakedGroupKey,
			&i.GroupKeyRaw,
			&i.GroupKeyFamily,
			&i.GroupKeyIndex,
			&i.ScriptVersion,
			&i.Amount,
			&i.LockTime,
			&i.RelativeLockTime,
			&i.AssetID,
			&i.AssetTag,
			&i.MetaHash,
			&i.GenesisOutputIndex,
			&i.AssetType,
			&i.GenesisPrevOut,
			&i.AnchorTx,
			&i.AnchorTxid,
			&i.AnchorBlockHash,
			&i.AnchorBlockHeight,
			&i.AnchorOutpoint,
			&i.AnchorTapscriptSibling,
			&i.AnchorMerkleRoot,
			&i.AnchorTaprootAssetRoot,
			&i.AnchorCommitmentVersion,
			&i.AnchorLeaseOwner,
			&i.AnchorLeaseExpiry,
			&i.AnchorInternalKey,
			&i.SplitCommitmentRootHash,
			&i.SplitCommitmentRootValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SetAssetSpent = `-- name: SetAssetSpent :one
WITH target_asset(asset_id) AS (
    SELECT assets.asset_id
    FROM assets
    JOIN script_keys
      ON assets.script_key_id = script_keys.script_key_id
    JOIN genesis_assets
      ON assets.genesis_id = genesis_assets.gen_asset_id
    JOIN managed_utxos utxos
         ON assets.anchor_utxo_id = utxos.utxo_id AND
            (utxos.outpoint = $1 OR
             $1 IS NULL)
    WHERE script_keys.tweaked_script_key = $2
     AND genesis_assets.asset_id = $3
)
UPDATE assets
SET spent = TRUE
WHERE asset_id = (SELECT asset_id FROM target_asset)
RETURNING assets.asset_id
`

type SetAssetSpentParams struct {
	AnchorPoint []byte
	ScriptKey   []byte
	GenAssetID  []byte
}

func (q *Queries) SetAssetSpent(ctx context.Context, arg SetAssetSpentParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, SetAssetSpent, arg.AnchorPoint, arg.ScriptKey, arg.GenAssetID)
	var asset_id int64
	err := row.Scan(&asset_id)
	return asset_id, err
}

const UpdateBatchGenesisTx = `-- name: UpdateBatchGenesisTx :exec
WITH target_batch AS (
    SELECT batch_id
    FROM asset_minting_batches batches
    JOIN internal_keys keys
        ON batches.batch_id = keys.key_id
    WHERE keys.raw_key = $1
)
UPDATE asset_minting_batches
SET minting_tx_psbt = $2
WHERE batch_id in (SELECT batch_id FROM target_batch)
`

type UpdateBatchGenesisTxParams struct {
	RawKey        []byte
	MintingTxPsbt []byte
}

func (q *Queries) UpdateBatchGenesisTx(ctx context.Context, arg UpdateBatchGenesisTxParams) error {
	_, err := q.db.ExecContext(ctx, UpdateBatchGenesisTx, arg.RawKey, arg.MintingTxPsbt)
	return err
}

const UpdateMintingBatchState = `-- name: UpdateMintingBatchState :exec
WITH target_batch AS (
    -- This CTE is used to fetch the ID of a batch, based on the serialized
    -- internal key associated with the batch. This internal key is used as the
    -- actual Taproot internal key to ultimately mint the batch. This pattern
    -- is used in several other queries.
    SELECT batch_id
    FROM asset_minting_batches batches
    JOIN internal_keys keys
        ON batches.batch_id = keys.key_id
    WHERE keys.raw_key = $1
)
UPDATE asset_minting_batches 
SET batch_state = $2
WHERE batch_id in (SELECT batch_id FROM target_batch)
`

type UpdateMintingBatchStateParams struct {
	RawKey     []byte
	BatchState int16
}

func (q *Queries) UpdateMintingBatchState(ctx context.Context, arg UpdateMintingBatchStateParams) error {
	_, err := q.db.ExecContext(ctx, UpdateMintingBatchState, arg.RawKey, arg.BatchState)
	return err
}

const UpdateUTXOLease = `-- name: UpdateUTXOLease :exec
UPDATE managed_utxos
SET lease_owner = $1, lease_expiry = $2
WHERE outpoint = $3
`

type UpdateUTXOLeaseParams struct {
	LeaseOwner  []byte
	LeaseExpiry sql.NullTime
	Outpoint    []byte
}

func (q *Queries) UpdateUTXOLease(ctx context.Context, arg UpdateUTXOLeaseParams) error {
	_, err := q.db.ExecContext(ctx, UpdateUTXOLease, arg.LeaseOwner, arg.LeaseExpiry, arg.Outpoint)
	return err
}

const UpsertAsset = `-- name: UpsertAsset :one
INSERT INTO assets (
    genesis_id, version, script_key_id, asset_group_witness_id, script_version, 
    amount, lock_time, relative_lock_time, anchor_utxo_id, spent
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
ON CONFLICT (genesis_id, script_key_id, anchor_utxo_id)
    -- This is a NOP, anchor_utxo_id is one of the unique fields that caused the
    -- conflict.
    DO UPDATE SET anchor_utxo_id = EXCLUDED.anchor_utxo_id
RETURNING asset_id
`

type UpsertAssetParams struct {
	GenesisID           int64
	Version             int32
	ScriptKeyID         int64
	AssetGroupWitnessID sql.NullInt64
	ScriptVersion       int32
	Amount              int64
	LockTime            sql.NullInt32
	RelativeLockTime    sql.NullInt32
	AnchorUtxoID        sql.NullInt64
	Spent               bool
}

func (q *Queries) UpsertAsset(ctx context.Context, arg UpsertAssetParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, UpsertAsset,
		arg.GenesisID,
		arg.Version,
		arg.ScriptKeyID,
		arg.AssetGroupWitnessID,
		arg.ScriptVersion,
		arg.Amount,
		arg.LockTime,
		arg.RelativeLockTime,
		arg.AnchorUtxoID,
		arg.Spent,
	)
	var asset_id int64
	err := row.Scan(&asset_id)
	return asset_id, err
}

const UpsertAssetGroupKey = `-- name: UpsertAssetGroupKey :one
INSERT INTO asset_groups (
    version, tweaked_group_key, tapscript_root, internal_key_id,
    genesis_point_id, custom_subtree_root_id
) VALUES (
    $1, $2, $3, $4, $5, $6
) ON CONFLICT (tweaked_group_key)
    -- This is not a NOP, update the genesis point ID in case it wasn't set
    -- before.
    DO UPDATE SET genesis_point_id = EXCLUDED.genesis_point_id
RETURNING group_id
`

type UpsertAssetGroupKeyParams struct {
	Version             int32
	TweakedGroupKey     []byte
	TapscriptRoot       []byte
	InternalKeyID       int64
	GenesisPointID      int64
	CustomSubtreeRootID sql.NullInt32
}

func (q *Queries) UpsertAssetGroupKey(ctx context.Context, arg UpsertAssetGroupKeyParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, UpsertAssetGroupKey,
		arg.Version,
		arg.TweakedGroupKey,
		arg.TapscriptRoot,
		arg.InternalKeyID,
		arg.GenesisPointID,
		arg.CustomSubtreeRootID,
	)
	var group_id int64
	err := row.Scan(&group_id)
	return group_id, err
}

const UpsertAssetGroupWitness = `-- name: UpsertAssetGroupWitness :one
INSERT INTO asset_group_witnesses (
    witness_stack, gen_asset_id, group_key_id
) VALUES (
    $1, $2, $3
) ON CONFLICT (gen_asset_id)
    -- This is a NOP, gen_asset_id is the unique field that caused the conflict.
    DO UPDATE SET gen_asset_id = EXCLUDED.gen_asset_id
RETURNING witness_id
`

type UpsertAssetGroupWitnessParams struct {
	WitnessStack []byte
	GenAssetID   int64
	GroupKeyID   int64
}

func (q *Queries) UpsertAssetGroupWitness(ctx context.Context, arg UpsertAssetGroupWitnessParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, UpsertAssetGroupWitness, arg.WitnessStack, arg.GenAssetID, arg.GroupKeyID)
	var witness_id int64
	err := row.Scan(&witness_id)
	return witness_id, err
}

const UpsertAssetMeta = `-- name: UpsertAssetMeta :one
INSERT INTO assets_meta (
    meta_data_hash, meta_data_blob, meta_data_type, meta_decimal_display,
    meta_universe_commitments, meta_canonical_universes, meta_delegation_key
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) ON CONFLICT (meta_data_hash)
    -- In this case, we may be inserting the data+type for an existing blob. So
    -- we'll set all of those values. At this layer we assume the meta hash
    -- has been validated elsewhere.
    DO UPDATE SET meta_data_blob = COALESCE(EXCLUDED.meta_data_blob, assets_meta.meta_data_blob),
                  meta_data_type = COALESCE(EXCLUDED.meta_data_type, assets_meta.meta_data_type),
                  meta_decimal_display = COALESCE(EXCLUDED.meta_decimal_display, assets_meta.meta_decimal_display),
                  meta_universe_commitments = COALESCE(EXCLUDED.meta_universe_commitments, assets_meta.meta_universe_commitments),
                  meta_canonical_universes = COALESCE(EXCLUDED.meta_canonical_universes, assets_meta.meta_canonical_universes),
                  meta_delegation_key = COALESCE(EXCLUDED.meta_delegation_key, assets_meta.meta_delegation_key)
        
RETURNING meta_id
`

type UpsertAssetMetaParams struct {
	MetaDataHash            []byte
	MetaDataBlob            []byte
	MetaDataType            sql.NullInt16
	MetaDecimalDisplay      sql.NullInt32
	MetaUniverseCommitments sql.NullBool
	MetaCanonicalUniverses  []byte
	MetaDelegationKey       []byte
}

func (q *Queries) UpsertAssetMeta(ctx context.Context, arg UpsertAssetMetaParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, UpsertAssetMeta,
		arg.MetaDataHash,
		arg.MetaDataBlob,
		arg.MetaDataType,
		arg.MetaDecimalDisplay,
		arg.MetaUniverseCommitments,
		arg.MetaCanonicalUniverses,
		arg.MetaDelegationKey,
	)
	var meta_id int64
	err := row.Scan(&meta_id)
	return meta_id, err
}

const UpsertAssetProofByID = `-- name: UpsertAssetProofByID :exec
INSERT INTO asset_proofs (
    asset_id, proof_file
) VALUES (
    $1, $2
) ON CONFLICT (asset_id)
    -- This is not a NOP, we always overwrite the proof with the new one.
    DO UPDATE SET proof_file = EXCLUDED.proof_file
`

type UpsertAssetProofByIDParams struct {
	AssetID   int64
	ProofFile []byte
}

func (q *Queries) UpsertAssetProofByID(ctx context.Context, arg UpsertAssetProofByIDParams) error {
	_, err := q.db.ExecContext(ctx, UpsertAssetProofByID, arg.AssetID, arg.ProofFile)
	return err
}

const UpsertAssetWitness = `-- name: UpsertAssetWitness :exec
INSERT INTO asset_witnesses (
    asset_id, prev_out_point, prev_asset_id, prev_script_key, witness_stack,
    split_commitment_proof, witness_index
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)  ON CONFLICT (asset_id, witness_index)
    -- We overwrite the witness with the new one.
    DO UPDATE SET prev_out_point = EXCLUDED.prev_out_point,
                  prev_asset_id = EXCLUDED.prev_asset_id,
                  prev_script_key = EXCLUDED.prev_script_key,
                  witness_stack = EXCLUDED.witness_stack,
                  split_commitment_proof = EXCLUDED.split_commitment_proof
`

type UpsertAssetWitnessParams struct {
	AssetID              int64
	PrevOutPoint         []byte
	PrevAssetID          []byte
	PrevScriptKey        []byte
	WitnessStack         []byte
	SplitCommitmentProof []byte
	WitnessIndex         int32
}

func (q *Queries) UpsertAssetWitness(ctx context.Context, arg UpsertAssetWitnessParams) error {
	_, err := q.db.ExecContext(ctx, UpsertAssetWitness,
		arg.AssetID,
		arg.PrevOutPoint,
		arg.PrevAssetID,
		arg.PrevScriptKey,
		arg.WitnessStack,
		arg.SplitCommitmentProof,
		arg.WitnessIndex,
	)
	return err
}

const UpsertChainTx = `-- name: UpsertChainTx :one
INSERT INTO chain_txns (
    txid, raw_tx, chain_fees, block_height, block_hash, tx_index
) VALUES (
    $1, $2, $3, $4, $5,
    $6
) ON CONFLICT (txid)
    -- Not a NOP but instead update any nullable fields that aren't null in the
    -- args.
    DO UPDATE SET block_height = COALESCE(EXCLUDED.block_height, chain_txns.block_height),
                  block_hash = COALESCE(EXCLUDED.block_hash, chain_txns.block_hash),
                  tx_index = COALESCE(EXCLUDED.tx_index, chain_txns.tx_index)
RETURNING txn_id
`

type UpsertChainTxParams struct {
	Txid        []byte
	RawTx       []byte
	ChainFees   int64
	BlockHeight sql.NullInt32
	BlockHash   []byte
	TxIndex     sql.NullInt32
}

func (q *Queries) UpsertChainTx(ctx context.Context, arg UpsertChainTxParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, UpsertChainTx,
		arg.Txid,
		arg.RawTx,
		arg.ChainFees,
		arg.BlockHeight,
		arg.BlockHash,
		arg.TxIndex,
	)
	var txn_id int64
	err := row.Scan(&txn_id)
	return txn_id, err
}

const UpsertGenesisAsset = `-- name: UpsertGenesisAsset :one
WITH target_meta_id AS (
    SELECT meta_id
    FROM assets_meta
    WHERE meta_data_hash = $1
)
INSERT INTO genesis_assets (
    asset_id, asset_tag, meta_data_id, output_index, asset_type, genesis_point_id
) VALUES (
    $2, $3, (SELECT meta_id FROM target_meta_id), $4, $5, $6
) ON CONFLICT (asset_id)
    -- This is a NOP, asset_id is the unique field that caused the conflict.
    DO UPDATE SET asset_id = EXCLUDED.asset_id
RETURNING gen_asset_id
`

type UpsertGenesisAssetParams struct {
	MetaDataHash   []byte
	AssetID        []byte
	AssetTag       string
	OutputIndex    int32
	AssetType      int16
	GenesisPointID int64
}

func (q *Queries) UpsertGenesisAsset(ctx context.Context, arg UpsertGenesisAssetParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, UpsertGenesisAsset,
		arg.MetaDataHash,
		arg.AssetID,
		arg.AssetTag,
		arg.OutputIndex,
		arg.AssetType,
		arg.GenesisPointID,
	)
	var gen_asset_id int64
	err := row.Scan(&gen_asset_id)
	return gen_asset_id, err
}

const UpsertGenesisPoint = `-- name: UpsertGenesisPoint :one
INSERT INTO genesis_points(
    prev_out
) VALUES (
    $1
) ON CONFLICT (prev_out)
    -- This is a NOP, prev_out is the unique field that caused the conflict.
    DO UPDATE SET prev_out = EXCLUDED.prev_out
RETURNING genesis_id
`

func (q *Queries) UpsertGenesisPoint(ctx context.Context, prevOut []byte) (int64, error) {
	row := q.db.QueryRowContext(ctx, UpsertGenesisPoint, prevOut)
	var genesis_id int64
	err := row.Scan(&genesis_id)
	return genesis_id, err
}

const UpsertInternalKey = `-- name: UpsertInternalKey :one
INSERT INTO internal_keys (
    raw_key,  key_family, key_index
) VALUES (
    $1, $2, $3
) ON CONFLICT (raw_key)
    -- This is a NOP, raw_key is the unique field that caused the conflict.
    DO UPDATE SET raw_key = EXCLUDED.raw_key
RETURNING key_id
`

type UpsertInternalKeyParams struct {
	RawKey    []byte
	KeyFamily int32
	KeyIndex  int32
}

func (q *Queries) UpsertInternalKey(ctx context.Context, arg UpsertInternalKeyParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, UpsertInternalKey, arg.RawKey, arg.KeyFamily, arg.KeyIndex)
	var key_id int64
	err := row.Scan(&key_id)
	return key_id, err
}

const UpsertManagedUTXO = `-- name: UpsertManagedUTXO :one
WITH target_key(key_id) AS (
    SELECT key_id
    FROM internal_keys
    WHERE raw_key = $1
)
INSERT INTO managed_utxos (
    outpoint, amt_sats, internal_key_id, tapscript_sibling, merkle_root, txn_id,
    taproot_asset_root, root_version
) VALUES (
    $2, $3, (SELECT key_id FROM target_key), $4, $5, $6, $7, $8
) ON CONFLICT (outpoint)
   -- Not a NOP but instead update any nullable fields that aren't null in the
   -- args.
   DO UPDATE SET tapscript_sibling = COALESCE(EXCLUDED.tapscript_sibling, managed_utxos.tapscript_sibling)
RETURNING utxo_id
`

type UpsertManagedUTXOParams struct {
	RawKey           []byte
	Outpoint         []byte
	AmtSats          int64
	TapscriptSibling []byte
	MerkleRoot       []byte
	TxnID            int64
	TaprootAssetRoot []byte
	RootVersion      sql.NullInt16
}

func (q *Queries) UpsertManagedUTXO(ctx context.Context, arg UpsertManagedUTXOParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, UpsertManagedUTXO,
		arg.RawKey,
		arg.Outpoint,
		arg.AmtSats,
		arg.TapscriptSibling,
		arg.MerkleRoot,
		arg.TxnID,
		arg.TaprootAssetRoot,
		arg.RootVersion,
	)
	var utxo_id int64
	err := row.Scan(&utxo_id)
	return utxo_id, err
}

const UpsertMintAnchorUniCommitment = `-- name: UpsertMintAnchorUniCommitment :one
INSERT INTO mint_anchor_uni_commitments (
    id, batch_id, tx_output_index, taproot_internal_key, group_key
)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(batch_id, tx_output_index) DO UPDATE SET
    -- The following fields are updated if a conflict occurs.
    taproot_internal_key = EXCLUDED.taproot_internal_key,
    group_key = EXCLUDED.group_key
RETURNING id
`

type UpsertMintAnchorUniCommitmentParams struct {
	ID                 int64
	BatchID            int32
	TxOutputIndex      int32
	TaprootInternalKey []byte
	GroupKey           []byte
}

// Upsert a record into the mint_anchor_uni_commitments table.
// If a record with the same batch_id and group_key already exists, update the
// existing record. Otherwise, insert a new record.
func (q *Queries) UpsertMintAnchorUniCommitment(ctx context.Context, arg UpsertMintAnchorUniCommitmentParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, UpsertMintAnchorUniCommitment,
		arg.ID,
		arg.BatchID,
		arg.TxOutputIndex,
		arg.TaprootInternalKey,
		arg.GroupKey,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const UpsertScriptKey = `-- name: UpsertScriptKey :one
INSERT INTO script_keys (
    internal_key_id, tweaked_script_key, tweak, key_type
) VALUES (
    $1, $2, $3, $4
)  ON CONFLICT (tweaked_script_key)
    -- Overwrite the declared_known, key_type and tweak fields if they were
    -- previously unknown.
    DO UPDATE SET 
      tweaked_script_key = EXCLUDED.tweaked_script_key,
      -- If the tweak was previously unknown, we'll update to the new value.
      tweak =
          CASE
             WHEN script_keys.tweak IS NULL
             THEN COALESCE(EXCLUDED.tweak, script_keys.tweak)
             ELSE script_keys.tweak
           END,
      -- We only overwrite the key type with a value that does not mean
      -- "unknown" (0 or NULL).
        key_type =
          CASE
             WHEN COALESCE(EXCLUDED.key_type, 0) != 0
             THEN EXCLUDED.key_type
             ELSE script_keys.key_type
           END
RETURNING script_key_id
`

type UpsertScriptKeyParams struct {
	InternalKeyID    int64
	TweakedScriptKey []byte
	Tweak            []byte
	KeyType          sql.NullInt16
}

func (q *Queries) UpsertScriptKey(ctx context.Context, arg UpsertScriptKeyParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, UpsertScriptKey,
		arg.InternalKeyID,
		arg.TweakedScriptKey,
		arg.Tweak,
		arg.KeyType,
	)
	var script_key_id int64
	err := row.Scan(&script_key_id)
	return script_key_id, err
}

const UpsertTapscriptTreeEdge = `-- name: UpsertTapscriptTreeEdge :one
INSERT INTO tapscript_edges (
    root_hash_id, node_index, raw_node_id
) VALUES (
    $1, $2, $3
) ON CONFLICT (root_hash_id, node_index, raw_node_id)
    -- This is a NOP, root_hash_id, node_index, and raw_node_id are the unique
    -- fields that caused the conflict.
    DO UPDATE SET root_hash_id = EXCLUDED.root_hash_id,
    node_index = EXCLUDED.node_index, raw_node_id = EXCLUDED.raw_node_id
RETURNING edge_id
`

type UpsertTapscriptTreeEdgeParams struct {
	RootHashID int64
	NodeIndex  int64
	RawNodeID  int64
}

func (q *Queries) UpsertTapscriptTreeEdge(ctx context.Context, arg UpsertTapscriptTreeEdgeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, UpsertTapscriptTreeEdge, arg.RootHashID, arg.NodeIndex, arg.RawNodeID)
	var edge_id int64
	err := row.Scan(&edge_id)
	return edge_id, err
}

const UpsertTapscriptTreeNode = `-- name: UpsertTapscriptTreeNode :one
INSERT INTO tapscript_nodes (
    raw_node
) VALUES (
    $1
) ON CONFLICT (raw_node)
    -- This is a NOP, raw_node is the unique field that caused the conflict.
    DO UPDATE SET raw_node = EXCLUDED.raw_node
RETURNING node_id
`

func (q *Queries) UpsertTapscriptTreeNode(ctx context.Context, rawNode []byte) (int64, error) {
	row := q.db.QueryRowContext(ctx, UpsertTapscriptTreeNode, rawNode)
	var node_id int64
	err := row.Scan(&node_id)
	return node_id, err
}

const UpsertTapscriptTreeRootHash = `-- name: UpsertTapscriptTreeRootHash :one
INSERT INTO tapscript_roots (
    root_hash, branch_only
) VALUES (
    $1, $2
) ON CONFLICT (root_hash)
    -- This is a NOP, the root_hash is the unique field that caused the
    -- conflict. The tree should be deleted before switching between branch and
    -- leaf storage for the same root hash.
    DO UPDATE SET root_hash = EXCLUDED.root_hash
RETURNING root_id
`

type UpsertTapscriptTreeRootHashParams struct {
	RootHash   []byte
	BranchOnly bool
}

func (q *Queries) UpsertTapscriptTreeRootHash(ctx context.Context, arg UpsertTapscriptTreeRootHashParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, UpsertTapscriptTreeRootHash, arg.RootHash, arg.BranchOnly)
	var root_id int64
	err := row.Scan(&root_id)
	return root_id, err
}
