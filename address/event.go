package address

import (
	"context"
	"crypto/sha256"
	"fmt"
	"time"

	"github.com/btcsuite/btcd/btcec/v2"
	"github.com/btcsuite/btcd/btcutil"
	"github.com/btcsuite/btcd/chaincfg/chainhash"
	"github.com/btcsuite/btcd/wire"
	"github.com/lightninglabs/lndclient"
	"github.com/lightninglabs/taproot-assets/asset"
	"github.com/lightninglabs/taproot-assets/commitment"
	"github.com/lightninglabs/taproot-assets/fn"
	"github.com/lightninglabs/taproot-assets/proof"
)

// Status denotes an address event's current status.
type Status uint8

const (
	// StatusTransactionDetected denotes that a transaction for an incoming
	// asset transfer was detected but the transaction hasn't been confirmed
	// yet.
	StatusTransactionDetected Status = 0

	// StatusTransactionConfirmed denotes that the transaction for an
	// incoming asset transfer was confirmed. The transfer now requires the
	// proof to be imported to proceed.
	StatusTransactionConfirmed Status = 1

	// StatusProofReceived denotes that the proof for an incoming asset
	// transfer was received and is now being validated and processed.
	StatusProofReceived Status = 2

	// StatusCompleted denotes that an incoming asset transfer was completed
	// successfully and the local node has taken over custody of the assets
	// that were transferred.
	StatusCompleted Status = 3
)

// EventQueryParams holds the set of query params for address events.
type EventQueryParams struct {
	// AddrTaprootOutputKey is the optional 32-byte x-only serialized
	// Taproot output key of the address to filter by. Must be set to nil
	// to return events for all addresses.
	AddrTaprootOutputKey []byte

	// StatusFrom is the smallest status to query for (inclusive). Can be
	// set to nil to return events of all states.
	StatusFrom *Status

	// StatusTo is the largest status to query for (inclusive). Can be
	// set to nil to return events of all states.
	StatusTo *Status

	// CreationTimeFrom is the earliest creation time to query for
	// (inclusive). Can be set to nil to return events of all creation
	// times.
	CreationTimeFrom *time.Time
}

// AssetOutput holds the information about a single asset output that was sent
// as part of an incoming asset transfer. Each event can have multiple outputs,
// in case multiple tranches of a grouped asset were transferred using a V2
// address.
type AssetOutput struct {
	// Amount is the amount of this asset output.
	Amount uint64

	// ScriptKey is the serialized script key that can be used to spend the
	// output.
	ScriptKey asset.ScriptKey
}

// Event represents a single incoming asset transfer that was initiated by
// sending an on-chain transaction to the Taproot output key generated by a
// Taproot Asset address. Each event represents a single on-chain UTXO that is
// being taken custody of and is being tracked/watched by the internal wallet.
// One Taproot Asset address can receive multiple times and therefore can have
// multiple events.
type Event struct {
	// ID is the database primary key ID of the address event.
	ID int64

	// CreationTime is the time the event was first created.
	CreationTime time.Time

	// Addr is the Taproot Asset address that was used to receive the
	// assets.
	Addr *AddrWithKeyInfo

	// Status represents the current status of the incoming assets.
	Status Status

	// Outpoint is the on-chain transaction outpoint that contains the
	// Taproot Asset commitment for the incoming asset transfer.
	Outpoint wire.OutPoint

	// Amt is the amount of satoshis that were transferred in the Bitcoin
	// on-chain transaction. This is independent of the asset amount, which
	// can be looked up through the Addr field.
	Amt btcutil.Amount

	// InternalKey is the key used as the internal key for the on-chain
	// Taproot output. The internal key tweaked with the Taproot Asset
	// commitment (when NO tapscript sibling if present) is equal to the
	// TaprootOutputKey of the Addr.
	InternalKey *btcec.PublicKey

	// The map of asset ID to AssetOutput that contains the amount and
	// script key of each asset output that was sent as part of the incoming
	// asset transfer.
	Outputs map[asset.ID]AssetOutput

	// ConfirmationHeight is the block height at which the incoming asset
	// transfer transaction was first confirmed.
	ConfirmationHeight uint32

	// HasAllProofs indicates that a proof for each output of this transfer
	// was imported. We don't keep a reference to them in memory as the
	// proofs themselves can be large. The proofs can be fetched by the
	// script keys of the address.
	HasAllProofs bool
}

// EventSource is a struct that holds the information about an incoming asset
// transfer that was detected on-chain. This is used to create an Event
// instance that can be stored in the database.
type EventSource struct {
	// Addr is the Taproot Asset address that was used to receive the
	// assets.
	Addr *AddrWithKeyInfo

	// Tx is the on-chain transaction that contains the Taproot Asset
	// commitment for the incoming asset transfer.
	Tx *wire.MsgTx

	// OutputIdx is the index of the output in the transaction that contains
	// the Taproot Asset commitment for the incoming asset transfer.
	OutputIdx uint32

	// CommitmentVersion is the version of the Taproot Asset commitment
	// that was used to create the Taproot Asset address.
	CommitmentVersion commitment.TapCommitmentVersion

	// TaprootAssetRoot is the root of the Taproot Asset commitment tree
	// that was used to create the Taproot Asset address.
	TaprootAssetRoot [sha256.Size]byte

	// BlockHeight is the height of the block that contains the transaction.
	BlockHeight uint32

	// BlockHash is the hash of the block that contains the transaction.
	BlockHash *chainhash.Hash

	// Outputs is a map of asset IDs to the outputs that are being sent.
	Outputs map[asset.ID]AssetOutput
}

// NewSourceFromWalletTx creates a new EventSource from a wallet transaction
// and the address that was used to receive the assets. This can only be used
// for V0 and V1 addresses.
func NewSourceFromWalletTx(addr *AddrWithKeyInfo,
	walletTx *lndclient.Transaction, outputIdx uint32,
	outputs map[asset.ID]AssetOutput) (EventSource, error) {

	if addr.Version > V1 {
		return EventSource{}, fmt.Errorf("address version %d is not "+
			"supported for event source creation", addr.Version)
	}

	var blockHash *chainhash.Hash
	if walletTx.Confirmations > 0 {
		var err error
		blockHash, err = chainhash.NewHashFromStr(walletTx.BlockHash)
		if err != nil {
			return EventSource{}, fmt.Errorf("error parsing block "+
				"hash: %w", err)
		}
	}

	expectedCommitment, err := addr.TapCommitment()
	if err != nil {
		return EventSource{}, fmt.Errorf("error getting taproot asset "+
			"commitment: %w", err)
	}
	taprootAssetRoot := expectedCommitment.TapscriptRoot(nil)

	return EventSource{
		Addr:              addr,
		Tx:                walletTx.Tx,
		OutputIdx:         outputIdx,
		CommitmentVersion: expectedCommitment.Version,
		TaprootAssetRoot:  taprootAssetRoot,
		BlockHeight:       uint32(walletTx.BlockHeight),
		BlockHash:         blockHash,
		Outputs:           outputs,
	}, nil
}

// NewSourceFromFragment creates a new EventSource from a SendFragment, the
// block that contains the TX and the address that was used to receive the
// assets. This can only be used for V2 addresses.
func NewSourceFromFragment(addr *AddrWithKeyInfo, block *wire.MsgBlock,
	fragment *proof.SendFragment,
	outputs map[asset.ID]AssetOutput) (EventSource, error) {

	if addr.Version < V2 {
		return EventSource{}, fmt.Errorf("address version %d is not "+
			"supported for event source creation", addr.Version)
	}

	commitmentVersion, err := CommitmentVersion(addr.Version)
	if err != nil {
		return EventSource{}, err
	}

	var walletTx *wire.MsgTx
	for _, tx := range block.Transactions {
		if tx.TxHash() == fragment.OutPoint.Hash {
			walletTx = tx
			break
		}
	}

	if walletTx == nil {
		return EventSource{}, fmt.Errorf("unable to find transaction "+
			"%s in block %s", fragment.OutPoint.Hash,
			fragment.BlockHeader.BlockHash())
	}

	return EventSource{
		Addr:              addr,
		Tx:                walletTx,
		OutputIdx:         fragment.OutPoint.Index,
		CommitmentVersion: *commitmentVersion,
		Outputs:           outputs,
		TaprootAssetRoot:  fragment.TaprootAssetRoot,
		BlockHeight:       fragment.BlockHeight,
		BlockHash:         fn.Ptr(fragment.BlockHeader.BlockHash()),
	}, nil
}

// EventStorage is the interface that a component storing address events should
// implement.
type EventStorage interface {
	// GetOrCreateEvent creates a new address event for the given status,
	// address and transaction. If an event for that address and transaction
	// already exists, then the status and transaction information is
	// updated instead.
	GetOrCreateEvent(ctx context.Context, status Status,
		source EventSource) (*Event, error)

	// QueryAddrEvents returns a list of event that match the given query
	// parameters.
	QueryAddrEvents(ctx context.Context, params EventQueryParams) ([]*Event,
		error)

	// QueryEvent returns a single address event by its address and
	// outpoint.
	QueryEvent(ctx context.Context, addr *AddrWithKeyInfo,
		outpoint wire.OutPoint) (*Event, error)

	// CompleteEvent updates an address event as being complete and links it
	// with the proof and asset that was imported/created for it.
	CompleteEvent(ctx context.Context, event *Event, status Status,
		anchorPoint wire.OutPoint) error
}
